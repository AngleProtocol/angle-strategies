{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"IERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/external/AccessControlAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../interfaces/IAccessControlAngle.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControl`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlAngle is Context, IAccessControlAngle {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == _msgSender(), \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/external/AccessControlAngleUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IAccessControlAngle.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControlUpgradeable`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlAngleUpgradeable is Initializable, IAccessControlAngle {\n    // solhint-disable-next-line\n    function __AccessControl_init() internal initializer {\n        __AccessControl_init_unchained();\n    }\n\n    // solhint-disable-next-line\n    function __AccessControl_init_unchained() internal initializer {}\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == msg.sender, \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/external/ComputePower.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nlibrary ComputePower {\n    /// @notice Calculates (1+x)**n where x is a small number in base `base`\n    /// @param ratePerSecond x value\n    /// @param exp n value\n    /// @param base Base in which the `ratePerSecond` is\n    /// @dev This function avoids expensive exponentiation and the calculation is performed using a binomial approximation\n    /// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3...\n    /// @dev This function was mostly inspired from Aave implementation and comes with the advantage of a great gas cost\n    /// reduction with respect to the base power implementation\n    function computePower(\n        uint256 ratePerSecond,\n        uint256 exp,\n        uint256 base\n    ) internal pure returns (uint256) {\n        if (exp == 0 || ratePerSecond == 0) return base;\n        uint256 halfBase = base / 2;\n        uint256 expMinusOne = exp - 1;\n        uint256 expMinusTwo = exp > 2 ? exp - 2 : 0;\n        uint256 basePowerTwo = (ratePerSecond * ratePerSecond + halfBase) / base;\n        uint256 basePowerThree = (basePowerTwo * ratePerSecond + halfBase) / base;\n        uint256 secondTerm = (exp * expMinusOne * basePowerTwo) / 2;\n        uint256 thirdTerm = (exp * expMinusOne * expMinusTwo * basePowerThree) / 6;\n        return base + ratePerSecond * exp + secondTerm + thirdTerm;\n    }\n}\n"
    },
    "contracts/external/FullMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.4.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev This contract was forked from Uniswap V3's contract `FullMath.sol` available here\n/// https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol\n//solhint-disable\nabstract contract FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function _mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n}\n"
    },
    "contracts/external/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n * This contract was fully forked from OpenZeppelin `ProxyAdmin`\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n    }\n}\n"
    },
    "contracts/external/RPow.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n// From MakerDAO DSS\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nlibrary RPow {\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 base\n    ) internal pure returns (uint256 z) {\n        // solhint-disable-next-line\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    z := base\n                }\n                default {\n                    z := x\n                }\n                let half := div(base, 2) // for rounding.\n                for {\n                    n := div(n, 2)\n                } n {\n                    n := div(n, 2)\n                } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) {\n                        revert(0, 0)\n                    }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n                    x := div(xxRound, base)\n                    if mod(n, 2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                            revert(0, 0)\n                        }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/interfaces/external/aave/IAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n}\n\ninterface IOptionalERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IPriceOracle {\n    function getAssetPrice(address _asset) external view returns (uint256);\n\n    function getAssetsPrices(address[] calldata _assets) external view returns (uint256[] memory);\n\n    function getSourceOfAsset(address _asset) external view returns (address);\n\n    function getFallbackOracle() external view returns (address);\n}\n\ninterface IStakedAave is IERC20 {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address) external view returns (uint256);\n\n    // solhint-disable-next-line\n    function COOLDOWN_SECONDS() external view returns (uint256);\n\n    function stakersCooldowns(address) external view returns (uint256);\n\n    // solhint-disable-next-line\n    function UNSTAKE_WINDOW() external view returns (uint256);\n}\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n    function baseVariableBorrowRate() external view returns (uint256);\n\n    function getMaxVariableBorrowRate() external view returns (uint256);\n\n    function stableRateSlope1() external view returns (uint256);\n\n    function stableRateSlope2() external view returns (uint256);\n\n    function variableRateSlope1() external view returns (uint256);\n\n    function variableRateSlope2() external view returns (uint256);\n\n    // solhint-disable-next-line\n    function OPTIMAL_UTILIZATION_RATE() external view returns (uint256);\n\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n\n    function calculateInterestRates(\n        address reserve,\n        address aToken,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n}\n"
    },
    "contracts/interfaces/external/aave/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IAaveIncentivesController {\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    // solhint-disable-next-line\n    function REWARD_TOKEN() external view returns (address);\n\n    function getDistributionEnd() external view returns (uint256);\n\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function assets(address asset)\n        external\n        view\n        returns (\n            uint256 emissionPerSecond,\n            uint256 index,\n            uint256 lastUpdateTimestamp\n        );\n\n    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n}\n"
    },
    "contracts/interfaces/external/aave/IAaveToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IAaveIncentivesController.sol\";\nimport \"./ILendingPool.sol\";\n\ninterface IScaledBalanceToken {\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     **/\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @dev Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled balance and the scaled total supply\n     **/\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n    /**\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n     * @return The scaled total supply\n     **/\n    function scaledTotalSupply() external view returns (uint256);\n}\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n **/\ninterface IVariableDebtToken is IERC20, IScaledBalanceToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param onBehalfOf The address of the user on which behalf minting has been performed\n     * @param value The amount to be minted\n     * @param index The last index of the reserve\n     **/\n    event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\n\n    /**\n     * @dev Mints debt token to the `onBehalfOf` address\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\n     * of credit delegate, or same as `onBehalfOf` otherwise\n     * @param onBehalfOf The address receiving the debt tokens\n     * @param amount The amount of debt being minted\n     * @param index The variable debt index of the reserve\n     * @return `true` if the the previous balance of the user is 0\n     **/\n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when variable debt is burnt\n     * @param user The user which debt has been burned\n     * @param amount The amount of debt being burned\n     * @param index The index of the user\n     **/\n    event Burn(address indexed user, uint256 amount, uint256 index);\n\n    /**\n     * @dev Burns user variable debt\n     * @param user The user which debt is burnt\n     * @param index The variable debt index of the reserve\n     **/\n    function burn(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n}\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n    /**\n     * @dev Emitted when an aToken is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param pool The address of the associated lending pool\n     * @param treasury The address of the treasury\n     * @param incentivesController The address of the incentives controller for this aToken\n     * @param aTokenDecimals the decimals of the underlying\n     * @param aTokenName the name of the aToken\n     * @param aTokenSymbol the symbol of the aToken\n     * @param params A set of encoded parameters for additional initialization\n     **/\n    event Initialized(\n        address indexed underlyingAsset,\n        address indexed pool,\n        address treasury,\n        address incentivesController,\n        uint8 aTokenDecimals,\n        string aTokenName,\n        string aTokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @dev Initializes the aToken\n     * @param pool The address of the lending pool where this aToken will be used\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @param incentivesController The smart contract managing potential incentives distribution\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n     * @param aTokenName The name of the aToken\n     * @param aTokenSymbol The symbol of the aToken\n     */\n    function initialize(\n        ILendingPool pool,\n        address treasury,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 aTokenDecimals,\n        string calldata aTokenName,\n        string calldata aTokenSymbol,\n        bytes calldata params\n    ) external;\n}\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param value The amount being\n     * @param index The new liquidity index of the reserve\n     **/\n    event Mint(address indexed from, uint256 value, uint256 index);\n\n    /**\n     * @dev Mints `amount` aTokens to `user`\n     * @param user The address receiving the minted tokens\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted after aTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param target The address that will receive the underlying\n     * @param value The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n    /**\n     * @dev Emitted during the transfer action\n     * @param from The user whose tokens are being transferred\n     * @param to The recipient\n     * @param value The amount being transferred\n     * @param index The new liquidity index of the reserve\n     **/\n    event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n    /**\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @param user The owner of the aTokens, getting them burned\n     * @param receiverOfUnderlying The address that will receive the underlying\n     * @param amount The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    function burn(\n        address user,\n        address receiverOfUnderlying,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Mints aTokens to the reserve treasury\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     */\n    function mintToTreasury(uint256 amount, uint256 index) external;\n\n    /**\n     * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n     * @param from The address getting liquidated, current owner of the aTokens\n     * @param to The recipient\n     * @param value The amount of tokens getting transferred\n     **/\n    function transferOnLiquidation(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    /**\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n     * assets in borrow(), withdraw() and flashLoan()\n     * @param user The recipient of the underlying\n     * @param amount The amount getting transferred\n     * @return The amount transferred\n     **/\n    function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n    /**\n     * @dev Invoked to execute actions on the aToken side after a repayment.\n     * @param user The user executing the repayment\n     * @param amount The amount getting repaid\n     **/\n    function handleRepayment(address user, uint256 amount) external;\n\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n\n    /**\n     * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     **/\n    // solhint-disable-next-line\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { DataTypes } from \"./IAave.sol\";\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { ILendingPoolAddressesProvider } from \"./ILendingPool.sol\";\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    // solhint-disable-next-line\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n"
    },
    "contracts/interfaces/external/compound/CErc20I.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./CTokenI.sol\";\n\ninterface CErc20I is CTokenI {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function decimals() external returns (uint8);\n\n    function accrueInterest() external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/CEtherI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./CTokenI.sol\";\n\ninterface CEtherI is CTokenI {\n    function mint() external payable;\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/CTokenI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\nimport \"./InterestRateModel.sol\";\n\ninterface CTokenI {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function interestRateModel() external view returns (InterestRateModel);\n\n    function totalReserves() external view returns (uint256);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./CTokenI.sol\";\n\ninterface IComptroller {\n    function compSupplySpeeds(address cToken) external view returns (uint256);\n\n    function claimComp(\n        address[] memory holders,\n        CTokenI[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface InterestRateModel {\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n\n    // Rinkeby function\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 _reserves\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/external/convex/frax/IBoosterFrax.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IBoosterFrax {\n    function createVault(uint256 _pid) external;\n}\n"
    },
    "contracts/interfaces/external/convex/frax/IFeeRegistryFrax.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IFeeRegistryFrax {\n    function totalFees() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/convex/frax/IPoolRegistryFrax.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IPoolRegistryFrax {\n    //clone a new user vault\n    function vaultMap(uint256 _pid, address _user) external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/convex/frax/IStakingProxyERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IStakingProxyERC20 {\n    //create a new locked state of _secs timelength\n    function stakeLocked(uint256 _liquidity, uint256 _secs) external;\n\n    //add to a current lock\n    // solhint-disable-next-line\n    function lockAdditional(bytes32 _kek_id, uint256 _addl_liq) external;\n\n    //withdraw a staked position\n    // solhint-disable-next-line\n    function withdrawLocked(bytes32 _kek_id) external;\n\n    //helper function to combine earned tokens on staking contract and any tokens that are on this vault\n    // solhint-disable-next-line\n    function earned() external view returns (address[] memory token_addresses, uint256[] memory total_earned);\n\n    /*\n    claim flow:\n        claim rewards directly to the vault\n        calculate fees to send to fee deposit\n        send fxs to booster for fees\n        get reward list of tokens that were received\n        send all remaining tokens to owner\n\n    A slightly less gas intensive approach could be to send rewards directly to booster and have it sort everything out.\n    However that makes the logic a bit more complex as well as runs a few future proofing risks\n    */\n    function getReward() external;\n\n    //get reward with claim option.\n    //_claim bool is for the off chance that rewardCollectionPause is true so getReward() fails but\n    //there are tokens on this vault for cases such as withdraw() also calling claim.\n    //can also be used to rescue tokens on the vault\n    function getReward(bool _claim) external;\n}\n"
    },
    "contracts/interfaces/external/convex/IBaseRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IConvexBaseRewardPool {\n    function balanceOf(address account) external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function getReward() external returns (bool);\n\n    function getReward(address _account, bool _claimExtras) external returns (bool);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function newRewardRatio() external view returns (uint256);\n\n    function periodFinish() external view returns (uint256);\n\n    function pid() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function stake(uint256 _amount) external returns (bool);\n\n    function stakeAll() external returns (bool);\n\n    function stakeFor(address _for, uint256 _amount) external returns (bool);\n\n    function stakingToken() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n\n    function withdraw(uint256 amount, bool claim) external returns (bool);\n\n    function withdrawAll(bool claim) external;\n\n    function withdrawAllAndUnwrap(bool claim) external;\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\n}\n"
    },
    "contracts/interfaces/external/convex/IBooster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n// solhint-disable\ninterface IConvexBooster {\n    function FEE_DENOMINATOR() external view returns (uint256);\n\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool);\n\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool);\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    function gaugeMap(address) external view returns (bool);\n\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    function staker() external view returns (address);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function withdrawAll(uint256 _pid) external returns (bool);\n\n    function withdrawTo(\n        uint256 _pid,\n        uint256 _amount,\n        address _to\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/external/convex/IClaimZap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IConvexClaimZap {\n    function claimRewards(\n        address[] calldata rewardContracts,\n        address[] calldata extraRewardContracts,\n        address[] calldata tokenRewardContracts,\n        address[] calldata tokenRewardTokens,\n        uint256 depositCrvMaxAmount,\n        uint256 minAmountOut,\n        uint256 depositCvxMaxAmount,\n        uint256 spendCvxAmount,\n        uint256 options\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/convex/ICvxRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface ICvxRewardPool {\n    function balanceOf(address account) external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function getReward(bool stake) external returns (bool);\n\n    function getReward(\n        address _account,\n        bool _claimExtras,\n        bool stake\n    ) external returns (bool);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function stake(uint256 _amount) external returns (bool);\n\n    function stakeAll() external returns (bool);\n\n    function stakeFor(address _for, uint256 _amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function withdraw(uint256 amount, bool claim) external returns (bool);\n\n    function withdrawAll(bool claim) external;\n}\n"
    },
    "contracts/interfaces/external/convex/IVirtualBalanceRewardPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface IVirtualBalanceRewardPool {\n    function balanceOf(address account) external view returns (uint256);\n\n    function currentRewards() external view returns (uint256);\n\n    function deposits() external view returns (address);\n\n    function duration() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _account) external;\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function lastUpdateTime() external view returns (uint256);\n\n    function operator() external view returns (address);\n\n    function periodFinish() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function rewards(address) external view returns (uint256);\n\n    function stake(address _account, uint256 amount) external;\n\n    function totalSupply() external view returns (uint256);\n\n    function withdraw(address _account, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveCryptoSwapPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// solhint-disable\ninterface ICurveCryptoSwapPool is IERC20 {\n    function A() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_fee(uint256[3] memory amounts, uint256[3] memory xp) external view returns (uint256);\n\n    function calc_token_amount(uint256[3] memory amounts, bool deposit) external view returns (uint256);\n\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[3] memory amounts, uint256 max_burn_amount) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/curve/IMetaPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// solhint-disable\ninterface IMetaPool is IERC20 {\n    function get_previous_balances() external view returns (uint256[] memory);\n\n    function get_twap_balances(\n        uint256[] memory _first_balances,\n        uint256[] memory _last_balances,\n        uint256 _time_elapsed\n    ) external view returns (uint256[] memory);\n\n    function get_price_cumulative_last() external view returns (uint256[] memory);\n\n    function admin_fee() external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(uint256[] memory _amounts, bool _is_deposit) external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[] memory _amounts,\n        bool _is_deposit,\n        bool _previous\n    ) external view returns (uint256);\n\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external returns (uint256);\n\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256[] memory _balances\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256[] memory _balances\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 _burn_amount, uint256[] memory _min_amounts) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity_imbalance(uint256[] memory _amounts, uint256 _max_burn_amount) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        bool _previous\n    ) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function admin_balances(uint256 i) external view returns (uint256);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/interfaces/external/curve/IStableSwapPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// this interface doesn't wok with 3Pool as it doesn't return anything on add_liquidity, remove_liquidity_one_coin\n\n// solhint-disable\ninterface IStableSwapPool is IERC20 {\n    function A() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(uint256[3] memory amounts, bool deposit) external view returns (uint256);\n\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[3] memory amounts, uint256 max_burn_amount) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/euler/IEuler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n// Forked from https://github.com/euler-xyz/euler-interfaces\npragma solidity ^0.8.12;\n\n/// @notice Main storage contract for the Euler system\ninterface IEulerConstants {\n    /// @notice gives the maxExternalAmount in base 18\n    //solhint-disable-next-line\n    function MAX_SANE_AMOUNT() external view returns (uint256);\n}\n\n/// @notice Main storage contract for the Euler system\ninterface IEuler {\n    /// @notice Lookup the current implementation contract for a module\n    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__ETOKEN)\n    /// @return An internal address specifies the module's implementation code\n    function moduleIdToImplementation(uint256 moduleId) external view returns (address);\n\n    /// @notice Lookup a proxy that can be used to interact with a module (only valid for single-proxy modules)\n    /// @param moduleId Fixed constant that refers to a module type (ie MODULEID__MARKETS)\n    /// @return An address that should be cast to the appropriate module interface, ie IEulerMarkets(moduleIdToProxy(2))\n    function moduleIdToProxy(uint256 moduleId) external view returns (address);\n\n    /// @notice Euler-related configuration for an asset\n    struct AssetConfig {\n        address eTokenAddress;\n        bool borrowIsolated;\n        uint32 collateralFactor;\n        uint32 borrowFactor;\n        uint24 twapWindow;\n    }\n}\n\n/// @notice Activating and querying markets, and maintaining entered markets lists\ninterface IEulerMarkets {\n    /// @notice Create an Euler pool and associated EToken and DToken addresses.\n    /// @param underlying The address of an ERC20-compliant token. There must be an initialised uniswap3 pool for the underlying/reference asset pair.\n    /// @return The created EToken, or the existing EToken if already activated.\n    function activateMarket(address underlying) external returns (address);\n\n    /// @notice Create a pToken and activate it on Euler. pTokens are protected wrappers around assets that prevent borrowing.\n    /// @param underlying The address of an ERC20-compliant token. There must already be an activated market on Euler for this underlying, and it must have a non-zero collateral factor.\n    /// @return The created pToken, or an existing one if already activated.\n    function activatePToken(address underlying) external returns (address);\n\n    /// @notice Given an underlying, lookup the associated EToken\n    /// @param underlying Token address\n    /// @return EToken address, or address(0) if not activated\n    function underlyingToEToken(address underlying) external view returns (address);\n\n    /// @notice Given an underlying, lookup the associated DToken\n    /// @param underlying Token address\n    /// @return DToken address, or address(0) if not activated\n    function underlyingToDToken(address underlying) external view returns (address);\n\n    /// @notice Given an underlying, lookup the associated PToken\n    /// @param underlying Token address\n    /// @return PToken address, or address(0) if it doesn't exist\n    function underlyingToPToken(address underlying) external view returns (address);\n\n    /// @notice Looks up the Euler-related configuration for a token, and resolves all default-value placeholders to their currently configured values.\n    /// @param underlying Token address\n    /// @return Configuration struct\n    function underlyingToAssetConfig(address underlying) external view returns (IEuler.AssetConfig memory);\n\n    /// @notice Looks up the Euler-related configuration for a token, and returns it unresolved (with default-value placeholders)\n    /// @param underlying Token address\n    /// @return config Configuration struct\n    function underlyingToAssetConfigUnresolved(address underlying)\n        external\n        view\n        returns (IEuler.AssetConfig memory config);\n\n    /// @notice Given an EToken address, looks up the associated underlying\n    /// @param eToken EToken address\n    /// @return underlying Token address\n    function eTokenToUnderlying(address eToken) external view returns (address underlying);\n\n    /// @notice Given an EToken address, looks up the associated DToken\n    /// @param eToken EToken address\n    /// @return dTokenAddr DToken address\n    function eTokenToDToken(address eToken) external view returns (address dTokenAddr);\n\n    /// @notice Looks up an asset's currently configured interest rate model\n    /// @param underlying Token address\n    /// @return Module ID that represents the interest rate model (IRM)\n    function interestRateModel(address underlying) external view returns (uint256);\n\n    /// @notice Retrieves the current interest rate for an asset\n    /// @param underlying Token address\n    /// @return The interest rate in yield-per-second, scaled by 10**27\n    function interestRate(address underlying) external view returns (int96);\n\n    /// @notice Retrieves the current interest rate accumulator for an asset\n    /// @param underlying Token address\n    /// @return An opaque accumulator that increases as interest is accrued\n    function interestAccumulator(address underlying) external view returns (uint256);\n\n    /// @notice Retrieves the reserve fee in effect for an asset\n    /// @param underlying Token address\n    /// @return Amount of interest that is redirected to the reserves, as a fraction scaled by RESERVE_FEE_SCALE (4e9)\n    function reserveFee(address underlying) external view returns (uint32);\n\n    /// @notice Retrieves the pricing config for an asset\n    /// @param underlying Token address\n    /// @return pricingType (1=pegged, 2=uniswap3, 3=forwarded)\n    /// @return pricingParameters If uniswap3 pricingType then this represents the uniswap pool fee used, otherwise unused\n    /// @return pricingForwarded If forwarded pricingType then this is the address prices are forwarded to, otherwise address(0)\n    function getPricingConfig(address underlying)\n        external\n        view\n        returns (\n            uint16 pricingType,\n            uint32 pricingParameters,\n            address pricingForwarded\n        );\n\n    /// @notice Retrieves the list of entered markets for an account (assets enabled for collateral or borrowing)\n    /// @param account User account\n    /// @return List of underlying token addresses\n    function getEnteredMarkets(address account) external view returns (address[] memory);\n\n    /// @notice Add an asset to the entered market list, or do nothing if already entered\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param newMarket Underlying token address\n    function enterMarket(uint256 subAccountId, address newMarket) external;\n\n    /// @notice Remove an asset from the entered market list, or do nothing if not already present\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param oldMarket Underlying token address\n    function exitMarket(uint256 subAccountId, address oldMarket) external;\n}\n\n/// @notice Definition of callback method that deferLiquidityCheck will invoke on your contract\ninterface IDeferredLiquidityCheck {\n    function onDeferredLiquidityCheck(bytes memory data) external;\n}\n\n/// @notice Batch executions, liquidity check deferrals, and interfaces to fetch prices and account liquidity\ninterface IEulerExec {\n    /// @notice Liquidity status for an account, either in aggregate or for a particular asset\n    struct LiquidityStatus {\n        uint256 collateralValue;\n        uint256 liabilityValue;\n        uint256 numBorrows;\n        bool borrowIsolated;\n    }\n\n    /// @notice Aggregate struct for reporting detailed (per-asset) liquidity for an account\n    struct AssetLiquidity {\n        address underlying;\n        LiquidityStatus status;\n    }\n\n    /// @notice Single item in a batch request\n    struct EulerBatchItem {\n        bool allowError;\n        address proxyAddr;\n        bytes data;\n    }\n\n    /// @notice Single item in a batch response\n    struct EulerBatchItemResponse {\n        bool success;\n        bytes result;\n    }\n\n    /// @notice Compute aggregate liquidity for an account\n    /// @param account User address\n    /// @return status Aggregate liquidity (sum of all entered assets)\n    function liquidity(address account) external returns (LiquidityStatus memory status);\n\n    /// @notice Compute detailed liquidity for an account, broken down by asset\n    /// @param account User address\n    /// @return assets List of user's entered assets and each asset's corresponding liquidity\n    function detailedLiquidity(address account) external returns (AssetLiquidity[] memory assets);\n\n    /// @notice Retrieve Euler's view of an asset's price\n    /// @param underlying Token address\n    /// @return twap Time-weighted average price\n    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available\n    function getPrice(address underlying) external view returns (uint256 twap, uint256 twapPeriod);\n\n    /// @notice Retrieve Euler's view of an asset's price, as well as the current marginal price on uniswap\n    /// @param underlying Token address\n    /// @return twap Time-weighted average price\n    /// @return twapPeriod TWAP duration, either the twapWindow value in AssetConfig, or less if that duration not available\n    /// @return currPrice The current marginal price on uniswap3 (informational: not used anywhere in the Euler protocol)\n    function getPriceFull(address underlying)\n        external\n        returns (\n            uint256 twap,\n            uint256 twapPeriod,\n            uint256 currPrice\n        );\n\n    /// @notice Defer liquidity checking for an account, to perform rebalancing, flash loans, etc. msg.sender must implement IDeferredLiquidityCheck\n    /// @param account The account to defer liquidity for. Usually address(this), although not always\n    /// @param data Passed through to the onDeferredLiquidityCheck() callback, so contracts don't need to store transient data in storage\n    function deferLiquidityCheck(address account, bytes memory data) external;\n\n    /// @notice Execute several operations in a single transaction\n    /// @param items List of operations to execute\n    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for\n    /// @return List of operation results\n    function batchDispatch(EulerBatchItem[] calldata items, address[] calldata deferLiquidityChecks)\n        external\n        returns (EulerBatchItemResponse[] memory);\n\n    /// @notice Results of a batchDispatch, but with extra information\n    struct EulerBatchExtra {\n        EulerBatchItemResponse[] responses;\n        uint256 gasUsed;\n        AssetLiquidity[][] liquidities;\n    }\n\n    /// @notice Call batchDispatch, but return extra information. Only intended to be used with callStatic.\n    /// @param items List of operations to execute\n    /// @param deferLiquidityChecks List of user accounts to defer liquidity checks for\n    /// @param queryLiquidity List of user accounts to return detailed liquidity information for\n    /// @return output Structure with extra information\n    function batchDispatchExtra(\n        EulerBatchItem[] calldata items,\n        address[] calldata deferLiquidityChecks,\n        address[] calldata queryLiquidity\n    ) external returns (EulerBatchExtra memory output);\n\n    /// @notice Enable average liquidity tracking for your account. Operations will cost more gas, but you may get additional benefits when performing liquidations\n    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account.\n    /// @param delegate An address of another account that you would allow to use the benefits of your account's average liquidity (use the null address if you don't care about this). The other address must also reciprocally delegate to your account.\n    /// @param onlyDelegate Set this flag to skip tracking average liquidity and only set the delegate.\n    function trackAverageLiquidity(\n        uint256 subAccountId,\n        address delegate,\n        bool onlyDelegate\n    ) external;\n\n    /// @notice Disable average liquidity tracking for your account and remove delegate\n    /// @param subAccountId subAccountId 0 for primary, 1-255 for a sub-account\n    function unTrackAverageLiquidity(uint256 subAccountId) external;\n\n    /// @notice Retrieve the average liquidity for an account\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment\n    function getAverageLiquidity(address account) external returns (uint256);\n\n    /// @notice Retrieve the average liquidity for an account or a delegate account, if set\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity, in terms of the reference asset, and post risk-adjustment\n    function getAverageLiquidityWithDelegate(address account) external returns (uint256);\n\n    /// @notice Retrieve the account which delegates average liquidity for an account, if set\n    /// @param account User account (xor in subAccountId, if applicable)\n    /// @return The average liquidity delegate account\n    function getAverageLiquidityDelegateAccount(address account) external view returns (address);\n\n    /// @notice Transfer underlying tokens from sender's wallet into the pToken wrapper. Allowance should be set for the euler address.\n    /// @param underlying Token address\n    /// @param amount The amount to wrap in underlying units\n    function pTokenWrap(address underlying, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from the pToken wrapper to the sender's wallet.\n    /// @param underlying Token address\n    /// @param amount The amount to unwrap in underlying units\n    function pTokenUnWrap(address underlying, uint256 amount) external;\n}\n\n/// @notice Tokenised representation of assets\ninterface IEulerEToken is IEulerConstants {\n    /// @notice Pool name, ie \"Euler Pool: DAI\"\n    function name() external view returns (string memory);\n\n    /// @notice Pool symbol, ie \"eDAI\"\n    function symbol() external view returns (string memory);\n\n    /// @notice Decimals, always normalised to 18.\n    function decimals() external pure returns (uint8);\n\n    /// @notice Sum of all balances, in internal book-keeping units (non-increasing)\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Sum of all balances, in underlying units (increases as interest is earned)\n    function totalSupplyUnderlying() external view returns (uint256);\n\n    /// @notice Balance of a particular account, in internal book-keeping units (non-increasing)\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Balance of a particular account, in underlying units (increases as interest is earned)\n    function balanceOfUnderlying(address account) external view returns (uint256);\n\n    /// @notice Balance of the reserves, in internal book-keeping units (non-increasing)\n    function reserveBalance() external view returns (uint256);\n\n    /// @notice Balance of the reserves, in underlying units (increases as interest is earned)\n    function reserveBalanceUnderlying() external view returns (uint256);\n\n    /// @notice Updates interest accumulator and totalBorrows, credits reserves, re-targets interest rate, and logs asset status\n    function touch() external;\n\n    /// @notice Transfer underlying tokens from sender to the Euler pool, and increase account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full underlying token balance)\n    function deposit(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from Euler pool to sender, and decrease account's eTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full pool balance)\n    function withdraw(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Convert an eToken balance to an underlying amount, taking into account current exchange rate\n    /// @param balance eToken balance, in internal book-keeping units (18 decimals)\n    /// @return Amount in underlying units, (same decimals as underlying token)\n    function convertBalanceToUnderlying(uint256 balance) external view returns (uint256);\n\n    /// @notice Convert an underlying amount to an eToken balance, taking into account current exchange rate\n    /// @param underlyingAmount Amount in underlying units (same decimals as underlying token)\n    /// @return eToken balance, in internal book-keeping units (18 decimals)\n    function convertUnderlyingToBalance(uint256 underlyingAmount) external view returns (uint256);\n}\n\ninterface IEulerDToken is IEulerConstants {\n    /// @notice Debt token name, ie \"Euler Debt: DAI\"\n    function name() external view returns (string memory);\n\n    /// @notice Debt token symbol, ie \"dDAI\"\n    function symbol() external view returns (string memory);\n\n    /// @notice Decimals, always normalised to 18.\n    function decimals() external pure returns (uint8);\n\n    /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Sum of all outstanding debts, in underlying units with extra precision (increases as interest is accrued)\n    function totalSupplyExact() external view returns (uint256);\n\n    /// @notice Debt owed by a particular account, in underlying units\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Debt owed by a particular account, in underlying units with extra precision\n    function balanceOfExact(address account) external view returns (uint256);\n\n    /// @notice Transfer underlying tokens from the Euler pool to the sender, and increase sender's dTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for all available tokens)\n    function borrow(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Transfer underlying tokens from the sender to the Euler pool, and decrease sender's dTokens\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param amount In underlying units (use max uint256 for full debt owed)\n    function repay(uint256 subAccountId, uint256 amount) external;\n\n    /// @notice Allow spender to send an amount of dTokens to a particular sub-account\n    /// @param subAccountId 0 for primary, 1-255 for a sub-account\n    /// @param spender Trusted address\n    /// @param amount Use max uint256 for \"infinite\" allowance\n    function approveDebt(\n        uint256 subAccountId,\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Retrieve the current debt allowance\n    /// @param holder Xor with the desired sub-account ID (if applicable)\n    /// @param spender Trusted address\n    function debtAllowance(address holder, address spender) external view returns (uint256);\n}\n\ninterface IBaseIRM {\n    function computeInterestRate(address underlying, uint32 utilisation) external view returns (int96);\n}\n\ninterface IGovernance {\n    function setIRM(\n        address underlying,\n        uint256 interestRateModel,\n        bytes calldata resetParams\n    ) external;\n\n    function setReserveFee(address underlying, uint32 newReserveFee) external;\n\n    function getGovernorAdmin() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/euler/IEulerStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\n// Original contract can be found under the following link:\n// https://github.com/Synthetixio/synthetix/blob/master/contracts/interfaces/IStakingRewards.sol\ninterface IEulerStakingRewards {\n    // Views\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function periodFinish() external view returns (uint256);\n\n    // Mutative\n\n    function exit() external;\n\n    function exit(uint256 subAccountId) external;\n\n    function getReward() external;\n\n    function stake(uint256 amount) external;\n\n    function stake(uint256 subAccountId, uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function withdraw(uint256 subAccountId, uint256 amount) external;\n\n    function notifyRewardAmount(uint256 reward) external;\n}\n"
    },
    "contracts/interfaces/external/frax/IFraxUnifiedFarmTemplate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n// solhint-disable\ninterface IFraxUnifiedFarmTemplate {\n    // Struct for the stake\n    struct LockedStake {\n        bytes32 kek_id;\n        uint256 start_timestamp;\n        uint256 liquidity;\n        uint256 ending_timestamp;\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\n    }\n\n    // Calculate the combined weight for an account\n    function calcCurCombinedWeight(address account)\n        external\n        view\n        returns (\n            uint256 old_combined_weight,\n            uint256 new_vefxs_multiplier,\n            uint256 new_combined_weight\n        );\n\n    // get the current minimum lockTime on the staking contract\n    function lock_time_min() external view returns (uint256);\n\n    /// @notice Send the rewards to the destination\n    /// @return Array of all sent rewards (only the amounts you need to know the order of the rewards)\n    function getReward(address destination_address) external returns (uint256[] memory);\n\n    // ------ LOCK RELATED ------\n\n    /// @notice get the current lock amount (without accruing interest) useful to compute the kekId\n    function lockedLiquidityOf(address account) external view returns (uint256);\n\n    // Add additional LPs to an existing locked stake\n    // REBASE: If you simply want to accrue interest, call this with addl_liq = 0\n    function lockAdditional(bytes32 kek_id, uint256 addl_liq) external;\n\n    /// @notice Two different stake functions are needed because of delegateCall and msg.sender issues (important for migration)\n    /// @return the keckId\n    function stakeLocked(uint256 liquidity, uint256 secs) external returns (bytes32);\n\n    // ------ WITHDRAWING ------\n\n    /// @notice Each withdraw will delete the locked associated to the `keck_id`\n    /// @return Liquidity withdrawn from the locker\n    function withdrawLocked(bytes32 kek_id, address destination_address) external returns (uint256);\n\n    // ------ REWARDS ------\n\n    function stakerSetVeFXSProxy(address proxy_address) external;\n\n    function rewardRates(uint256 token_idx) external view returns (uint256 rwd_rate);\n\n    function lockMultiplier(uint256 secs) external view returns (uint256);\n\n    function totalCombinedWeight() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/external/lido/ISteth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISteth is IERC20 {\n    event Submitted(address sender, uint256 amount, address referral);\n\n    function submit(address) external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/mock/IMockFraxUnifiedFarm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n// solhint-disable\ninterface IMockFraxUnifiedFarm {\n    // Struct for the stake\n    struct LockedStake {\n        bytes32 kek_id;\n        uint256 start_timestamp;\n        uint256 liquidity;\n        uint256 ending_timestamp;\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\n    }\n\n    // Calculate the combined weight for an account\n    function calcCurCombinedWeight(address account)\n        external\n        view\n        returns (\n            uint256 old_combined_weight,\n            uint256 new_vefxs_multiplier,\n            uint256 new_combined_weight\n        );\n\n    // get the current minimum lockTime on the staking contract\n    function lock_time_min() external view returns (uint256);\n\n    /// @notice Send the rewards to the destination\n    /// @return Array of all sent rewards (only the amounts you need to know the order of the rewards)\n    function getReward(address destination_address) external returns (uint256[] memory);\n\n    // ------ LOCK RELATED ------\n\n    // Add additional LPs to an existing locked stake\n    // REBASE: If you simply want to accrue interest, call this with addl_liq = 0\n    function lockAdditional(bytes32 kek_id, uint256 addl_liq) external;\n\n    /// @notice Two different stake functions are needed because of delegateCall and msg.sender issues (important for migration)\n    /// @return the keckId\n    function stakeLocked(uint256 liquidity, uint256 secs) external returns (bytes32);\n\n    // ------ WITHDRAWING ------\n\n    /// @notice Each withdraw will delete the locked associated to the `keck_id`\n    /// @return Liquidity withdrawn from the locker\n    function withdrawLocked(bytes32 kek_id, address destination_address) external returns (uint256);\n\n    // ------ REWARDS ------\n\n    function stakerSetVeFXSProxy(address proxy_address) external;\n\n    function rewardRates(uint256 token_idx) external view returns (uint256 rwd_rate);\n\n    function lockMultiplier(uint256 secs) external view returns (uint256);\n\n    function totalCombinedWeight() external view returns (uint256);\n\n    // just for the mock and testing\n\n    function proxyToggleStaker(address staker_address) external;\n\n    function veFXSMultiplier(address account) external view returns (uint256 vefxs_multiplier);\n\n    function toggleValidVeFXSProxy(address _proxy_addr) external;\n\n    function setMiscVariables(uint256[6] memory _misc_vars) external;\n\n    function getProxyFor(address _proxy_addr) external view returns (address);\n\n    function storedStkLiqIdx(bytes32) external view returns (uint256);\n\n    function currLiqIdx() external view returns (uint256);\n\n    function lockedStakes(address, uint256) external view returns (LockedStake memory);\n}\n"
    },
    "contracts/interfaces/external/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3Pool {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n}\n"
    },
    "contracts/interfaces/IAccessControlAngle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IAccessControl\n/// @author Forked from OpenZeppelin\n/// @notice Interface for `AccessControl` contracts\ninterface IAccessControlAngle {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IAngleHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nstruct PerpetualManagerFeeData {\n    uint64[] xHAFeesDeposit;\n    uint64[] yHAFeesDeposit;\n    uint64[] xHAFeesWithdraw;\n    uint64[] yHAFeesWithdraw;\n    uint64 haBonusMalusDeposit;\n    uint64 haBonusMalusWithdraw;\n}\n\nstruct PerpetualManagerParamData {\n    uint64 maintenanceMargin;\n    uint64 maxLeverage;\n    uint64 targetHAHedge;\n    uint64 limitHAHedge;\n    uint64 lockTime;\n}\n\nstruct CollateralAddresses {\n    address stableMaster;\n    address poolManager;\n    address perpetualManager;\n    address sanToken;\n    address oracle;\n    address gauge;\n    address feeManager;\n    address[] strategies;\n}\n\ninterface IAngleHelper {\n    function getCollateralAddresses(address agToken, address collateral)\n        external\n        view\n        returns (CollateralAddresses memory addresses);\n\n    function getStablecoinAddresses() external view returns (address[] memory, address[] memory);\n\n    function getPoolManager(address agToken, address collateral) external view returns (address poolManager);\n}\n"
    },
    "contracts/interfaces/IGenericLender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./IAccessControlAngle.sol\";\n\n/// @title IGenericLender\n/// @author Yearn with slight modifications from Angle Core Team\n/// @dev Interface for the `GenericLender` contract, the base interface for contracts interacting\n/// with lending and yield farming platforms\ninterface IGenericLender is IAccessControlAngle {\n    /// @notice Name of the lender on which funds are invested\n    function lenderName() external view returns (string memory);\n\n    /// @notice Helper function to get the current total of assets managed by the lender.\n    function nav() external view returns (uint256);\n\n    /// @notice Reference to the `Strategy` contract the lender interacts with\n    function strategy() external view returns (address);\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate on the lender\n    function apr() external view returns (uint256);\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate weighted by the assets under\n    /// management of the lender\n    function weightedApr() external view returns (uint256);\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount The amount the caller wants to withdraw\n    /// @return Amount actually withdrawn\n    function withdraw(uint256 amount) external returns (uint256);\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the `PoolManager`\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or if the amount withdrawn is correct\n    function emergencyWithdraw(uint256 amount) external;\n\n    /// @notice Deposits the current balance of the contract to the lending platform\n    function deposit() external;\n\n    /// @notice Withdraws as much as possible from the lending platform\n    /// @return Whether everything was withdrawn or not\n    function withdrawAll() external returns (bool);\n\n    /// @notice Check if assets are currently managed by the lender\n    /// @dev We're considering that the strategy has no assets if it has less than 10 of the\n    /// underlying asset in total to avoid the case where there is dust remaining on the lending market\n    /// and we cannot withdraw everything\n    function hasAssets() external view returns (bool);\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// of `amount`\n    /// @param amount Amount to add to the lending platform, and that we want to take into account\n    /// in the apr computation\n    function aprAfterDeposit(int256 amount) external view returns (uint256);\n\n    /// @notice\n    /// Removes tokens from this Strategy that are not the type of tokens\n    /// managed by this Strategy. This may be used in case of accidentally\n    /// sending the wrong kind of token to this Strategy.\n    ///\n    /// Tokens will be sent to `governance()`.\n    ///\n    /// This will fail if an attempt is made to sweep `want`, or any tokens\n    /// that are protected by this Strategy.\n    ///\n    /// This may only be called by governance.\n    /// @param _token The token to transfer out of this poolManager.\n    /// @param to Address to send the tokens to.\n    /// @dev\n    /// Implement `_protectedTokens()` to specify any additional tokens that\n    /// should be protected from sweeping in addition to `want`.\n    function sweep(address _token, address to) external;\n\n    /// @notice Returns the current balance invested on the lender and related staking contracts\n    function underlyingBalanceStored() external view returns (uint256 balance);\n}\n"
    },
    "contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n// Struct for the parameters associated with a strategy interacting with a collateral `PoolManager`\n// contract\nstruct StrategyParams {\n    // Timestamp of last report made by this strategy\n    // It is also used to check if a strategy has been initialized\n    uint256 lastReport;\n    // Total amount the strategy is expected to have\n    uint256 totalStrategyDebt;\n    // The share of the total assets in the `PoolManager` contract that the `strategy` can access to.\n    uint256 debtRatio;\n}\n\n/// @title IPoolManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the collateral poolManager contracts handling each one type of collateral for\n/// a given stablecoin\n/// @dev Only the functions used in other contracts of the protocol are left here\ninterface IPoolManagerFunctions {\n    // ============================ Yield Farming ==================================\n\n    function creditAvailable() external view returns (uint256);\n\n    function debtOutstanding() external view returns (uint256);\n\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtPayment\n    ) external;\n\n    // ============================= Getters =======================================\n\n    function getBalance() external view returns (uint256);\n\n    function getTotalAsset() external view returns (uint256);\n}\n\n/// @title IPoolManager\n/// @author Angle Core Team\n/// @notice Previous interface with additional getters for public variables and mappings\n/// @dev Used in other contracts of the protocol\ninterface IPoolManager is IPoolManagerFunctions {\n    function stableMaster() external view returns (address);\n\n    function perpetualManager() external view returns (address);\n\n    function token() external view returns (address);\n\n    function totalDebt() external view returns (uint256);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./IAccessControlAngle.sol\";\n\nstruct LendStatus {\n    string name;\n    uint256 assets;\n    uint256 rate;\n    address add;\n}\n\n/// @title IStrategy\n/// @author Inspired by Yearn with slight changes\n/// @notice Interface for yield farming strategies\ninterface IStrategy is IAccessControlAngle {\n    function estimatedAPR() external view returns (uint256);\n\n    function poolManager() external view returns (address);\n\n    function want() external view returns (address);\n\n    function isActive() external view returns (bool);\n\n    function estimatedTotalAssets() external view returns (uint256);\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    function withdraw(uint256 _amountNeeded) external returns (uint256 amountFreed, uint256 _loss);\n\n    function setEmergencyExit() external;\n\n    function addGuardian(address _guardian) external;\n\n    function revokeGuardian(address _guardian) external;\n}\n"
    },
    "contracts/mock/MockAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\n\nimport { IPriceOracle, IOptionalERC20, DataTypes, IStakedAave, IReserveInterestRateStrategy } from \"../interfaces/external/aave/IAave.sol\";\nimport { IAToken } from \"../interfaces/external/aave/IAaveToken.sol\";\nimport { IAToken } from \"../interfaces/external/aave/IAaveToken.sol\";\nimport { IProtocolDataProvider } from \"../interfaces/external/aave/IProtocolDataProvider.sol\";\nimport { ILendingPool, ILendingPoolAddressesProvider } from \"../interfaces/external/aave/ILendingPool.sol\";\nimport { IAaveIncentivesController } from \"../interfaces/external/aave/IAaveIncentivesController.sol\";\nimport { IVariableDebtToken } from \"../interfaces/external/aave/IAaveToken.sol\";\n\nabstract contract MockAave is\n    IAaveIncentivesController,\n    ILendingPoolAddressesProvider,\n    IReserveInterestRateStrategy,\n    IStakedAave\n{\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**27;\n\n    uint256 public distributionEnd = type(uint256).max;\n    uint256 public emissionsPerSecond = 10;\n    uint256 public unstakeWindow = type(uint256).max;\n    uint256 public stakersCooldownsValue = 0;\n    uint256 public rewardsBalance = 0;\n\n    function getRewardsBalance(address[] calldata, address) external view override returns (uint256) {\n        return rewardsBalance;\n    }\n\n    function setRewardsBalance(uint256 _rewardsBalance) external {\n        rewardsBalance = _rewardsBalance;\n    }\n\n    function claimRewards(\n        address[] calldata,\n        uint256,\n        address\n    ) external pure override returns (uint256) {\n        return uint256(0);\n    }\n\n    function getDistributionEnd() external view override returns (uint256) {\n        return distributionEnd;\n    }\n\n    function setDistributionEnd(uint256 _distributionEnd) external {\n        distributionEnd = _distributionEnd;\n    }\n\n    function getAssetData(address)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (0, emissionsPerSecond, 0);\n    }\n\n    function setEmissionsPerSecond(uint256 _emissionsPerSecond) external {\n        emissionsPerSecond = _emissionsPerSecond;\n    }\n\n    function getLendingPool() external view override returns (address) {\n        return address(this);\n    }\n\n    function calculateInterestRates(\n        address,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    )\n        external\n        pure\n        override\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        )\n    {\n        return (0.04 ether, 0.04 ether, 0.04 ether);\n    }\n\n    function stake(address to, uint256 amount) external override {}\n\n    function redeem(address to, uint256 amount) external override {}\n\n    function cooldown() external override {}\n\n    function claimRewards(address to, uint256 amount) external override {}\n\n    function getTotalRewardsBalance(address) external view override returns (uint256) {}\n\n    // solhint-disable-next-line\n    function COOLDOWN_SECONDS() external pure override returns (uint256) {\n        return 0;\n    }\n\n    function stakersCooldowns(address) external view override returns (uint256) {\n        return stakersCooldownsValue;\n    }\n\n    // solhint-disable-next-line\n    function UNSTAKE_WINDOW() external view override returns (uint256) {\n        return unstakeWindow;\n    }\n\n    function setUnstakeWindowAndStakers(uint256 _unstakeWindow, uint256 _stakersCooldownsValue) external {\n        unstakeWindow = _unstakeWindow;\n        stakersCooldownsValue = _stakersCooldownsValue;\n    }\n\n    function getPriceOracle() external view override returns (address) {\n        return address(this);\n    }\n\n    function getAssetsPrices(address[] calldata) external pure returns (uint256[] memory) {\n        uint256[] memory _ret = new uint256[](2);\n        _ret[0] = uint256(392936527437060);\n        _ret[1] = uint256(394087347138603);\n        return _ret;\n    }\n}\n\ncontract MockMKRLender {\n    mapping(address => uint256) public maxFlashLoan;\n    uint256 public compilerMuter;\n\n    constructor(address _token, uint256 _maxFlashLoan) {\n        maxFlashLoan[_token] = _maxFlashLoan;\n    }\n\n    function flashFee(address, uint256) external view returns (uint256) {\n        compilerMuter;\n        return 0;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool) {\n        compilerMuter = 0;\n        return true;\n    }\n}\n\ncontract MockAToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    /// @notice constructor\n    /// @param name_ of the token lent\n    /// @param symbol_ of the token lent\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 decimals\n    ) ERC20(name_, symbol_) {}\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function getIncentivesController() external view returns (IAaveIncentivesController) {\n        return IAaveIncentivesController(address(this));\n    }\n}\n\nabstract contract MockLendingPool is ILendingPool {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**27;\n\n    MockAToken public immutable aToken;\n    MockAToken public immutable debtToken;\n    uint128 public currentLiquidityRate = 0;\n    uint256 public compilerMuter;\n\n    constructor(address _aToken, address _debtToken) {\n        aToken = MockAToken(_aToken);\n        debtToken = MockAToken(_debtToken);\n    }\n\n    mapping(address => uint256) public reserveNormalizedIncomes; // Mapping between an underlying asset and its reserveNoramlized income\n\n    function deployNewUnderlying(address underlying) external {\n        reserveNormalizedIncomes[underlying] = BASE;\n    }\n\n    function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n        return reserveNormalizedIncomes[asset] / BASE;\n    }\n\n    function changeReserveNormalizedIncome(uint256 newIncome, address asset) external {\n        reserveNormalizedIncomes[asset] = newIncome * BASE;\n    }\n\n    function setCurrentLiquidityRate(uint128 _liquidityRate) external {\n        currentLiquidityRate = _liquidityRate;\n    }\n\n    function getReserveData(address) external view override returns (DataTypes.ReserveData memory) {\n        return\n            DataTypes.ReserveData(\n                DataTypes.ReserveConfigurationMap(uint256(0)),\n                uint128(0),\n                uint128(0),\n                currentLiquidityRate,\n                uint128(0),\n                uint128(0),\n                uint40(0),\n                address(this),\n                address(this),\n                address(this),\n                address(this),\n                uint8(0)\n            );\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16\n    ) external override {\n        IERC20 underlying = IERC20(asset);\n        underlying.safeTransferFrom(msg.sender, address(this), amount);\n        // With Aave the amount of cToken is exactly what has been given\n        uint256 reserveNormalizedIncome_ = reserveNormalizedIncomes[asset];\n        aToken.mint(onBehalfOf, (amount * BASE) / reserveNormalizedIncome_); // Here we don't exactly respect what Aave is doing\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        uint256 reserveNormalizedIncome_ = reserveNormalizedIncomes[asset];\n        uint256 amountcToken = (amount * BASE) / reserveNormalizedIncome_;\n        aToken.burn(msg.sender, amountcToken);\n        uint256 amountToken = (amountcToken * reserveNormalizedIncome_) / BASE;\n        IERC20(asset).safeTransfer(to, amountToken);\n        return (amountToken);\n    }\n\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external override {}\n\n    function repay(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external override returns (uint256) {\n        compilerMuter = 0;\n        return 0;\n    }\n}\n\ncontract MockProtocolDataProvider {\n    uint256 public availableLiquidityStorage = 0;\n\n    address public immutable aToken;\n    address public immutable debtToken;\n    MockAave public immutable mockAave;\n\n    constructor(\n        address _aToken,\n        address _debtToken,\n        address _mockAave\n    ) {\n        aToken = _aToken;\n        debtToken = _debtToken;\n        mockAave = MockAave(_mockAave);\n    }\n\n    function getReserveTokensAddresses(address)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        )\n    {\n        aTokenAddress = aToken;\n        stableDebtTokenAddress = debtToken;\n        variableDebtTokenAddress = debtToken;\n    }\n\n    // solhint-disable-next-line\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider) {\n        return ILendingPoolAddressesProvider(mockAave);\n    }\n\n    function getReserveConfigurationData(address)\n        external\n        pure\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        )\n    {\n        // https://etherscan.io/address/0x057835ad21a177dbdd3090bb1cae03eacf78fc6d#readContract\n        return (uint256(6), uint256(8250), uint256(8500), uint256(10400), uint256(1000), true, true, true, true, false);\n    }\n\n    function setAvailableLiquidity(uint256 _availableLiquidity) external {\n        availableLiquidityStorage = _availableLiquidity;\n    }\n\n    function getReserveData(address)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        )\n    {\n        availableLiquidity = availableLiquidityStorage;\n        return (\n            availableLiquidity,\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint40(0)\n        );\n    }\n}\n"
    },
    "contracts/mock/MockCurveStETHETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contract we have to fix flash attacks\ncontract MockCurveStETHETH {\n    using SafeERC20 for IERC20;\n\n    address public stETH;\n    uint256 public dy;\n\n    constructor(address _stETH) {\n        stETH = _stETH;\n        dy = 10**18;\n    }\n\n    receive() external payable {}\n\n    function exchange(\n        int128 from,\n        int128 to,\n        // solhint-disable-next-line\n        uint256 _from_amount,\n        uint256\n    ) external payable {\n        if (from == 0 && to == 1) {\n            IERC20(stETH).transfer(msg.sender, (msg.value * dy) / 10**18);\n        } else {\n            IERC20(stETH).transferFrom(msg.sender, address(this), _from_amount);\n            // solhint-disable-next-line\n            (bool sent, ) = msg.sender.call{ value: (_from_amount * 10**18) / dy }(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n\n    function setDy(uint256 _dy) external {\n        dy = _dy;\n    }\n\n    // solhint-disable-next-line\n    function get_dy(\n        int128,\n        int128,\n        // solhint-disable-next-line\n        uint256 _from_amount\n    ) external view returns (uint256) {\n        return (_from_amount * dy) / 10**18;\n    }\n}\n"
    },
    "contracts/mock/MockLender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./../strategies/OptimizerAPR/genericLender/GenericLenderBaseUpgradeable.sol\";\n\n/// @title GenericEuler\n/// @author Angle Core Team\n/// @notice Simple supplier to Euler markets\ncontract MockLender is GenericLenderBaseUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    uint256 private constant _BPS = 10**4;\n\n    uint256 public r0;\n    uint256 public slope1;\n    uint256 public totalBorrow;\n    uint256 public biasSupply;\n    uint256 public propWithdrawable;\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Initializer of the `GenericEuler`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param governorList List of addresses with governor privilege\n    /// @param keeperList List of addresses with keeper privilege\n    /// @param guardian Address of the guardian\n    function initialize(\n        address _strategy,\n        string memory _name,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_,\n        uint256 _propWithdrawable\n    ) public {\n        _initialize(_strategy, _name, governorList, guardian, keeperList, oneInch_);\n        propWithdrawable = _propWithdrawable;\n    }\n\n    function setPropWithdrawable(uint256 _propWithdrawable) external {\n        propWithdrawable = _propWithdrawable;\n    }\n\n    // ======================== EXTERNAL STRATEGY FUNCTIONS ========================\n\n    /// @inheritdoc IGenericLender\n    function deposit() external view override onlyRole(STRATEGY_ROLE) {\n        want.balanceOf(address(this));\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ========================== EXTERNAL VIEW FUNCTIONS ==========================\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function underlyingBalanceStored() public pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @inheritdoc IGenericLender\n    function aprAfterDeposit(int256 amount) external view override returns (uint256) {\n        return _aprAfterDeposit(amount);\n    }\n\n    // ================================= GOVERNANCE ================================\n\n    /// @inheritdoc IGenericLender\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        want.safeTransfer(address(poolManager), amount);\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function _apr() internal view override returns (uint256) {\n        return _aprAfterDeposit(0);\n    }\n\n    /// @notice Internal version of the `aprAfterDeposit` function\n    function _aprAfterDeposit(int256 amount) internal view returns (uint256 supplyAPY) {\n        uint256 totalSupply = want.balanceOf(address(this));\n        if (amount >= 0) totalSupply += uint256(amount);\n        else totalSupply -= uint256(-amount);\n        if (totalSupply > 0) supplyAPY = _computeAPYs(totalSupply);\n    }\n\n    /// @notice Computes APYs based on the interest rate, reserve fee, borrow\n    /// @param totalSupply Interest rate paid per second by borrowers\n    /// @return supplyAPY The annual percentage yield received as a supplier with current settings\n    function _computeAPYs(uint256 totalSupply) internal view returns (uint256 supplyAPY) {\n        // All rates are in base 18 on Angle strategies\n        supplyAPY = r0 + (slope1 * totalBorrow) / (totalSupply + biasSupply);\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = looseBalance;\n\n        if (amount > total) {\n            // Can't withdraw more than we own\n            amount = total;\n        }\n\n        // Limited in what we can withdraw\n        amount = (amount * propWithdrawable) / _BPS;\n        want.safeTransfer(address(strategy), amount);\n        return amount;\n    }\n\n    /// @notice Internal version of the `setEulerPoolVariables`\n    function setLenderPoolVariables(\n        uint256 _r0,\n        uint256 _slope1,\n        uint256 _totalBorrow,\n        uint256 _biasSupply\n    ) external {\n        r0 = _r0;\n        slope1 = _slope1;\n        totalBorrow = _totalBorrow;\n        biasSupply = _biasSupply;\n    }\n\n    // ============================= VIRTUAL FUNCTIONS =============================\n\n    /// @inheritdoc IGenericLender\n    function hasAssets() external view override returns (bool) {\n        return _nav() > 0;\n    }\n\n    function _protectedTokens() internal pure override returns (address[] memory) {\n        return new address[](0);\n    }\n}\n"
    },
    "contracts/mock/MockPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\ncontract MockPoolManager is AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE_TOKENS = 10**18;\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n\n    mapping(address => StrategyParams) public strategies;\n    address[] public strategyList;\n\n    IERC20 public token;\n    uint256 public creditAvailable;\n    uint256 public totalDebt;\n    uint256 public debtRatio;\n\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 totalDebt\n    );\n    event StrategyAdded(address indexed strategy, uint256 debtRatio);\n    event StrategyRevoked(address indexed strategy);\n\n    constructor(address _token, uint256 _creditAvailable) {\n        token = IERC20(_token);\n        creditAvailable = _creditAvailable;\n    }\n\n    function debtOutstanding() external view returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        // console.log(\"debtOutstanding: totalStrategyDebt %s / target: %s / debtRatio: %s\", params.totalStrategyDebt, target, params.debtRatio);\n\n        if (target > params.totalStrategyDebt) return 0;\n\n        return (params.totalStrategyDebt - target);\n    }\n\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external {\n        require(token.balanceOf(msg.sender) >= gain + debtPayment, \"72\");\n\n        StrategyParams storage params = strategies[msg.sender];\n        // Updating parameters in the `perpetualManager`\n        // This needs to be done now because it has implications in `_getTotalAsset()`\n        params.totalStrategyDebt = params.totalStrategyDebt + gain - loss;\n        totalDebt = totalDebt + gain - loss;\n        params.lastReport = block.timestamp;\n\n        // Warning: `_getTotalAsset` could be manipulated by flashloan attacks.\n        // It may allow external users to transfer funds into strategy or remove funds\n        // from the strategy. Yet, as it does not impact the profit or loss and as attackers\n        // have no interest in making such txs to have a direct profit, we let it as is.\n        // The only issue is if the strategy is compromised; in this case governance\n        // should revoke the strategy\n        uint256 target = ((_getTotalAsset()) * params.debtRatio) / BASE_PARAMS;\n        // console.log(\"PoolManager - report\");\n        // console.log(\"_getTotalAsset %s / target %s\", _getTotalAsset(), target);\n        if (target > params.totalStrategyDebt) {\n            // If the strategy has some credit left, tokens can be transferred to this strategy\n            uint256 available = Math.min(target - params.totalStrategyDebt, _getBalance());\n            // console.log(\"available1 %s\", available);\n            params.totalStrategyDebt = params.totalStrategyDebt + available;\n            totalDebt = totalDebt + available;\n            if (available > 0) {\n                token.safeTransfer(msg.sender, available);\n            }\n        } else {\n            uint256 available = Math.min(params.totalStrategyDebt - target, debtPayment + gain);\n            // console.log(\"available2 %s\", available);\n            params.totalStrategyDebt = params.totalStrategyDebt - available;\n            totalDebt = totalDebt - available;\n            if (available > 0) {\n                token.safeTransferFrom(msg.sender, address(this), available);\n            }\n        }\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, params.totalStrategyDebt);\n    }\n\n    function _getBalance() internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    function getTotalAsset() external view returns (uint256) {\n        return _getTotalAsset();\n    }\n\n    function _getTotalAsset() internal view returns (uint256) {\n        return _getBalance() + totalDebt;\n    }\n\n    function addStrategy(address strategy, uint256 _debtRatio) external {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.lastReport == 0, \"73\");\n        require(address(this) == IStrategy(strategy).poolManager(), \"74\");\n        // Using current code, this condition should always be verified as in the constructor\n        // of the strategy the `want()` is set to the token of this `PoolManager`\n        require(address(token) == IStrategy(strategy).want(), \"75\");\n        require(debtRatio + _debtRatio <= BASE_PARAMS, \"76\");\n\n        // Add strategy to approved strategies\n        params.lastReport = 1;\n        params.totalStrategyDebt = 0;\n        params.debtRatio = _debtRatio;\n\n        _grantRole(STRATEGY_ROLE, strategy);\n\n        // Update global parameters\n        debtRatio += _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n\n        strategyList.push(strategy);\n    }\n\n    function revokeStrategy(address strategy) external {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.debtRatio == 0, \"77\");\n        require(params.totalStrategyDebt == 0, \"77\");\n        uint256 strategyListLength = strategyList.length;\n        require(params.lastReport != 0 && strategyListLength >= 1, \"78\");\n        // It has already been checked whether the strategy was a valid strategy\n        for (uint256 i = 0; i < strategyListLength - 1; i++) {\n            if (strategyList[i] == strategy) {\n                strategyList[i] = strategyList[strategyListLength - 1];\n                break;\n            }\n        }\n\n        strategyList.pop();\n\n        // Update global parameters\n        debtRatio -= params.debtRatio;\n        delete strategies[strategy];\n\n        _revokeRole(STRATEGY_ROLE, strategy);\n\n        emit StrategyRevoked(strategy);\n    }\n\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external {\n        StrategyParams storage params = strategies[strategy];\n        require(params.lastReport != 0, \"78\");\n        debtRatio = debtRatio + _debtRatio - params.debtRatio;\n        require(debtRatio <= BASE_PARAMS, \"76\");\n        params.debtRatio = _debtRatio;\n    }\n}\n"
    },
    "contracts/mock/MockPoolManager2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../external/AccessControlAngleUpgradeable.sol\";\n\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\nimport \"../utils/FunctionUtils.sol\";\n\nstruct SLPData {\n    // Last timestamp at which the `sanRate` has been updated for SLPs\n    uint256 lastBlockUpdated;\n    // Fees accumulated from previous blocks and to be distributed to SLPs\n    uint256 lockedInterests;\n    // Max interests used to update the `sanRate` in a single block\n    // Should be in collateral token base\n    uint256 maxInterestsDistributed;\n    // Amount of fees left aside for SLPs and that will be distributed\n    // when the protocol is collateralized back again\n    uint256 feesAside;\n    // Part of the fees normally going to SLPs that is left aside\n    // before the protocol is collateralized back again (depends on collateral ratio)\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippageFee;\n    // Portion of the fees from users minting and burning\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 feesForSLPs;\n    // Slippage factor that's applied to SLPs exiting (depends on collateral ratio)\n    // If `slippage = BASE_PARAMS`, SLPs can get nothing, if `slippage = 0` they get their full claim\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippage;\n    // Portion of the interests from lending\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 interestsForSLPs;\n}\n\nstruct MintBurnData {\n    // Values of the thresholds to compute the minting fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeMint;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeMint;\n    // Values of the thresholds to compute the burning fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeBurn;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeBurn;\n    // Max proportion of collateral from users that can be covered by HAs\n    // It is exactly the same as the parameter of the same name in `PerpetualManager`, whenever one is updated\n    // the other changes accordingly\n    uint64 targetHAHedge;\n    // Minting fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusMint;\n    // Burning fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusBurn;\n    // Parameter used to limit the number of stablecoins that can be issued using the concerned collateral\n    uint256 capOnStableMinted;\n}\n\ninterface IOracle {\n    function read() external view returns (uint256);\n\n    function readAll() external view returns (uint256 lowerRate, uint256 upperRate);\n\n    function readLower() external view returns (uint256);\n\n    function readUpper() external view returns (uint256);\n\n    function readQuote(uint256 baseAmount) external view returns (uint256);\n\n    function readQuoteLower(uint256 baseAmount) external view returns (uint256);\n\n    function inBase() external view returns (uint256);\n}\n\ninterface ISanToken is IERC20 {\n    function mint(address account, uint256 amount) external;\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    function burnSelf(uint256 amount, address burner) external;\n\n    function stableMaster() external view returns (address);\n\n    function poolManager() external view returns (address);\n}\n\ninterface IStableMaster {\n    function agToken() external view returns (address);\n\n    function signalLoss(uint256 loss) external;\n\n    function accumulateInterest(uint256 gain) external;\n\n    function collateralMap(IPoolManager poolManager)\n        external\n        view\n        returns (\n            IERC20 token,\n            ISanToken sanToken,\n            address perpetualManager,\n            IOracle oracle,\n            uint256 stocksUsers,\n            uint256 sanRate,\n            uint256 collatBase,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        );\n}\n\n/// @title PoolManager\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file contains the functions that are callable by governance or by other contracts of the protocol\n/// @dev References to this contract are called `PoolManager`\ncontract PoolManager is IPoolManagerFunctions, AccessControlAngleUpgradeable, FunctionUtils {\n    using SafeERC20 for IERC20;\n\n    /// @notice Interface for the underlying token accepted by this contract\n    IERC20 public token;\n\n    /// @notice Reference to the `StableMaster` contract corresponding to this `PoolManager`\n    IStableMaster public stableMaster;\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Funds currently given to strategies\n    uint256 public totalDebt;\n\n    /// @notice Proportion of the funds managed dedicated to strategies\n    /// Has to be between 0 and `BASE_PARAMS`\n    uint256 public debtRatio;\n\n    /// The struct `StrategyParams` is defined in the interface `IPoolManager`\n    /// @notice Mapping between the address of a strategy contract and its corresponding details\n    mapping(address => StrategyParams) public strategies;\n\n    /// @notice List of the current strategies\n    address[] public strategyList;\n\n    /// @notice Address of the surplus distributor allowed to distribute rewards\n    address public surplusConverter;\n\n    /// @notice Share of the interests going to surplus and share going to SLPs\n    uint64 public interestsForSurplus;\n\n    /// @notice Interests accumulated by the protocol and to be distributed through ANGLE or veANGLE\n    /// token holders\n    uint256 public interestsAccumulated;\n\n    /// @notice Debt that must be paid by admins after a loss on a strategy\n    uint256 public adminDebt;\n\n    event FeesDistributed(uint256 amountDistributed);\n\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    event StrategyAdded(address indexed strategy, uint256 debtRatio);\n\n    event InterestsForSurplusUpdated(uint64 _interestsForSurplus);\n\n    event SurplusConverterUpdated(address indexed newSurplusConverter, address indexed oldSurplusConverter);\n\n    event StrategyRevoked(address indexed strategy);\n\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 totalDebt\n    );\n\n    // Roles need to be defined here because there are some internal access control functions\n    // in the `PoolManagerInternal` file\n\n    /// @notice Role for `StableMaster` only\n    bytes32 public constant STABLEMASTER_ROLE = keccak256(\"STABLEMASTER_ROLE\");\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for `Strategy` only\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n\n    constructor(\n        address _token,\n        address governor,\n        address guardian\n    ) {\n        token = IERC20(_token);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n    }\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Internal version of `updateStrategyDebtRatio`\n    /// @dev Updates the debt ratio for a strategy\n    function _updateStrategyDebtRatio(address strategy, uint256 _debtRatio) internal {\n        StrategyParams storage params = strategies[strategy];\n        require(params.lastReport != 0, \"78\");\n        debtRatio = debtRatio + _debtRatio - params.debtRatio;\n        require(debtRatio <= BASE_PARAMS, \"76\");\n        params.debtRatio = _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n    }\n\n    // ============================ Utils ==========================================\n\n    /// @notice Returns this `PoolManager`'s reserve of collateral (not including what has been lent)\n    function _getBalance() internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns the amount of assets owned by this `PoolManager`\n    /// @dev This sums the current balance of the contract to what has been given to strategies\n    /// @dev This amount can be manipulated by flash loans\n    function _getTotalAsset() internal view returns (uint256) {\n        return _getBalance() + totalDebt;\n    }\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Provides an estimated Annual Percentage Rate for SLPs based on lending to other protocols\n    /// @dev This function is an estimation and is made for external use only\n    /// @dev This does not take into account transaction fees which accrue to SLPs too\n    /// @dev This can be manipulated by a flash loan attack (SLP deposit/ withdraw) via `_getTotalAsset`\n    /// when entering you should make sure this hasn't be called by a flash loan and look\n    /// at a mean of past APR.\n    function estimatedAPR() external view returns (uint256 apr) {\n        apr = 0;\n        (, ISanToken sanTokenForAPR, , , , uint256 sanRate, , SLPData memory slpData, ) = stableMaster.collateralMap(\n            IPoolManager(address(this))\n        );\n        uint256 supply = sanTokenForAPR.totalSupply();\n\n        // `sanRate` should never be equal to 0\n        if (supply == 0) return type(uint256).max;\n\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            apr =\n                apr +\n                (strategies[strategyList[i]].debtRatio * IStrategy(strategyList[i]).estimatedAPR()) /\n                BASE_PARAMS;\n        }\n        apr = (apr * slpData.interestsForSLPs * _getTotalAsset()) / sanRate / supply;\n    }\n\n    /// @notice Tells a strategy how much it can borrow from this `PoolManager`\n    /// @return Amount of token a strategy has access to as a credit line\n    /// @dev Since this function is a view function, there is no need to have an access control logic\n    /// even though it will just be relevant for a strategy\n    /// @dev Manipulating `_getTotalAsset` with a flashloan will only\n    /// result in tokens being transferred at the cost of the caller\n    function creditAvailable() external view override returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        if (target < params.totalStrategyDebt) return 0;\n\n        return Math.min(target - params.totalStrategyDebt, _getBalance());\n    }\n\n    /// @notice Tells a strategy how much it owes to this `PoolManager`\n    /// @return Amount of token a strategy has to reimburse\n    /// @dev Manipulating `_getTotalAsset` with a flashloan will only\n    /// result in tokens being transferred at the cost of the caller\n    function debtOutstanding() external view override returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        if (target > params.totalStrategyDebt) return 0;\n\n        return (params.totalStrategyDebt - target);\n    }\n\n    /// @notice Reports the gains or loss made by a strategy\n    /// @param gain Amount strategy has realized as a gain on its investment since its\n    /// last report, and is free to be given back to `PoolManager` as earnings\n    /// @param loss Amount strategy has realized as a loss on its investment since its\n    /// last report, and should be accounted for on the `PoolManager`'s balance sheet.\n    /// The loss will reduce the `debtRatio`. The next time the strategy will harvest,\n    /// it will pay back the debt in an attempt to adjust to the new debt limit.\n    /// @param debtPayment Amount strategy has made available to cover outstanding debt\n    /// @dev This is the main contact point where the strategy interacts with the `PoolManager`\n    /// @dev The strategy reports back what it has free, then the `PoolManager` contract \"decides\"\n    /// whether to take some back or give it more. Note that the most it can\n    /// take is `gain + _debtPayment`, and the most it can give is all of the\n    /// remaining reserves. Anything outside of those bounds is abnormal behavior.\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external override onlyRole(STRATEGY_ROLE) {\n        require(token.balanceOf(msg.sender) >= gain + debtPayment, \"72\");\n\n        StrategyParams storage params = strategies[msg.sender];\n        // Updating parameters in the `perpetualManager`\n        // This needs to be done now because it has implications in `_getTotalAsset()`\n        params.totalStrategyDebt = params.totalStrategyDebt + gain - loss;\n        totalDebt = totalDebt + gain - loss;\n        params.lastReport = block.timestamp;\n\n        // Warning: `_getTotalAsset` could be manipulated by flashloan attacks.\n        // It may allow external users to transfer funds into strategy or remove funds\n        // from the strategy. Yet, as it does not impact the profit or loss and as attackers\n        // have no interest in making such txs to have a direct profit, we let it as is.\n        // The only issue is if the strategy is compromised; in this case governance\n        // should revoke the strategy\n        uint256 target = ((_getTotalAsset()) * params.debtRatio) / BASE_PARAMS;\n\n        if (target > params.totalStrategyDebt) {\n            // If the strategy has some credit left, tokens can be transferred to this strategy\n            uint256 available = Math.min(target - params.totalStrategyDebt, _getBalance());\n            params.totalStrategyDebt = params.totalStrategyDebt + available;\n            totalDebt = totalDebt + available;\n            if (available > 0) {\n                token.safeTransfer(msg.sender, available);\n            }\n        } else {\n            uint256 available = Math.min(params.totalStrategyDebt - target, debtPayment + gain);\n            params.totalStrategyDebt = params.totalStrategyDebt - available;\n            totalDebt = totalDebt - available;\n            if (available > 0) {\n                token.safeTransferFrom(msg.sender, address(this), available);\n            }\n        }\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, params.totalStrategyDebt);\n\n        // Handle gains before losses\n        if (gain > 0) {\n            uint256 gainForSurplus = (gain * interestsForSurplus) / BASE_PARAMS;\n            uint256 adminDebtPre = adminDebt;\n            // Depending on the current admin debt distribute the necessary gain from the strategies\n            if (adminDebtPre == 0) interestsAccumulated += gainForSurplus;\n            else if (adminDebtPre <= gainForSurplus) {\n                interestsAccumulated += gainForSurplus - adminDebtPre;\n                adminDebt = 0;\n            } else adminDebt -= gainForSurplus;\n            // stableMaster.accumulateInterest(gain - gainForSurplus);\n            emit FeesDistributed(gain);\n        }\n\n        // Handle eventual losses\n        if (loss > 0) {\n            uint256 lossForSurplus = (loss * interestsForSurplus) / BASE_PARAMS;\n            uint256 interestsAccumulatedPreLoss = interestsAccumulated;\n            // If the loss can not be entirely soaked by the interests to be distributed then\n            // the protocol keeps track of the debt\n            if (lossForSurplus > interestsAccumulatedPreLoss) {\n                interestsAccumulated = 0;\n                adminDebt += lossForSurplus - interestsAccumulatedPreLoss;\n            } else interestsAccumulated -= lossForSurplus;\n            // The rest is incurred to SLPs\n            // stableMaster.signalLoss(loss - lossForSurplus);\n        }\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Allows to recover any ERC20 token, including the token handled by this contract, and to send it\n    /// to a contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev As this function can be used to transfer funds to another contract, it has to be a `GOVERNOR` function\n    /// @dev In case the concerned token is the specific token handled by this contract, this function checks that the\n    /// amount entered is not too big and approximates the surplus of the protocol\n    /// @dev To esimate the amount of user claims on the concerned collateral, this function uses the `stocksUsers` for\n    /// this collateral, but this is just an approximation as users can claim the collateral of their choice provided\n    /// that they own a stablecoin\n    /// @dev The sanity check excludes the HA claims: to get a sense of it, this function would need to compute the cash out\n    /// amount of all the perpetuals, and this cannot be done on-chain in a cheap manner\n    /// @dev Overall, even though there is a sanity check, this function relies on the fact that governance is not corrupted\n    /// in this protocol and will not try to withdraw too much funds\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyRole(GOVERNOR_ROLE) {\n        if (tokenAddress == address(token)) {\n            // Fetching info from the `StableMaster`\n            (\n                ,\n                ISanToken sanToken,\n                ,\n                IOracle oracle,\n                uint256 stocksUsers,\n                uint256 sanRate,\n                uint256 collatBase,\n                ,\n\n            ) = stableMaster.collateralMap(IPoolManager(address(this)));\n\n            // Checking if there are enough reserves for the amount to withdraw\n            require(\n                _getTotalAsset() >=\n                    amountToRecover +\n                        (sanToken.totalSupply() * sanRate) /\n                        BASE_TOKENS +\n                        (stocksUsers * collatBase) /\n                        oracle.readUpper() +\n                        interestsAccumulated,\n                \"66\"\n            );\n\n            token.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Adds a strategy to the `PoolManager`\n    /// @param strategy The address of the strategy to add\n    /// @param _debtRatio The share of the total assets that the strategy has access to\n    /// @dev Multiple checks are made. For instance, the contract must not already belong to the `PoolManager`\n    /// and the underlying token of the strategy has to be consistent with the `PoolManager` contracts\n    /// @dev This function is a `governor` function and not a `guardian` one because a `guardian` could add a strategy\n    /// enabling the withdraw of the funds of the protocol\n    /// @dev The `_debtRatio` should be expressed in `BASE_PARAMS`\n    function addStrategy(address strategy, uint256 _debtRatio) external onlyRole(GOVERNOR_ROLE) {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.lastReport == 0, \"73\");\n        require(address(this) == IStrategy(strategy).poolManager(), \"74\");\n        // Using current code, this condition should always be verified as in the constructor\n        // of the strategy the `want()` is set to the token of this `PoolManager`\n        require(address(token) == IStrategy(strategy).want(), \"75\");\n        require(debtRatio + _debtRatio <= BASE_PARAMS, \"76\");\n\n        // Add strategy to approved strategies\n        params.lastReport = 1;\n        params.totalStrategyDebt = 0;\n        params.debtRatio = _debtRatio;\n\n        _grantRole(STRATEGY_ROLE, strategy);\n\n        // Update global parameters\n        debtRatio += _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n\n        strategyList.push(strategy);\n    }\n\n    // =========================== Guardian Functions ==============================\n\n    /// @notice Changes the guardian address and echoes it to other contracts that interact with this `PoolManager`\n    /// @param _guardian New guardian address\n    /// @param guardian Old guardian address to revoke\n    function setGuardian(address _guardian, address guardian) external onlyRole(GUARDIAN_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role in other contract\n        uint256 strategyListLength = strategyList.length;\n        for (uint256 i = 0; i < strategyListLength; i++) {\n            IStrategy(strategyList[i]).addGuardian(_guardian);\n        }\n        for (uint256 i = 0; i < strategyListLength; i++) {\n            IStrategy(strategyList[i]).revokeGuardian(guardian);\n        }\n        _revokeRole(GUARDIAN_ROLE, guardian);\n    }\n\n    /// @notice Modifies the funds a strategy has access to\n    /// @param strategy The address of the Strategy\n    /// @param _debtRatio The share of the total assets that the strategy has access to\n    /// @dev The update has to be such that the `debtRatio` does not exceeds the 100% threshold\n    /// as this `PoolManager` cannot lend collateral that it doesn't not own.\n    /// @dev `_debtRatio` is stored as a uint256 but as any parameter of the protocol, it should be expressed\n    /// in `BASE_PARAMS`\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external onlyRole(GUARDIAN_ROLE) {\n        _updateStrategyDebtRatio(strategy, _debtRatio);\n    }\n\n    /// @notice Triggers an emergency exit for a strategy and then harvests it to fetch all the funds\n    /// @param strategy The address of the `Strategy`\n    function setStrategyEmergencyExit(address strategy) external onlyRole(GUARDIAN_ROLE) {\n        _updateStrategyDebtRatio(strategy, 0);\n        IStrategy(strategy).setEmergencyExit();\n        IStrategy(strategy).harvest();\n    }\n\n    /// @notice Revokes a strategy\n    /// @param strategy The address of the strategy to revoke\n    /// @dev This should only be called after the following happened in order: the `strategy.debtRatio` has been set to 0,\n    /// `harvest` has been called enough times to recover all capital gain/losses.\n    function revokeStrategy(address strategy) external onlyRole(GUARDIAN_ROLE) {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.debtRatio == 0, \"77\");\n        require(params.totalStrategyDebt == 0, \"77\");\n        uint256 strategyListLength = strategyList.length;\n        require(params.lastReport != 0 && strategyListLength >= 1, \"78\");\n        // It has already been checked whether the strategy was a valid strategy\n        for (uint256 i = 0; i < strategyListLength - 1; i++) {\n            if (strategyList[i] == strategy) {\n                strategyList[i] = strategyList[strategyListLength - 1];\n                break;\n            }\n        }\n\n        strategyList.pop();\n\n        // Update global parameters\n        debtRatio -= params.debtRatio;\n        delete strategies[strategy];\n\n        _revokeRole(STRATEGY_ROLE, strategy);\n\n        emit StrategyRevoked(strategy);\n    }\n\n    /// @notice Withdraws a given amount from a strategy\n    /// @param strategy The address of the strategy\n    /// @param amount The amount to withdraw\n    /// @dev This function tries to recover `amount` from the strategy, but it may not go through\n    /// as we may not be able to withdraw from the lending protocol the full amount\n    /// @dev In this last case we only update the parameters by setting the loss as the gap between\n    /// what has been asked and what has been returned.\n    function withdrawFromStrategy(IStrategy strategy, uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        StrategyParams storage params = strategies[address(strategy)];\n        require(params.lastReport != 0, \"78\");\n\n        uint256 loss;\n        (amount, loss) = strategy.withdraw(amount);\n\n        // Handling eventual losses\n        params.totalStrategyDebt = params.totalStrategyDebt - loss - amount;\n        totalDebt = totalDebt - loss - amount;\n\n        emit StrategyReported(address(strategy), 0, loss, amount - loss, params.totalStrategyDebt);\n\n        // Handle eventual losses\n        // With the strategy we are using in current tests, it is going to be impossible to have\n        // a positive loss by calling strategy.withdraw, this function indeed calls _liquidatePosition\n        // which output value is always zero\n        // if (loss > 0) stableMaster.signalLoss(loss);\n    }\n\n    // =================== Surplus Distributor Function ============================\n\n    /// @notice Allows to push interests revenue accumulated by the protocol to the `surplusConverter` to do buybacks\n    ///  or another form of redistribution to ANGLE or veANGLE token holders\n    /// @dev This function is permissionless and anyone can transfer the `interestsAccumulated` by the protocol\n    /// to the `surplusConverter`\n    function pushSurplus() external {\n        // If the `surplusConverter` has not been initialized, surplus should not be distributed\n        // Storing the `surplusConverter` in an intermediate variable to avoid multiple reads in\n        // storage\n        address surplusConverterMem = surplusConverter;\n        require(surplusConverterMem != address(0), \"0\");\n        uint256 amount = interestsAccumulated;\n        interestsAccumulated = 0;\n        // Storing the `token` in memory to avoid duplicate reads in storage\n        IERC20 tokenMem = token;\n        tokenMem.safeTransfer(surplusConverterMem, amount);\n        emit Recovered(address(tokenMem), surplusConverterMem, amount);\n    }\n\n    // ======================== Getters - View Functions ===========================\n\n    /// @notice Gets the current balance of this `PoolManager` contract\n    /// @return The amount of the underlying collateral that the contract currently owns\n    /// @dev This balance does not take into account what has been lent to strategies\n    function getBalance() external view override returns (uint256) {\n        return _getBalance();\n    }\n\n    /// @notice Gets the total amount of collateral that is controlled by this `PoolManager` contract\n    /// @return The amount of collateral owned by this contract plus the amount that has been lent to strategies\n    /// @dev This is the value that is used to compute the debt ratio for a given strategy\n    function getTotalAsset() external view override returns (uint256) {\n        return _getTotalAsset();\n    }\n}\n"
    },
    "contracts/mock/MockStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./MockToken.sol\";\n\ncontract MockStETH is MockToken {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    /// @dev To account for the fact that the balance increases we can simply mint stETH to the concerned address\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) MockToken(name_, symbol_, decimal_) {}\n\n    receive() external payable {}\n\n    function submit(address) external payable returns (uint256) {\n        _mint(msg.sender, msg.value);\n        return msg.value;\n    }\n}\n"
    },
    "contracts/mock/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IPoolManager.sol\";\n\ncontract MockStrategy {\n    address public poolManager;\n\n    address public want;\n\n    constructor(address _poolManager, address _want) {\n        poolManager = _poolManager;\n        want = _want;\n    }\n\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external {\n        IPoolManager(poolManager).report(gain, loss, debtPayment);\n    }\n\n    function withdraw(uint256 amount) external pure returns (uint256, uint256) {\n        return (amount, 1);\n    }\n\n    function creditAvailable() external view returns (uint256 credit) {\n        credit = IPoolManager(poolManager).creditAvailable();\n    }\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    /// For example, if `decimals` equals `2`, a balance of `505` tokens should\n    /// be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    /// @notice allow to mint\n    /// @param account the account to mint to\n    /// @param amount the amount to mint\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    /// @notice allow to burn\n    /// @param account the account to burn from\n    /// @param amount the amount of agToken to burn from caller\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n}\n"
    },
    "contracts/mock/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./MockToken.sol\";\n\ncontract MockWETH is MockToken {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    receive() external payable {}\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) MockToken(name_, symbol_, decimal_) {}\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        _burn(msg.sender, wad);\n        // solhint-disable-next-line\n        (bool sent, ) = msg.sender.call{ value: wad }(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit Withdrawal(msg.sender, wad);\n    }\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/AaveLibraries.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport { IPriceOracle, IOptionalERC20 } from \"../../interfaces/external/aave/IAave.sol\";\nimport { IAToken } from \"../../interfaces/external/aave/IAaveToken.sol\";\nimport { IProtocolDataProvider } from \"../../interfaces/external/aave/IProtocolDataProvider.sol\";\nimport { ILendingPool } from \"../../interfaces/external/aave/ILendingPool.sol\";\n\nlibrary FlashMintLib {\n    event Leverage(\n        uint256 amountRequested,\n        uint256 amountUsed,\n        uint256 requiredDAI,\n        uint256 amountToCloseLTVGap,\n        bool deficit,\n        address flashLoan\n    );\n\n    address public constant LENDER = 0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853;\n    uint256 private constant _DAI_DECIMALS = 1e18;\n    uint256 private constant _COLLAT_RATIO_PRECISION = 1 ether;\n    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant _DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    IAToken public constant ADAI = IAToken(0x028171bCA77440897B824Ca71D1c56caC55b68A3);\n    // solhint-disable-next-line\n    IProtocolDataProvider private constant _protocolDataProvider =\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\n    // solhint-disable-next-line\n    ILendingPool private constant _lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    // solhint-disable-next-line\n    uint16 private constant _referral = 0; // TODO: get our own referral code\n\n    uint256 private constant _RAY = 10**27;\n\n    function doFlashMint(\n        bool deficit,\n        uint256 amountDesired,\n        address token,\n        uint256 collatRatioDAI,\n        uint256 depositToCloseLTVGap\n    ) public returns (uint256 amount) {\n        if (amountDesired == 0) {\n            return 0;\n        }\n        amount = amountDesired;\n        address dai = _DAI;\n\n        // calculate amount of dai we need\n        uint256 requiredDAI;\n        {\n            requiredDAI = (toDAI(amount, token) * _COLLAT_RATIO_PRECISION) / collatRatioDAI;\n\n            uint256 requiredDAIToCloseLTVGap = 0;\n            if (depositToCloseLTVGap > 0) {\n                requiredDAIToCloseLTVGap = toDAI(depositToCloseLTVGap, token);\n                requiredDAI = requiredDAI + requiredDAIToCloseLTVGap;\n            }\n\n            uint256 _maxLiquidity = maxLiquidity();\n\n            /*\n            When depositing/withdrawing in the `lendingPool` the amounts are scaled by a `liquidityIndex` and rounded with the functions rayDiv and rayMul (in the aDAI contract)\n            Weirdly, 2 different indexes are used: `liquidityIndex` is used when depositing and `getReserveNormalizedIncome` when withdrawing\n            Therefore, we need to round `requiredDAI`, or we may get some rounding errors and revert\n            because the amount we try to withdraw (to pay back the flashloan) is not equal to the amount deposited\n            */\n            uint256 liquidityIndex = _lendingPool.getReserveData(dai).liquidityIndex;\n            uint256 getReserveNormalizedIncome = _lendingPool.getReserveNormalizedIncome(dai);\n            uint256 rayDiv = ((requiredDAI * _RAY + liquidityIndex / 2) / liquidityIndex);\n            requiredDAI = (rayDiv * getReserveNormalizedIncome + (_RAY / 2)) / _RAY;\n\n            if (requiredDAI > _maxLiquidity) {\n                requiredDAI = (_maxLiquidity * _RAY - (_RAY / 2)) / getReserveNormalizedIncome;\n                requiredDAI = (requiredDAI * liquidityIndex - liquidityIndex / 2) / _RAY;\n\n                // NOTE: if we cap amountDAI, we reduce amountToken we are taking too\n                amount =\n                    (fromDAI(requiredDAI - requiredDAIToCloseLTVGap, token) * collatRatioDAI) /\n                    _COLLAT_RATIO_PRECISION;\n            }\n        }\n\n        bytes memory data = abi.encode(deficit, amount);\n        uint256 _fee = IERC3156FlashLender(LENDER).flashFee(dai, requiredDAI);\n        // Check that fees have not been increased without us knowing\n        require(_fee == 0);\n        uint256 _allowance = IERC20(dai).allowance(address(this), address(LENDER));\n        if (_allowance < requiredDAI) {\n            IERC20(dai).approve(address(LENDER), 0);\n            IERC20(dai).approve(address(LENDER), type(uint256).max);\n        }\n\n        IERC3156FlashLender(LENDER).flashLoan(IERC3156FlashBorrower(address(this)), dai, requiredDAI, data);\n\n        emit Leverage(amountDesired, amount, requiredDAI, depositToCloseLTVGap, deficit, LENDER);\n\n        return amount; // we need to return the amount of Token we have changed our position in\n    }\n\n    function loanLogic(\n        bool deficit,\n        uint256 amount,\n        uint256 amountFlashmint,\n        address want\n    ) public returns (bytes32) {\n        address dai = _DAI;\n        bool isDai = (want == dai);\n\n        ILendingPool lp = _lendingPool;\n\n        if (isDai) {\n            if (deficit) {\n                lp.deposit(dai, amountFlashmint - amount, address(this), _referral);\n                lp.repay(dai, IERC20(dai).balanceOf(address(this)), 2, address(this));\n                lp.withdraw(dai, amountFlashmint, address(this));\n            } else {\n                lp.deposit(dai, IERC20(dai).balanceOf(address(this)), address(this), _referral);\n                lp.borrow(dai, amount, 2, _referral, address(this));\n                lp.withdraw(dai, amountFlashmint - amount, address(this));\n            }\n        } else {\n            // 1. Deposit DAI in Aave as collateral\n            lp.deposit(dai, amountFlashmint, address(this), _referral);\n\n            if (deficit) {\n                // 2a. If in deficit withdraw amount and repay it\n                lp.withdraw(want, amount, address(this));\n                lp.repay(want, IERC20(want).balanceOf(address(this)), 2, address(this));\n            } else {\n                // 2b. If levering up borrow and deposit\n                lp.borrow(want, amount, 2, _referral, address(this));\n                lp.deposit(want, IERC20(want).balanceOf(address(this)), address(this), _referral);\n            }\n            // 3. Withdraw DAI\n            lp.withdraw(dai, amountFlashmint, address(this));\n        }\n\n        return CALLBACK_SUCCESS;\n    }\n\n    function priceOracle() internal view returns (IPriceOracle) {\n        return IPriceOracle(_protocolDataProvider.ADDRESSES_PROVIDER().getPriceOracle());\n    }\n\n    function toDAI(uint256 _amount, address asset) internal view returns (uint256) {\n        address dai = _DAI;\n        if (_amount == 0 || _amount == type(uint256).max || asset == dai) {\n            return _amount;\n        }\n\n        if (asset == _WETH) {\n            return\n                (_amount * (uint256(10)**uint256(IOptionalERC20(dai).decimals()))) / priceOracle().getAssetPrice(dai);\n        }\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = asset;\n        tokens[1] = dai;\n        uint256[] memory prices = priceOracle().getAssetsPrices(tokens);\n\n        uint256 ethPrice = (_amount * prices[0]) / (uint256(10)**uint256(IOptionalERC20(asset).decimals()));\n        return (ethPrice * _DAI_DECIMALS) / prices[1];\n    }\n\n    function fromDAI(uint256 _amount, address asset) internal view returns (uint256) {\n        address dai = _DAI;\n        if (_amount == 0 || _amount == type(uint256).max || asset == dai) {\n            return _amount;\n        }\n\n        if (asset == _WETH) {\n            return\n                (_amount * priceOracle().getAssetPrice(dai)) / (uint256(10)**uint256(IOptionalERC20(dai).decimals()));\n        }\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = asset;\n        tokens[1] = dai;\n        uint256[] memory prices = priceOracle().getAssetsPrices(tokens);\n\n        uint256 ethPrice = (_amount * prices[1]) / _DAI_DECIMALS;\n\n        return (ethPrice * (uint256(10)**uint256(IOptionalERC20(asset).decimals()))) / prices[0];\n    }\n\n    function maxLiquidity() public view returns (uint256) {\n        return IERC3156FlashLender(LENDER).maxFlashLoan(_DAI);\n    }\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/ComputeProfitability.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title ComputeProfitability\n/// @author Angle Core Team\n/// @notice Helper contract to get the optimal borrow amount from a set of provided parameters from Aave\nlibrary ComputeProfitability {\n    struct SCalculateBorrow {\n        int256 reserveFactor;\n        int256 totalStableDebt;\n        int256 totalVariableDebt;\n        int256 totalDeposits;\n        int256 stableBorrowRate;\n        int256 rewardDeposit;\n        int256 rewardBorrow;\n        int256 strategyAssets;\n        int256 guessedBorrowAssets;\n        int256 slope1;\n        int256 slope2;\n        int256 r0;\n        int256 uOptimal;\n    }\n\n    int256 private constant _BASE_RAY = 10**27;\n\n    /// @notice Computes the Aave utilization ratio\n    // solhint-disable-next-line\n    function _computeUtilization(int256 borrow, SCalculateBorrow memory parameters) internal pure returns (int256) {\n        return\n            ((parameters.totalStableDebt + parameters.totalVariableDebt + borrow) * _BASE_RAY) /\n            (parameters.totalDeposits + borrow);\n    }\n\n    /// @notice Computes the derivative of the utilization ratio with respect to the amount borrowed\n    // solhint-disable-next-line\n    function _computeUprime(int256 borrow, SCalculateBorrow memory parameters) internal pure returns (int256) {\n        return\n            ((parameters.totalDeposits - parameters.totalStableDebt - parameters.totalVariableDebt) * _BASE_RAY) /\n            (parameters.totalDeposits + borrow);\n    }\n\n    /// @notice Computes the value of the interest rate, its first and second order derivatives\n    /// @dev The returned value is in `_BASE_RAY`\n    // solhint-disable-next-line\n    function _calculateInterestPrimes(int256 borrow, SCalculateBorrow memory parameters)\n        internal\n        pure\n        returns (\n            int256 interest,\n            int256 interestPrime,\n            int256 interestPrime2\n        )\n    {\n        int256 newUtilization = _computeUtilization(borrow, parameters);\n        int256 denomUPrime = (parameters.totalDeposits + borrow);\n        int256 uprime = _computeUprime(borrow, parameters);\n        uprime = (uprime * _BASE_RAY) / denomUPrime;\n        int256 uprime2nd = -2 * uprime;\n        uprime2nd = (uprime2nd * _BASE_RAY) / denomUPrime;\n        if (newUtilization < parameters.uOptimal) {\n            interest = parameters.r0 + (parameters.slope1 * newUtilization) / parameters.uOptimal;\n            interestPrime = (parameters.slope1 * uprime) / parameters.uOptimal;\n            interestPrime2 = (parameters.slope1 * uprime2nd) / parameters.uOptimal;\n        } else {\n            interest =\n                parameters.r0 +\n                parameters.slope1 +\n                (parameters.slope2 * (newUtilization - parameters.uOptimal)) /\n                (_BASE_RAY - parameters.uOptimal);\n            interestPrime = (parameters.slope2 * uprime) / (_BASE_RAY - parameters.uOptimal);\n            interestPrime2 = (parameters.slope2 * uprime2nd) / (_BASE_RAY - parameters.uOptimal);\n        }\n    }\n\n    /// @notice Computes the value of the revenue, as well as its first and second order derivatives\n    // solhint-disable-next-line\n    function _revenuePrimes(\n        int256 borrow,\n        SCalculateBorrow memory parameters,\n        bool onlyRevenue\n    )\n        internal\n        pure\n        returns (\n            int256 revenue,\n            int256 revenuePrime,\n            int256 revenuePrime2nd\n        )\n    {\n        (int256 newRate, int256 newRatePrime, int256 newRatePrime2) = _calculateInterestPrimes(borrow, parameters);\n\n        // 0 order derivative\n        int256 proportionStrat = ((borrow + parameters.strategyAssets) * (_BASE_RAY - parameters.reserveFactor)) /\n            (borrow + parameters.totalDeposits);\n        int256 poolYearlyRevenue = (parameters.totalStableDebt *\n            parameters.stableBorrowRate +\n            (borrow + parameters.totalVariableDebt) *\n            newRate) / _BASE_RAY;\n\n        revenue =\n            (proportionStrat * poolYearlyRevenue) /\n            _BASE_RAY +\n            (borrow * parameters.rewardBorrow) /\n            (borrow + parameters.totalVariableDebt) +\n            ((borrow + parameters.strategyAssets) * parameters.rewardDeposit) /\n            (borrow + parameters.totalDeposits) -\n            (borrow * newRate) /\n            _BASE_RAY;\n\n        if (!onlyRevenue) {\n            // 1st order derivative\n            {\n                // Computing block per block to avoid stack too deep errors\n                int256 proportionStratPrime = ((parameters.totalDeposits - parameters.strategyAssets) *\n                    (_BASE_RAY - parameters.reserveFactor)) / (borrow + parameters.totalDeposits);\n                proportionStratPrime = (proportionStratPrime * _BASE_RAY) / (borrow + parameters.totalDeposits);\n                int256 poolYearlyRevenuePrime = (newRate *\n                    _BASE_RAY +\n                    (borrow + parameters.totalVariableDebt) *\n                    newRatePrime) / _BASE_RAY;\n\n                revenuePrime = ((proportionStratPrime * poolYearlyRevenue + poolYearlyRevenuePrime * proportionStrat) /\n                    _BASE_RAY);\n\n                {\n                    int256 proportionStratPrime2nd = (-2 * (proportionStratPrime * (_BASE_RAY))) /\n                        ((borrow + parameters.totalDeposits));\n                    revenuePrime2nd =\n                        2 *\n                        proportionStratPrime *\n                        poolYearlyRevenuePrime +\n                        proportionStratPrime2nd *\n                        poolYearlyRevenue;\n                }\n                poolYearlyRevenuePrime =\n                    (2 * newRatePrime * _BASE_RAY + (borrow + parameters.totalVariableDebt) * newRatePrime2) /\n                    _BASE_RAY;\n\n                revenuePrime2nd = (revenuePrime2nd + poolYearlyRevenuePrime * proportionStrat) / _BASE_RAY;\n            }\n\n            int256 costPrime = (newRate * _BASE_RAY + borrow * newRatePrime) / _BASE_RAY;\n            int256 rewardBorrowPrime = (parameters.rewardBorrow * (parameters.totalVariableDebt)) /\n                (borrow + parameters.totalVariableDebt);\n            rewardBorrowPrime = (rewardBorrowPrime * _BASE_RAY) / (borrow + parameters.totalVariableDebt);\n            int256 rewardDepositPrime = (parameters.rewardDeposit *\n                (parameters.totalDeposits - parameters.strategyAssets)) / (borrow + parameters.totalDeposits);\n            rewardDepositPrime = (rewardDepositPrime * _BASE_RAY) / (borrow + parameters.totalDeposits);\n\n            revenuePrime += rewardBorrowPrime + rewardDepositPrime - costPrime;\n\n            // 2nd order derivative\n            // Reusing variables for the stack too deep issue\n            costPrime = ((2 * newRatePrime * _BASE_RAY) + borrow * newRatePrime2) / _BASE_RAY;\n            rewardBorrowPrime = (-2 * rewardBorrowPrime * _BASE_RAY) / (borrow + parameters.totalVariableDebt);\n            rewardDepositPrime = (-2 * rewardDepositPrime * _BASE_RAY) / (borrow + parameters.totalDeposits);\n\n            revenuePrime2nd += (rewardBorrowPrime + rewardDepositPrime) - costPrime;\n        }\n    }\n\n    /// @notice Returns the absolute value of an integer\n    function _abs(int256 x) private pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n\n    /// @notice Computes the optimal borrow amount of the strategy depending on Aave protocol parameters\n    /// to maximize folding revenues\n    /// @dev Performs a newton Raphson approximation to get the zero point of the derivative of the\n    /// revenue function of the protocol depending on the amount borrowed\n    function computeProfitability(SCalculateBorrow memory parameters) internal pure returns (int256 borrow) {\n        (int256 y, , ) = _revenuePrimes(0, parameters, true);\n        (int256 revenueWithBorrow, , ) = _revenuePrimes(_BASE_RAY, parameters, true);\n\n        if (revenueWithBorrow <= y) {\n            return 0;\n        }\n        uint256 count;\n        int256 borrowInit;\n        int256 grad;\n        int256 grad2nd;\n        borrow = parameters.guessedBorrowAssets;\n        // Tolerance is 1% in this method: indeed we're stopping: `_abs(borrowInit - borrow)/ borrowInit < 10**(-2)`\n        while (count < 10 && (count == 0 || _abs(borrowInit - borrow) * (10**2 / 5) > borrowInit)) {\n            (, grad, grad2nd) = _revenuePrimes(borrow, parameters, false);\n            borrowInit = borrow;\n            borrow = borrowInit - (grad * _BASE_RAY) / grad2nd;\n            count += 1;\n        }\n\n        (int256 x, , ) = _revenuePrimes(borrow, parameters, true);\n        if (x <= y) {\n            borrow = 0;\n        }\n    }\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/ComputeProfitabilityTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./ComputeProfitability.sol\";\n\n/// @title ComputeProfitabilityTest\n/// @author Angle Core Team\n/// @notice Wrapper contract to ComputeProfitability for testing purpose\ncontract ComputeProfitabilityTest {\n    /// @notice external version of _calculateInterestPrimes\n    function calculateInterestPrimes(int256 borrow, ComputeProfitability.SCalculateBorrow memory parameters)\n        external\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        return ComputeProfitability._calculateInterestPrimes(borrow, parameters);\n    }\n\n    /// @notice External version of _revenuePrimes\n    function revenuePrimes(\n        int256 borrow,\n        ComputeProfitability.SCalculateBorrow memory parameters,\n        bool onlyRevenue\n    )\n        external\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        return ComputeProfitability._revenuePrimes(borrow, parameters, onlyRevenue);\n    }\n\n    /// @notice Computes the optimal borrow amount of the strategy depending on Aave protocol parameters\n    /// to maximize folding revenues\n    function computeProfitability(ComputeProfitability.SCalculateBorrow memory parameters)\n        external\n        pure\n        returns (int256)\n    {\n        return ComputeProfitability.computeProfitability(parameters);\n    }\n}\n"
    },
    "contracts/strategies/BaseStrategyEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../external/AccessControlAngle.sol\";\nimport \"../external/AccessControlAngleUpgradeable.sol\";\n\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IPoolManager.sol\";\n\nimport \"../utils/Errors.sol\";\n\n/// @title BaseStrategyEvents\n/// @author Angle Core Team\n/// @notice Events used in the abstract `BaseStrategy` contract\ncontract BaseStrategyEvents {\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\n\n    event UpdatedMinReportDelayed(uint256 delay);\n\n    event UpdatedMaxReportDelayed(uint256 delay);\n\n    event UpdatedDebtThreshold(uint256 debtThreshold);\n\n    event UpdatedRewards(address rewards);\n\n    event UpdatedIsRewardActivated(bool activated);\n\n    event UpdatedRewardAmountAndMinimumAmountMoved(uint256 _rewardAmount, uint256 _minimumAmountMoved);\n\n    event EmergencyExitActivated();\n}\n"
    },
    "contracts/strategies/BaseStrategyUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n                  *                                                  █                              \n                *****                                               ▓▓▓                             \n                  *                                               ▓▓▓▓▓▓▓                         \n                                   *            ///.           ▓▓▓▓▓▓▓▓▓▓▓▓▓                       \n                                 *****        ////////            ▓▓▓▓▓▓▓                          \n                                   *       /////////////            ▓▓▓                             \n                     ▓▓                  //////////////////          █         ▓▓                   \n                   ▓▓  ▓▓             ///////////////////////                ▓▓   ▓▓                \n                ▓▓       ▓▓        ////////////////////////////           ▓▓        ▓▓              \n              ▓▓            ▓▓    /////////▓▓▓///////▓▓▓/////////       ▓▓             ▓▓            \n           ▓▓                 ,////////////////////////////////////// ▓▓                 ▓▓         \n        ▓▓                  //////////////////////////////////////////                     ▓▓      \n      ▓▓                  //////////////////////▓▓▓▓/////////////////////                          \n                       ,////////////////////////////////////////////////////                        \n                    .//////////////////////////////////////////////////////////                     \n                     .//////////////////////////██.,//////////////////////////█                     \n                       .//////////////////////████..,./////////////////////██                       \n                        ...////////////////███████.....,.////////////////███                        \n                          ,.,////////////████████ ........,///////////████                          \n                            .,.,//////█████████      ,.......///////████                            \n                               ,..//████████           ........./████                               \n                                 ..,██████                .....,███                                 \n                                    .██                     ,.,█                                    \n                                                                                                    \n                                                                                                    \n                                                                                                    \n               ▓▓            ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓               ▓▓▓▓▓▓▓▓▓▓          \n             ▓▓▓▓▓▓          ▓▓▓    ▓▓▓       ▓▓▓               ▓▓               ▓▓   ▓▓▓▓         \n           ▓▓▓    ▓▓▓        ▓▓▓    ▓▓▓       ▓▓▓    ▓▓▓        ▓▓               ▓▓▓▓▓             \n          ▓▓▓        ▓▓      ▓▓▓    ▓▓▓       ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓▓▓▓          \n*/\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./BaseStrategyEvents.sol\";\n\n/// @title BaseStrategyUpgradeable\n/// @author Forked from https://github.com/yearn/yearn-managers/blob/master/contracts/BaseStrategy.sol\n/// @notice `BaseStrategyUpgradeable` implements all of the required functionalities to interoperate\n/// with the `PoolManager` Contract.\n/// @dev This contract should be inherited and the abstract methods implemented to adapt the `Strategy`\n/// to the particular needs it has to create a return.\nabstract contract BaseStrategyUpgradeable is BaseStrategyEvents, AccessControlAngleUpgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**18;\n    uint256 public constant SECONDS_PER_YEAR = 31556952;\n\n    /// @notice Role for `PoolManager` only - keccak256(\"POOLMANAGER_ROLE\")\n    bytes32 public constant POOLMANAGER_ROLE = 0x5916f72c85af4ac6f7e34636ecc97619c4b2085da099a5d28f3e58436cfbe562;\n    /// @notice Role for guardians and governors - keccak256(\"GUARDIAN_ROLE\")\n    bytes32 public constant GUARDIAN_ROLE = 0x55435dd261a4b9b3364963f7738a7a662ad9c84396d64be3365284bb7f0a5041;\n    /// @notice Role for keepers - keccak256(\"KEEPER_ROLE\")\n    bytes32 public constant KEEPER_ROLE = 0xfc8737ab85eb45125971625a9ebdb75cc78e01d5c1fa80c4c6e5203f47bc4fab;\n\n    // ================================= REFERENCES ================================\n\n    /// @notice See note on `setEmergencyExit()`\n    bool public emergencyExit;\n\n    /// @notice Reference to the protocol's collateral `PoolManager`\n    IPoolManager public poolManager;\n\n    /// @notice Reference to the ERC20 farmed by this strategy\n    IERC20 public want;\n\n    /// @notice Base of the ERC20 token farmed by this strategy\n    uint256 public wantBase;\n\n    // ================================= PARAMETERS ================================\n\n    /// @notice Use this to adjust the threshold at which running a debt causes a\n    /// harvest trigger. See `setDebtThreshold()` for more details\n    uint256 public debtThreshold;\n\n    uint256[46] private __gapBaseStrategy;\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Constructor of the `BaseStrategyUpgradeable`\n    /// @param _poolManager Address of the `PoolManager` lending collateral to this strategy\n    /// @param governor Governor address of the protocol\n    /// @param guardian Address of the guardian\n    function _initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers\n    ) internal initializer {\n        poolManager = IPoolManager(_poolManager);\n        want = IERC20(poolManager.token());\n        wantBase = 10**(IERC20Metadata(address(want)).decimals());\n        if (guardian == address(0) || governor == address(0) || governor == guardian) revert ZeroAddress();\n        // AccessControl\n        // Governor is guardian so no need for a governor role\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setupRole(POOLMANAGER_ROLE, address(_poolManager));\n        _setRoleAdmin(POOLMANAGER_ROLE, POOLMANAGER_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, POOLMANAGER_ROLE);\n\n        // Initializing roles first\n        uint256 keepersLength = keepers.length;\n        for (uint256 i; i < keepersLength; ++i) {\n            if (keepers[i] == address(0)) revert ZeroAddress();\n            _setupRole(KEEPER_ROLE, keepers[i]);\n        }\n        _setRoleAdmin(KEEPER_ROLE, GUARDIAN_ROLE);\n\n        debtThreshold = 100 * BASE;\n        emergencyExit = false;\n        // Give `PoolManager` unlimited access (might save gas)\n        want.safeIncreaseAllowance(address(poolManager), type(uint256).max);\n    }\n\n    // =============================== CORE FUNCTIONS ==============================\n\n    /// @notice Harvests the Strategy, recognizing any profits or losses and adjusting\n    /// the Strategy's position.\n    function harvest() external {\n        _report();\n        // Check if free returns are left, and re-invest them\n        _adjustPosition();\n    }\n\n    /// @notice Same as the function above with a `data` parameter to help adjust the position\n    /// @dev Since this function is permissionless, strategy implementations should be made\n    /// to remain safe regardless of the data that is passed in the call\n    function harvest(bytes memory data) external virtual {\n        _report();\n        _adjustPosition(data);\n    }\n\n    /// @notice Same as above with a `borrowInit` parameter to help in case of the convergence of the `adjustPosition`\n    /// method\n    function harvest(uint256 borrowInit) external onlyRole(KEEPER_ROLE) {\n        _report();\n        _adjustPosition(borrowInit);\n    }\n\n    /// @notice Withdraws `_amountNeeded` to `poolManager`.\n    /// @param _amountNeeded How much `want` to withdraw.\n    /// @return amountFreed How much `want` withdrawn.\n    /// @return _loss Any realized losses\n    /// @dev This may only be called by the `PoolManager`\n    function withdraw(uint256 _amountNeeded)\n        external\n        onlyRole(POOLMANAGER_ROLE)\n        returns (uint256 amountFreed, uint256 _loss)\n    {\n        // Liquidate as much as possible `want` (up to `_amountNeeded`)\n        (amountFreed, _loss) = _liquidatePosition(_amountNeeded);\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\n        want.safeTransfer(msg.sender, amountFreed);\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\n    }\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @notice Provides an accurate estimate for the total amount of assets\n    /// (principle + return) that this Strategy is currently managing,\n    /// denominated in terms of `want` tokens.\n    /// This total should be \"realizable\" e.g. the total value that could\n    /// *actually* be obtained from this Strategy if it were to divest its\n    /// entire position based on current on-chain conditions.\n    /// @return The estimated total assets in this Strategy.\n    /// @dev Care must be taken in using this function, since it relies on external\n    /// systems, which could be manipulated by the attacker to give an inflated\n    /// (or reduced) value produced by this function, based on current on-chain\n    /// conditions (e.g. this function is possible to influence through\n    /// flashloan attacks, oracle manipulations, or other DeFi attack\n    /// mechanisms).\n    function estimatedTotalAssets() public view virtual returns (uint256);\n\n    /// @notice Provides an indication of whether this strategy is currently \"active\"\n    /// in that it is managing an active position, or will manage a position in\n    /// the future. This should correlate to `harvest()` activity, so that Harvest\n    /// events can be tracked externally by indexing agents.\n    /// @return True if the strategy is actively managing a position.\n    function isActive() public view returns (bool) {\n        return estimatedTotalAssets() != 0;\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Prepares the Strategy to return, recognizing any profits or losses\n    /// @dev In the rare case the Strategy is in emergency shutdown, this will exit\n    /// the Strategy's position.\n    /// @dev  When `_report()` is called, the Strategy reports to the Manager (via\n    /// `poolManager.report()`), so in some cases `harvest()` must be called in order\n    /// to take in profits, to borrow newly available funds from the Manager, or\n    /// otherwise adjust its position. In other cases `harvest()` must be\n    /// called to report to the Manager on the Strategy's position, especially if\n    /// any losses have occurred.\n    /// @dev As keepers may directly profit from this function, there may be front-running problems with miners bots,\n    /// we may have to put an access control logic for this function to only allow white-listed addresses to act\n    /// as keepers for the protocol\n    function _report() internal {\n        uint256 profit;\n        uint256 loss;\n        uint256 debtOutstanding = poolManager.debtOutstanding();\n        uint256 debtPayment;\n        if (emergencyExit) {\n            // Free up as much capital as possible\n            uint256 amountFreed = _liquidateAllPositions();\n            if (amountFreed < debtOutstanding) {\n                loss = debtOutstanding - amountFreed;\n            } else if (amountFreed > debtOutstanding) {\n                profit = amountFreed - debtOutstanding;\n            }\n            debtPayment = debtOutstanding - loss;\n        } else {\n            // Free up returns for Manager to pull\n            (profit, loss, debtPayment) = _prepareReturn(debtOutstanding);\n        }\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\n\n        // Allows Manager to take up to the \"harvested\" balance of this contract,\n        // which is the amount it has earned since the last time it reported to\n        // the Manager.\n        poolManager.report(profit, loss, debtPayment);\n    }\n\n    /// @notice Performs any Strategy unwinding or other calls necessary to capture the\n    /// \"free return\" this Strategy has generated since the last time its core\n    /// position(s) were adjusted. Examples include unwrapping extra rewards.\n    /// This call is only used during \"normal operation\" of a Strategy, and\n    /// should be optimized to minimize losses as much as possible.\n    ///\n    /// This method returns any realized profits and/or realized losses\n    /// incurred, and should return the total amounts of profits/losses/debt\n    /// payments (in `want` tokens) for the Manager's accounting (e.g.\n    /// `want.balanceOf(this) >= _debtPayment + _profit`).\n    ///\n    /// `_debtOutstanding` will be 0 if the Strategy is not past the configured\n    /// debt limit, otherwise its value will be how far past the debt limit\n    /// the Strategy is. The Strategy's debt limit is configured in the Manager.\n    ///\n    /// NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\n    ///       It is okay for it to be less than `_debtOutstanding`, as that\n    ///       should only used as a guide for how much is left to pay back.\n    ///       Payments should be made to minimize loss from slippage, debt,\n    ///       withdrawal fees, etc.\n    ///\n    /// See `poolManager.debtOutstanding()`.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        );\n\n    /// @notice Performs any adjustments to the core position(s) of this Strategy given\n    /// what change the Manager made in the \"investable capital\" available to the\n    /// Strategy. Note that all \"free capital\" in the Strategy after the report\n    /// was made is available for reinvestment. Also note that this number\n    /// could be 0, and you should handle that scenario accordingly.\n    function _adjustPosition() internal virtual;\n\n    /// @notice same as _adjustPosition but with an initial parameter\n    function _adjustPosition(uint256) internal virtual;\n\n    /// @notice same as _adjustPosition but with permissionless parameters\n    function _adjustPosition(bytes memory) internal virtual {\n        _adjustPosition();\n    }\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other situation at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        virtual\n        returns (uint256 _liquidatedAmount, uint256 _loss);\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\n\n    /// @notice Override this to add all tokens/tokenized positions this contract\n    /// manages on a *persistent* basis (e.g. not just for swapping back to\n    /// want ephemerally).\n    ///\n    /// NOTE: Do *not* include `want`, already included in `sweep` below.\n    ///\n    /// Example:\n    /// ```\n    ///    function _protectedTokens() internal override view returns (address[] memory) {\n    ///      address[] memory protected = new address[](3);\n    ///      protected[0] = tokenA;\n    ///      protected[1] = tokenB;\n    ///      protected[2] = tokenC;\n    ///      return protected;\n    ///    }\n    /// ```\n    function _protectedTokens() internal view virtual returns (address[] memory);\n\n    // ================================= GOVERNANCE ================================\n\n    /// @notice Activates emergency exit. Once activated, the Strategy will exit its\n    /// position upon the next harvest, depositing all funds into the Manager as\n    /// quickly as is reasonable given on-chain conditions.\n    /// @dev This may only be called by the `PoolManager`, because when calling this the `PoolManager` should at the same\n    /// time update the debt ratio\n    /// @dev This function can only be called once by the `PoolManager` contract\n    /// @dev See `poolManager.setEmergencyExit()` and `harvest()` for further details.\n    function setEmergencyExit() external onlyRole(POOLMANAGER_ROLE) {\n        emergencyExit = true;\n        emit EmergencyExitActivated();\n    }\n\n    /// @notice Sets how far the Strategy can go into loss without a harvest and report\n    /// being required.\n    /// @param _debtThreshold How big of a loss this Strategy may carry without\n    /// @dev By default this is 0, meaning any losses would cause a harvest which\n    /// will subsequently report the loss to the Manager for tracking.\n    function setDebtThreshold(uint256 _debtThreshold) external onlyRole(GUARDIAN_ROLE) {\n        debtThreshold = _debtThreshold;\n        emit UpdatedDebtThreshold(_debtThreshold);\n    }\n\n    /// @notice Removes tokens from this Strategy that are not the type of tokens\n    /// managed by this Strategy. This may be used in case of accidentally\n    /// sending the wrong kind of token to this Strategy.\n    ///\n    /// Tokens will be sent to `governance()`.\n    ///\n    /// This will fail if an attempt is made to sweep `want`, or any tokens\n    /// that are protected by this Strategy.\n    ///\n    /// This may only be called by governance.\n    /// @param _token The token to transfer out of this `PoolManager`.\n    /// @param to Address to send the tokens to.\n    /// @dev\n    /// Implement `_protectedTokens()` to specify any additional tokens that\n    /// should be protected from sweeping in addition to `want`.\n    function sweep(address _token, address to) external onlyRole(GUARDIAN_ROLE) {\n        if (_token == address(want)) revert InvalidToken();\n\n        address[] memory __protectedTokens = _protectedTokens();\n        uint256 protectedTokensLength = __protectedTokens.length;\n        for (uint256 i; i < protectedTokensLength; ++i)\n            // In the strategy we use so far, the only protectedToken is the want token\n            // and this has been checked above\n            if (_token == __protectedTokens[i]) revert InvalidToken();\n\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\n    }\n\n    // ============================= MANAGER FUNCTIONS =============================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because Access Control is not defined\n    /// in PoolManagerInternal\n    function addGuardian(address _guardian) external virtual;\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external virtual;\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/aave/GenericAaveNoStaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./GenericAaveUpgradeable.sol\";\n\n/// @title GenericAaveNoStaker\n/// @author  Angle Core Team\n/// @notice Only deposit onto Aave lendingPool without staking\n/// @dev In this implementation, we just have to override the base functions with constant amounts as nothing is\n/// staked in an external contract\ncontract GenericAaveNoStaker is GenericAaveUpgradeable {\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Wrapper on top of the `initializeAave` method\n    function initialize(\n        address _strategy,\n        string memory name,\n        bool _isIncentivised,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_\n    ) external {\n        initializeAave(_strategy, name, _isIncentivised, governorList, guardian, keeperList, oneInch_);\n    }\n\n    // ============================= VIRTUAL FUNCTIONS =============================\n\n    function _stake(uint256) internal override returns (uint256) {}\n\n    function _unstake(uint256 amount) internal pure override returns (uint256) {\n        return amount;\n    }\n\n    /// @notice Gets current staked balance (e.g 0 if nothing is staked)\n    function _stakedBalance() internal pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Get stakingAPR after staking an additional `amount`: in this case, since nothing\n    /// is staked, it simply returns 0\n    function _stakingApr(int256) internal pure override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/aave/GenericAaveUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { DataTypes, IStakedAave, IReserveInterestRateStrategy } from \"../../../../interfaces/external/aave/IAave.sol\";\nimport { IProtocolDataProvider } from \"../../../../interfaces/external/aave/IProtocolDataProvider.sol\";\nimport { ILendingPool } from \"../../../../interfaces/external/aave/ILendingPool.sol\";\nimport { IAaveIncentivesController } from \"../../../../interfaces/external/aave/IAaveIncentivesController.sol\";\nimport { IAToken, IVariableDebtToken } from \"../../../../interfaces/external/aave/IAaveToken.sol\";\nimport \"./../GenericLenderBaseUpgradeable.sol\";\n\n/// @title GenericAave\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/master/contracts/GenericLender/GenericAave.sol\n/// @notice A contract to lend any supported ERC20 to Aave and potentially stake them in an external staking contract\n/// @dev This contract is just a base implementation which can be overriden depending on the staking contract on which to stake\n/// or not the aTokens\nabstract contract GenericAaveUpgradeable is GenericLenderBaseUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ================================= REFERENCES ================================\n\n    // solhint-disable-next-line\n    AggregatorV3Interface private constant oracle = AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n\n    // solhint-disable-next-line\n    address private constant _aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n    // solhint-disable-next-line\n    IStakedAave private constant _stkAave = IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n    // solhint-disable-next-line\n    IAaveIncentivesController private constant _incentivesController =\n        IAaveIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\n    // solhint-disable-next-line\n    ILendingPool internal constant _lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n    // solhint-disable-next-line\n    IProtocolDataProvider private constant _protocolDataProvider =\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\n\n    // ================================= CONSTANTS =================================\n\n    uint256 internal constant _SECONDS_IN_YEAR = 365 days;\n    uint256 public cooldownSeconds;\n    uint256 public unstakeWindow;\n    bool public cooldownStkAave;\n    bool public isIncentivised;\n    IAToken internal _aToken;\n\n    uint256[47] private __gapAaveLender;\n\n    // =================================== EVENT ===================================\n\n    event IncentivisedUpdated(bool _isIncentivised);\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Initializer of the `GenericAave`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param name Name of the lender\n    /// @param _isIncentivised Whether the corresponding token is incentivized on Aave or not\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param keeperList List of addresses with keeper privilege\n    function initializeAave(\n        address _strategy,\n        string memory name,\n        bool _isIncentivised,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_\n    ) public {\n        _initialize(_strategy, name, governorList, guardian, keeperList, oneInch_);\n\n        _setAavePoolVariables();\n        if (_isIncentivised && address(_aToken.getIncentivesController()) == address(0)) revert PoolNotIncentivized();\n        isIncentivised = _isIncentivised;\n        cooldownStkAave = true;\n        IERC20(address(want)).safeApprove(address(_lendingPool), type(uint256).max);\n        // Approve swap router spend\n        IERC20(address(_stkAave)).safeApprove(oneInch_, type(uint256).max);\n        IERC20(address(_aave)).safeApprove(oneInch_, type(uint256).max);\n    }\n\n    // ============================= EXTERNAL FUNCTIONS ============================\n\n    /// @inheritdoc IGenericLender\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        // Aave doesn't allow null deposits\n        if (balance == 0) return;\n        _deposit(balance);\n        // We don't stake balance but the whole aTokenBalance\n        // if some dust has been kept idle\n        _stake(_balanceAtoken());\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @inheritdoc IGenericLender\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        _unstake(amount);\n        _lendingPool.withdraw(address(want), amount, address(this));\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    /// @notice Claim earned stkAAVE\n    /// @dev stkAAVE require a \"cooldown\" period of 10 days before being claimed\n    function claimRewards() external onlyRole(KEEPER_ROLE) {\n        _claimRewards();\n    }\n\n    /// @notice Triggers the cooldown on Aave for this contract\n    function cooldown() external onlyRole(KEEPER_ROLE) {\n        _stkAave.cooldown();\n    }\n\n    /// @notice Retrieves lending pool variables like the `COOLDOWN_SECONDS` or the `UNSTAKE_WINDOW` on Aave\n    /// @dev No access control is needed here because values are fetched from Aave directly\n    /// @dev We expect the values concerned not to be modified often\n    function setAavePoolVariables() external {\n        _setAavePoolVariables();\n    }\n\n    // ================================== SETTERS ==================================\n\n    /// @notice Toggle isIncentivised state, to let know the lender if it should harvest aave rewards\n    function toggleIsIncentivised() external onlyRole(GUARDIAN_ROLE) {\n        isIncentivised = !isIncentivised;\n    }\n\n    /// @notice Toggle cooldownStkAave state, which allow or not to call the coolDown stkAave each time rewards are claimed\n    function toggleCooldownStkAave() external onlyRole(GUARDIAN_ROLE) {\n        cooldownStkAave = !cooldownStkAave;\n    }\n\n    // ========================== EXTERNAL VIEW FUNCTIONS ==========================\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function underlyingBalanceStored() public view override returns (uint256 balance) {\n        balance = _balanceAtoken() + _stakedBalance();\n    }\n\n    /// @inheritdoc IGenericLender\n    function aprAfterDeposit(int256 amount) external view override returns (uint256) {\n        // i need to calculate new supplyRate after Deposit (when deposit has not been done yet)\n        DataTypes.ReserveData memory reserveData = _lendingPool.getReserveData(address(want));\n\n        (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            ,\n            ,\n            ,\n            uint256 averageStableBorrowRate,\n            ,\n            ,\n\n        ) = _protocolDataProvider.getReserveData(address(want));\n\n        uint256 newLiquidity = availableLiquidity;\n        if (amount >= 0) newLiquidity += uint256(amount);\n        else newLiquidity -= uint256(-amount);\n\n        (, , , , uint256 reserveFactor, , , , , ) = _protocolDataProvider.getReserveConfigurationData(address(want));\n\n        (uint256 newLiquidityRate, , ) = IReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n            .calculateInterestRates(\n                address(want),\n                newLiquidity,\n                totalStableDebt,\n                totalVariableDebt,\n                averageStableBorrowRate,\n                reserveFactor\n            );\n        uint256 incentivesRate = _incentivesRate(newLiquidity + totalStableDebt + totalVariableDebt); // total supplied liquidity in Aave v2\n        uint256 stakingApr = _stakingApr(amount);\n\n        return newLiquidityRate / 1e9 + incentivesRate + stakingApr; // divided by 1e9 to go from Ray to Wad\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Internal version of the `claimRewards` function\n    function _claimRewards() internal returns (uint256 stkAaveBalance) {\n        stkAaveBalance = _balanceOfStkAave();\n        // If it's the claim period claim\n        if (stkAaveBalance != 0 && _checkCooldown() == 1) {\n            // redeem AAVE from _stkAave\n            _stkAave.claimRewards(address(this), type(uint256).max);\n            _stkAave.redeem(address(this), stkAaveBalance);\n        }\n\n        address[] memory claimOnTokens = new address[](1);\n        claimOnTokens[0] = address(_aToken);\n        // claim _stkAave from lending and borrowing, this will reset the cooldown\n        _incentivesController.claimRewards(claimOnTokens, type(uint256).max, address(this));\n\n        stkAaveBalance = _balanceOfStkAave();\n\n        // request start of cooldown period, if there's no cooldown in progress\n        if (cooldownStkAave && stkAaveBalance != 0 && _checkCooldown() == 0) {\n            _stkAave.cooldown();\n        }\n    }\n\n    /// @notice Returns the `StkAAVE` balance\n    function _balanceOfStkAave() internal view returns (uint256) {\n        return IERC20(address(_stkAave)).balanceOf(address(this));\n    }\n\n    /// @notice Returns the `aToken` balance\n    function _balanceAtoken() internal view returns (uint256) {\n        return _aToken.balanceOf(address(this));\n    }\n\n    /// @notice Estimate the amount of `want` we will get out by swapping it for AAVE\n    /// @param amount Amount of AAVE we want to exchange (in base 18)\n    /// @return amount Amount of `want` we are getting\n    /// @dev Uses Chainlink spot price. Return value will be in base of `want` (6 for USDC)\n    function _estimatedStkAaveToWant(uint256 amount) internal view returns (uint256) {\n        (, int256 aavePriceUSD, , , ) = oracle.latestRoundData(); // stkAavePriceUSD is in base 8\n        // `aavePriceUSD` is in base 8, so ultimately we need to divide by `1e(18+8)\n        return (uint256(aavePriceUSD) * amount * wantBase) / 1e26;\n    }\n\n    /// @notice See `apr`\n    function _apr() internal view override returns (uint256) {\n        (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            ,\n            ,\n            ,\n            ,\n            ,\n\n        ) = _protocolDataProvider.getReserveData(address(want));\n        uint256 incentivesRate = _incentivesRate(availableLiquidity + totalStableDebt + totalVariableDebt); // total supplied liquidity in Aave v2\n        uint256 stakingApr = _stakingApr(0);\n\n        return liquidityRate / 10**9 + incentivesRate + stakingApr;\n    }\n\n    /// @notice Calculates APR from Liquidity Mining Program\n    /// @param totalLiquidity Total liquidity available in the pool\n    function _incentivesRate(uint256 totalLiquidity) internal view returns (uint256) {\n        // Only returns != 0 if the incentives are in place at the moment.\n        // It will fail if `isIncentivised` is set to true but there are no incentives\n        if (isIncentivised && block.timestamp < _incentivesController.getDistributionEnd() && totalLiquidity != 0) {\n            uint256 _emissionsPerSecond;\n            (, _emissionsPerSecond, ) = _incentivesController.getAssetData(address(_aToken));\n            if (_emissionsPerSecond != 0) {\n                uint256 emissionsInWant = _estimatedStkAaveToWant(_emissionsPerSecond); // amount of emissions in want\n                uint256 incentivesRate = (emissionsInWant * _SECONDS_IN_YEAR * 1e18) / totalLiquidity; // APRs are in 1e18\n\n                return (incentivesRate * 9500) / 10000; // 95% of estimated APR to avoid overestimations\n            }\n        }\n        return 0;\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 stakedBalance = _stakedBalance();\n        uint256 balanceUnderlying = _balanceAtoken();\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = stakedBalance + balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        // Not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(_aToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                uint256 freedAmount = _unstake(toWithdraw);\n                _lendingPool.withdraw(address(want), freedAmount, address(this));\n            } else {\n                //take all we can\n                uint256 freedAmount = _unstake(liquidity);\n                _lendingPool.withdraw(address(want), freedAmount, address(this));\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice See `deposit`\n    function _deposit(uint256 amount) internal {\n        ILendingPool lp = _lendingPool;\n        // NOTE: Checks if allowance is enough and acts accordingly\n        // allowance might not be enough if\n        //     i) initial allowance has been used (should take years)\n        //     ii) _lendingPool contract address has changed (Aave updated the contract address)\n        if (want.allowance(address(this), address(lp)) < amount) {\n            IERC20(address(want)).safeApprove(address(lp), 0);\n            IERC20(address(want)).safeApprove(address(lp), type(uint256).max);\n        }\n        lp.deposit(address(want), amount, address(this), 0);\n    }\n\n    /// @notice Internal version of the `_setAavePoolVariables`\n    function _setAavePoolVariables() internal {\n        (address aToken, , ) = _protocolDataProvider.getReserveTokensAddresses(address(want));\n        _aToken = IAToken(aToken);\n        cooldownSeconds = IStakedAave(_stkAave).COOLDOWN_SECONDS();\n        unstakeWindow = IStakedAave(_stkAave).UNSTAKE_WINDOW();\n    }\n\n    /// @notice Verifies the cooldown status for earned stkAAVE\n    /// @return cooldownStatus Status of the coolDown: if it is 0 then there is no cooldown Status, if it is 1 then\n    /// the strategy should claim the stkAave\n    function _checkCooldown() internal view returns (uint256 cooldownStatus) {\n        uint256 cooldownStartTimestamp = IStakedAave(_stkAave).stakersCooldowns(address(this));\n        uint256 nextClaimStartTimestamp = cooldownStartTimestamp + cooldownSeconds;\n        if (cooldownStartTimestamp == 0) {\n            return 0;\n        }\n        if (block.timestamp > nextClaimStartTimestamp && block.timestamp <= nextClaimStartTimestamp + unstakeWindow) {\n            return 1;\n        }\n        if (block.timestamp < nextClaimStartTimestamp) {\n            return 2;\n        }\n    }\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(_aToken);\n        return protected;\n    }\n\n    // ============================= VIRTUAL FUNCTIONS =============================\n\n    /// @notice Allows the lender to stake its aTokens in an external staking contract\n    /// @param amount Amount of aTokens to stake\n    /// @return Amount of aTokens actually staked\n    function _stake(uint256 amount) internal virtual returns (uint256);\n\n    /// @notice Allows the lender to unstake its aTokens from an external staking contract\n    /// @param amount Amount of aToken to unstake\n    /// @return Amount of aTokens actually unstaked\n    function _unstake(uint256 amount) internal virtual returns (uint256);\n\n    /// @notice Gets the amount of aTokens currently staked\n    function _stakedBalance() internal view virtual returns (uint256);\n\n    /// @notice Gets the APR from staking additional `amount` of aTokens in the associated staking\n    /// contract\n    /// @param amount Virtual amount to be staked\n    function _stakingApr(int256 amount) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/compound/GenericCompoundUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../../interfaces/external/compound/CErc20I.sol\";\nimport \"../../../../interfaces/external/compound/IComptroller.sol\";\nimport \"../../../../interfaces/external/compound/InterestRateModel.sol\";\n\nimport \"./../GenericLenderBaseUpgradeable.sol\";\n\n/// @title GenericCompoundV3\n/// @author Forked from here: https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/master/contracts/GenericLender/GenericCompound.sol\ncontract GenericCompoundUpgradeable is GenericLenderBaseUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    uint256 public constant BLOCKS_PER_YEAR = 2_350_000;\n\n    // solhint-disable-next-line\n    AggregatorV3Interface public constant oracle = AggregatorV3Interface(0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5);\n    // solhint-disable-next-line\n    IComptroller public constant comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n    // solhint-disable-next-line\n    address public constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n    // ================================= REFERENCES ================================\n\n    CErc20I public cToken;\n    // solhint-disable-next-line\n    uint256 private dust;\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializer of the `GenericCompound`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _cToken Address of the cToken\n    /// @param governorList List of addresses with governor privilege\n    /// @param keeperList List of addresses with keeper privilege\n    /// @param guardian Address of the guardian\n    function initialize(\n        address _strategy,\n        string memory _name,\n        address _cToken,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_\n    ) external {\n        _initialize(_strategy, _name, governorList, guardian, keeperList, oneInch_);\n\n        cToken = CErc20I(_cToken);\n        if (CErc20I(_cToken).underlying() != address(want)) revert WrongCToken();\n\n        want.safeApprove(_cToken, type(uint256).max);\n        IERC20(comp).safeApprove(oneInch_, type(uint256).max);\n    }\n\n    // ======================== EXTERNAL STRATEGY FUNCTIONS ========================\n\n    /// @inheritdoc IGenericLender\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        if (cToken.mint(balance) != 0) revert FailedToMint();\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ========================== EXTERNAL VIEW FUNCTIONS ==========================\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function underlyingBalanceStored() public view override returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            //The current exchange rate as an unsigned integer, scaled by 1e18.\n            balance = (currentCr * cToken.exchangeRateStored()) / 1e18;\n        }\n    }\n\n    /// @inheritdoc IGenericLender\n    function aprAfterDeposit(int256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        uint256 newCashPrior = cashPrior;\n        uint256 totalSupplyInWant = (cToken.totalSupply() * cToken.exchangeRateStored()) / 1e18;\n        if (amount >= 0) {\n            newCashPrior += uint256(amount);\n            totalSupplyInWant += uint256(amount);\n        } else {\n            newCashPrior -= uint256(-amount);\n            totalSupplyInWant -= uint256(-amount);\n        }\n        // The supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(newCashPrior, borrows, reserves, reserverFactor);\n        // Adding the yield from comp\n        return supplyRate * BLOCKS_PER_YEAR + _incentivesRate(totalSupplyInWant);\n    }\n\n    // ================================= GOVERNANCE ================================\n\n    /// @inheritdoc IGenericLender\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        // Do not care about errors here, what is important is to withdraw what is possible\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    /// @notice Allow to modify the dust amount\n    /// @param dust_ Amount under which the contract does not try to redeem from Compound\n    /// @dev Set in a function because contract was already initialized\n    function setDust(uint256 dust_) external onlyRole(GUARDIAN_ROLE) {\n        dust = dust_;\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice See `apr`\n    function _apr() internal view override returns (uint256) {\n        uint256 totalSupplyInWant = (cToken.totalSupply() * cToken.exchangeRateStored()) / 1e18;\n        return cToken.supplyRatePerBlock() * BLOCKS_PER_YEAR + _incentivesRate(totalSupplyInWant);\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            // Can't withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        // Not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n            // If amount is too low then do not try to withdraw it\n            // Risk being: the tx can revert because the cToken needed to be sent == 0\n            if (toWithdraw >= dust) {\n                if (toWithdraw <= liquidity) {\n                    // We can take all\n                    if (cToken.redeemUnderlying(toWithdraw) != 0) revert FailedToRedeem();\n                } else {\n                    // Take all we can\n                    if (cToken.redeemUnderlying(liquidity) != 0) revert FailedToRedeem();\n                }\n            }\n        }\n        address[] memory holders = new address[](1);\n        CTokenI[] memory cTokens = new CTokenI[](1);\n        holders[0] = address(this);\n        cTokens[0] = cToken;\n        comptroller.claimComp(holders, cTokens, true, true);\n\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice Calculates APR from Compound's Liquidity Mining Program\n    /// @param totalSupplyInWant Total supply in want for this market (for the `aprAfterDeposit` function)\n    function _incentivesRate(uint256 totalSupplyInWant) internal view returns (uint256) {\n        uint256 supplySpeed = comptroller.compSupplySpeeds(address(cToken));\n        // `supplySpeed` is in `COMP` unit -> the following operation is going to put it in `want` unit\n        supplySpeed = _comptoWant(supplySpeed);\n        uint256 incentivesRate;\n        // Added for testing purposes and to handle the edge case where there is nothing left in a market\n        if (totalSupplyInWant == 0) {\n            incentivesRate = supplySpeed * BLOCKS_PER_YEAR;\n        } else {\n            // `incentivesRate` is expressed in base 18 like all APR\n            incentivesRate = (supplySpeed * BLOCKS_PER_YEAR * 1e18) / totalSupplyInWant;\n        }\n        return (incentivesRate * 9500) / 10000; // 95% of estimated APR to avoid overestimations\n    }\n\n    /// @notice Estimates the value of `_amount` COMP tokens\n    /// @param _amount Amount of comp to compute the `want` price of\n    /// @dev This function uses a ChainLink oracle to easily compute the price\n    function _comptoWant(uint256 _amount) internal view returns (uint256) {\n        if (_amount == 0) {\n            return 0;\n        }\n        (uint80 roundId, int256 ratio, , , uint80 answeredInRound) = oracle.latestRoundData();\n        if (ratio == 0 || roundId > answeredInRound) revert InvalidOracleValue();\n        uint256 castedRatio = uint256(ratio);\n\n        // Checking whether we should multiply or divide by the ratio computed\n        return (_amount * castedRatio * wantBase) / 1e26;\n    }\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        return protected;\n    }\n\n    /// @notice Recovers ETH from the contract\n    /// @param amount Amount to be recovered\n    function recoverETH(address to, uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        if (!payable(to).send(amount)) revert FailedToRecoverETH();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/euler/GenericEuler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { IEuler, IEulerMarkets, IEulerEToken, IEulerDToken, IBaseIRM } from \"../../../../interfaces/external/euler/IEuler.sol\";\nimport \"../../../../external/ComputePower.sol\";\nimport \"./../GenericLenderBaseUpgradeable.sol\";\n\n/// @title GenericEuler\n/// @author Angle Core Team\n/// @notice Simple supplier to Euler markets\ncontract GenericEuler is GenericLenderBaseUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @notice Base used for interest rate / power computation\n    // solhint-disable-next-line\n    uint256 private constant BASE_INTEREST = 10**27;\n\n    /// @notice Euler address holding assets\n    // solhint-disable-next-line\n    IEuler private constant _euler = IEuler(0x27182842E098f60e3D576794A5bFFb0777E025d3);\n    /// @notice Euler address with data on all eTokens, debt tokens and interest rates\n    // solhint-disable-next-line\n    IEulerMarkets private constant _eulerMarkets = IEulerMarkets(0x3520d5a913427E6F0D6A83E07ccD4A4da316e4d3);\n    // solhint-disable-next-line\n    uint256 internal constant _SECONDS_IN_YEAR = 365 days;\n    // solhint-disable-next-line\n    uint256 private constant RESERVE_FEE_SCALE = 4_000_000_000;\n\n    // ========================== REFERENCES TO CONTRACTS ==========================\n\n    /// @notice Euler interest rate model for the desired token\n    // solhint-disable-next-line\n    IBaseIRM private irm;\n    /// @notice Euler debt token\n    // solhint-disable-next-line\n    IEulerDToken private dToken;\n    /// @notice Token given to lenders on Euler\n    IEulerEToken public eToken;\n    /// @notice Reserve fee on the token on Euler\n    uint32 public reserveFee;\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Initializer of the `GenericEuler`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param governorList List of addresses with governor privilege\n    /// @param keeperList List of addresses with keeper privilege\n    /// @param guardian Address of the guardian\n    function initializeEuler(\n        address _strategy,\n        string memory _name,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_\n    ) public {\n        _initialize(_strategy, _name, governorList, guardian, keeperList, oneInch_);\n\n        eToken = IEulerEToken(_eulerMarkets.underlyingToEToken(address(want)));\n        dToken = IEulerDToken(_eulerMarkets.underlyingToDToken(address(want)));\n\n        _setEulerPoolVariables();\n\n        want.safeApprove(address(_euler), type(uint256).max);\n    }\n\n    // ===================== EXTERNAL PERMISSIONLESS FUNCTIONS =====================\n\n    /// @notice Retrieves Euler variables `reserveFee` and the `irm` - rates curve -  used for the underlying token\n    /// @dev No access control is needed here because values are fetched from Euler directly\n    /// @dev We expect the values concerned not to be modified often\n    function setEulerPoolVariables() external {\n        _setEulerPoolVariables();\n    }\n\n    // ======================== EXTERNAL STRATEGY FUNCTIONS ========================\n\n    /// @inheritdoc IGenericLender\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        eToken.deposit(0, balance);\n        // We don't stake balance but the whole eToken balance\n        // if some dust has been kept idle\n        _stakeAll();\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @inheritdoc IGenericLender\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ========================== EXTERNAL VIEW FUNCTIONS ==========================\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function underlyingBalanceStored() public view override returns (uint256) {\n        uint256 stakeAmount = _stakedBalance();\n        return eToken.balanceOfUnderlying(address(this)) + stakeAmount;\n    }\n\n    /// @inheritdoc IGenericLender\n    function aprAfterDeposit(int256 amount) external view override returns (uint256) {\n        return _aprAfterDeposit(amount);\n    }\n\n    // ================================= GOVERNANCE ================================\n\n    /// @inheritdoc IGenericLender\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        _unstake(amount);\n        eToken.withdraw(0, amount);\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function _apr() internal view override returns (uint256) {\n        return _aprAfterDeposit(0);\n    }\n\n    /// @notice Internal version of the `aprAfterDeposit` function\n    function _aprAfterDeposit(int256 amount) internal view returns (uint256) {\n        uint256 totalBorrows = dToken.totalSupply();\n        // Total supply is current supply + added liquidity\n\n        uint256 totalSupply = eToken.totalSupplyUnderlying();\n        if (amount >= 0) totalSupply += uint256(amount);\n        else totalSupply -= uint256(-amount);\n\n        uint256 supplyAPY;\n        if (totalSupply != 0) {\n            uint32 futureUtilisationRate = uint32(\n                (totalBorrows * (uint256(type(uint32).max) * 1e18)) / totalSupply / 1e18\n            );\n            uint256 interestRate = uint256(uint96(irm.computeInterestRate(address(want), futureUtilisationRate)));\n            supplyAPY = _computeAPYs(interestRate, totalBorrows, totalSupply, reserveFee);\n        }\n\n        // Adding the yield from EUL\n        return supplyAPY + _stakingApr(amount);\n    }\n\n    /// @notice Computes APYs based on the interest rate, reserve fee, borrow\n    /// @param borrowSPY Interest rate paid per second by borrowers\n    /// @param totalBorrows Total amount borrowed on Euler of the underlying token\n    /// @param totalSupplyUnderlying Total amount supplied on Euler of the underlying token\n    /// @param _reserveFee Reserve fee set by governance for the underlying token\n    /// @return supplyAPY The annual percentage yield received as a supplier with current settings\n    function _computeAPYs(\n        uint256 borrowSPY,\n        uint256 totalBorrows,\n        uint256 totalSupplyUnderlying,\n        uint32 _reserveFee\n    ) internal pure returns (uint256 supplyAPY) {\n        // Not useful for the moment\n        // uint256 borrowAPY = (ComputePower.computePower(borrowSPY, _SECONDS_IN_YEAR) - ComputePower.BASE_INTEREST) / 1e9;\n        uint256 supplySPY = (borrowSPY * totalBorrows) / totalSupplyUnderlying;\n        supplySPY = (supplySPY * (RESERVE_FEE_SCALE - _reserveFee)) / RESERVE_FEE_SCALE;\n        // All rates are in base 18 on Angle strategies\n        supplyAPY = (ComputePower.computePower(supplySPY, _SECONDS_IN_YEAR, BASE_INTEREST) - BASE_INTEREST) / 1e9;\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 stakedBalance = _stakedBalance();\n        uint256 balanceUnderlying = eToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = stakedBalance + balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            // Can't withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        // Not state changing but still cheap because of previous call\n        uint256 availableLiquidity = want.balanceOf(address(_euler));\n\n        if (availableLiquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n            uint256 toUnstake;\n            // We can take all\n            if (toWithdraw <= availableLiquidity)\n                toUnstake = toWithdraw > (balanceUnderlying + looseBalance)\n                    ? toWithdraw - (balanceUnderlying + looseBalance)\n                    : 0;\n            else {\n                // Take all we can\n                toUnstake = availableLiquidity > balanceUnderlying ? availableLiquidity - balanceUnderlying : 0;\n                toWithdraw = availableLiquidity;\n            }\n            if (toUnstake != 0) _unstake(toUnstake);\n            eToken.withdraw(0, toWithdraw);\n        }\n\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice Internal version of the `setEulerPoolVariables`\n    function _setEulerPoolVariables() internal {\n        uint256 interestRateModel = _eulerMarkets.interestRateModel(address(want));\n        address moduleImpl = _euler.moduleIdToImplementation(interestRateModel);\n        irm = IBaseIRM(moduleImpl);\n        reserveFee = _eulerMarkets.reserveFee(address(want));\n    }\n\n    /// @inheritdoc GenericLenderBaseUpgradeable\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(eToken);\n        return protected;\n    }\n\n    // ============================= VIRTUAL FUNCTIONS =============================\n\n    /// @notice Allows the lender to stake its eTokens in an external staking contract\n    function _stakeAll() internal virtual {}\n\n    /// @notice Allows the lender to unstake its eTokens from an external staking contract\n    /// @return Amount of eTokens actually unstaked\n    function _unstake(uint256) internal virtual returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Gets the value of the eTokens currently staked\n    function _stakedBalance() internal view virtual returns (uint256) {\n        return (0);\n    }\n\n    /// @notice Calculates APR from Liquidity Mining Program\n    /// @dev amountToAdd Amount to add to the currently supplied liquidity (for the `aprAfterDeposit` function)\n    function _stakingApr(int256) internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/euler/GenericEulerStaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { IEulerExec } from \"../../../../interfaces/external/euler/IEuler.sol\";\nimport \"../../../../interfaces/external/euler/IEulerStakingRewards.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./GenericEuler.sol\";\n\n/// @title GenericEulerStaker\n/// @author  Angle Core Team\n/// @notice `GenericEuler` with staking to earn EUL incentives\ncontract GenericEulerStaker is GenericEuler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ================================= CONSTANTS =================================\n    uint32 internal constant _TWAP_PERIOD = 1 minutes;\n    IEulerExec private constant _EXEC = IEulerExec(0x59828FdF7ee634AaaD3f58B19fDBa3b03E2D9d80);\n    IERC20 private constant _EUL = IERC20(0xd9Fcd98c322942075A5C3860693e9f4f03AAE07b);\n\n    // ================================= VARIABLES =================================\n    IEulerStakingRewards public eulerStakingContract;\n    AggregatorV3Interface public chainlinkOracle;\n    uint8 public isUniMultiplied;\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Wrapper built on top of the `initializeEuler` method to initialize the contract\n    function initialize(\n        address _strategy,\n        string memory _name,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_,\n        IEulerStakingRewards _eulerStakingContract,\n        AggregatorV3Interface _chainlinkOracle\n    ) external {\n        initializeEuler(_strategy, _name, governorList, guardian, keeperList, oneInch_);\n        eulerStakingContract = _eulerStakingContract;\n        chainlinkOracle = _chainlinkOracle;\n        IERC20(address(eToken)).safeApprove(address(_eulerStakingContract), type(uint256).max);\n        IERC20(_EUL).safeApprove(oneInch_, type(uint256).max);\n    }\n\n    // ============================= EXTERNAL FUNCTION =============================\n\n    /// @notice Claim earned EUL\n    function claimRewards() external {\n        eulerStakingContract.getReward();\n    }\n\n    // ============================= VIRTUAL FUNCTIONS =============================\n\n    /// @inheritdoc GenericEuler\n    function _stakeAll() internal override {\n        eulerStakingContract.stake(eToken.balanceOf(address(this)));\n    }\n\n    /// @inheritdoc GenericEuler\n    function _unstake(uint256 amount) internal override returns (uint256 eTokensUnstaked) {\n        // Take an upper bound as when withdrawing from Euler there could be rounding issue\n        eTokensUnstaked = eToken.convertUnderlyingToBalance(amount) + 1;\n        eulerStakingContract.withdraw(eTokensUnstaked);\n    }\n\n    /// @inheritdoc GenericEuler\n    function _stakedBalance() internal view override returns (uint256 amount) {\n        uint256 amountInEToken = eulerStakingContract.balanceOf(address(this));\n        amount = eToken.convertBalanceToUnderlying(amountInEToken);\n    }\n\n    /// @inheritdoc GenericEuler\n    function _stakingApr(int256 amount) internal view override returns (uint256 apr) {\n        uint256 periodFinish = eulerStakingContract.periodFinish();\n        uint256 newTotalSupply = eToken.convertBalanceToUnderlying(eulerStakingContract.totalSupply());\n        if (amount >= 0) newTotalSupply += uint256(amount);\n        else newTotalSupply -= uint256(-amount);\n        if (periodFinish <= block.timestamp || newTotalSupply == 0) return 0;\n        // APRs are in 1e18 and a 5% penalty on the EUL price is taken to avoid overestimations\n        // `_estimatedEulToWant()` and eTokens are in base 18\n        apr =\n            (_estimatedEulToWant(eulerStakingContract.rewardRate() * _SECONDS_IN_YEAR) * 9_500 * 10**6) /\n            10_000 /\n            newTotalSupply;\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Estimates the amount of `want` we will get out by swapping it for EUL\n    /// @param quoteAmount The amount to convert in the out-currency\n    /// @return The value of the `quoteAmount` expressed in out-currency\n    /// @dev Uses Euler TWAP and Chainlink spot price\n    function _estimatedEulToWant(uint256 quoteAmount) internal view returns (uint256) {\n        (uint256 twapEUL, ) = _EXEC.getPrice(address(_EUL));\n        return _quoteOracleEUL((quoteAmount * twapEUL) / 10**18);\n    }\n\n    // ============================= VIRTUAL FUNCTIONS =============================\n\n    /// @notice Return quote amount of the EUL amount\n    function _quoteOracleEUL(uint256 amount) internal view virtual returns (uint256 quoteAmount) {\n        // No stale checks are made as it is only used to estimate the staking APR\n        (, int256 ethPriceUSD, , , ) = chainlinkOracle.latestRoundData();\n        // ethPriceUSD is in base 8\n        return (uint256(ethPriceUSD) * amount) / 1e8;\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/GenericLenderBaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../../external/AccessControlAngleUpgradeable.sol\";\n\nimport \"../../../interfaces/IGenericLender.sol\";\nimport \"../../../interfaces/IPoolManager.sol\";\nimport \"../../../interfaces/IStrategy.sol\";\n\nimport \"../../../utils/Errors.sol\";\n\n/// @title GenericLenderBaseUpgradeable\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat/tree/master/contracts/GenericLender\n/// @notice A base contract to build contracts that lend assets to protocols\nabstract contract GenericLenderBaseUpgradeable is IGenericLender, AccessControlAngleUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GUARDIAN_ROLE = 0x55435dd261a4b9b3364963f7738a7a662ad9c84396d64be3365284bb7f0a5041;\n    bytes32 public constant STRATEGY_ROLE = 0x928286c473ded01ff8bf61a1986f14a0579066072fa8261442d9fea514d93a4c;\n    bytes32 public constant KEEPER_ROLE = 0xfc8737ab85eb45125971625a9ebdb75cc78e01d5c1fa80c4c6e5203f47bc4fab;\n\n    // ========================= REFERENCES AND PARAMETERS =========================\n\n    /// @inheritdoc IGenericLender\n    string public override lenderName;\n    /// @notice Reference to the protocol's collateral poolManager\n    IPoolManager public poolManager;\n    /// @inheritdoc IGenericLender\n    address public override strategy;\n    /// @notice Reference to the token lent\n    IERC20 public want;\n    /// @notice Base of the asset handled by the lender\n    uint256 public wantBase;\n    /// @notice 1inch Aggregation router\n    address internal _oneInch;\n\n    uint256[44] private __gapBaseLender;\n\n    // ================================ INITIALIZER ================================\n\n    /// @notice Initializer of the `GenericLenderBase`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _name Name of the lender\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param keeperList List of keeper addresses\n    function _initialize(\n        address _strategy,\n        string memory _name,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        address oneInch_\n    ) internal initializer {\n        _oneInch = oneInch_;\n        strategy = _strategy;\n        // The corresponding `PoolManager` is inferred from the `Strategy`\n        poolManager = IPoolManager(IStrategy(strategy).poolManager());\n        want = IERC20(poolManager.token());\n        lenderName = _name;\n\n        _setupRole(GUARDIAN_ROLE, address(poolManager));\n        uint256 governorListLength = governorList.length;\n        for (uint256 i; i < governorListLength; ++i) {\n            _setupRole(GUARDIAN_ROLE, governorList[i]);\n        }\n\n        _setupRole(KEEPER_ROLE, guardian);\n        uint256 keeperListLength = keeperList.length;\n        for (uint256 i; i < keeperListLength; ++i) {\n            _setupRole(KEEPER_ROLE, keeperList[i]);\n        }\n\n        _setRoleAdmin(KEEPER_ROLE, GUARDIAN_ROLE);\n\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(STRATEGY_ROLE, _strategy);\n        _setRoleAdmin(GUARDIAN_ROLE, STRATEGY_ROLE);\n        _setRoleAdmin(STRATEGY_ROLE, GUARDIAN_ROLE);\n        wantBase = 10**IERC20Metadata(address(want)).decimals();\n        want.safeApprove(_strategy, type(uint256).max);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @inheritdoc IGenericLender\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    /// @inheritdoc IGenericLender\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a * _nav();\n    }\n\n    /// @inheritdoc IGenericLender\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    /// @inheritdoc IGenericLender\n    function hasAssets() external view virtual override returns (bool) {\n        return _nav() > 10 * wantBase;\n    }\n\n    /// @notice See `nav`\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)) + underlyingBalanceStored();\n    }\n\n    /// @notice See `apr`\n    function _apr() internal view virtual returns (uint256);\n\n    /// @notice Returns the current balance invested in the lender and related staking contracts\n    function underlyingBalanceStored() public view virtual returns (uint256 balance);\n\n    // ================================= GOVERNANCE ================================\n\n    /// @notice Override this to add all tokens/tokenized positions this contract\n    /// manages on a *persistent* basis (e.g. not just for swapping back to\n    /// want ephemerally).\n    ///\n    /// Example:\n    /// ```\n    ///    function _protectedTokens() internal override view returns (address[] memory) {\n    ///      address[] memory protected = new address[](3);\n    ///      protected[0] = tokenA;\n    ///      protected[1] = tokenB;\n    ///      protected[2] = tokenC;\n    ///      return protected;\n    ///    }\n    /// ```\n    function _protectedTokens() internal view virtual returns (address[] memory);\n\n    /// @inheritdoc IGenericLender\n    function sweep(address _token, address to) external override onlyRole(GUARDIAN_ROLE) {\n        address[] memory __protectedTokens = _protectedTokens();\n        uint256 protectedTokensLength = __protectedTokens.length;\n        for (uint256 i; i < protectedTokensLength; ++i) if (_token == __protectedTokens[i]) revert ProtectedToken();\n\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\n    }\n\n    /// @notice Changes allowance of a set of tokens to addresses\n    /// @param tokens Addresses of the tokens for which approvals should be made\n    /// @param spenders Addresses to approve\n    /// @param amounts Approval amounts for each address\n    function changeAllowance(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external onlyRole(GUARDIAN_ROLE) {\n        if (tokens.length != spenders.length || tokens.length != amounts.length) revert IncompatibleLengths();\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i < tokensLength; ++i) {\n            _changeAllowance(tokens[i], spenders[i], amounts[i]);\n        }\n    }\n\n    /// @notice Changes oneInch contract address\n    /// @param oneInch_ Addresses of the new 1inch api endpoint contract\n    function set1Inch(address oneInch_) external onlyRole(GUARDIAN_ROLE) {\n        _oneInch = oneInch_;\n    }\n\n    /// @notice Swap earned _stkAave or Aave for `want` through 1Inch\n    /// @param minAmountOut Minimum amount of `want` to receive for the swap to happen\n    /// @param payload Bytes needed for 1Inch API\n    /// @dev In the case of a contract lending to Aave, tokens swapped should typically be: _stkAave -> `want` or Aave -> `want`\n    function sellRewards(uint256 minAmountOut, bytes memory payload) external onlyRole(KEEPER_ROLE) {\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = _oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        uint256 amountOut = abi.decode(result, (uint256));\n        if (amountOut < minAmountOut) revert TooSmallAmount();\n    }\n\n    /// @notice Internal function used for error handling\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length != 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert ErrorSwap();\n    }\n\n    /// @notice Changes allowance of a set of tokens to addresses\n    /// @param token Address of the token for which approval should be made\n    /// @param spender Address to approve\n    /// @param amount Approval amount\n    function _changeAllowance(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 currentAllowance = token.allowance(address(this), address(spender));\n        if (currentAllowance < amount) {\n            token.safeIncreaseAllowance(address(spender), amount - currentAllowance);\n        } else if (currentAllowance > amount) {\n            token.safeDecreaseAllowance(address(spender), currentAllowance - amount);\n        }\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/OptimizerAPRGreedyStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../BaseStrategyUpgradeable.sol\";\n\nimport \"../../interfaces/IGenericLender.sol\";\n\n/// @title OptimizerAPRGreedyStrategy\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat\n/// @notice A lender optimisation strategy for any ERC20 asset\n/// @dev This strategy works by taking plugins designed for standard lending platforms\n/// It automatically chooses the best yield generating platform and adjusts accordingly\n/// The adjustment is sub optimal so there is an additional option to manually set position\ncontract OptimizerAPRGreedyStrategy is BaseStrategyUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ================================= REFERENCES ================================\n\n    IGenericLender[] public lenders;\n\n    // ================================= PARAMETERS ================================\n\n    uint256 public withdrawalThreshold;\n\n    // =================================== EVENTS ==================================\n\n    event AddLender(address indexed lender);\n    event RemoveLender(address indexed lender);\n\n    // ================================ CONSTRUCTOR ================================\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param governor Address with governor privilege\n    /// @param guardian Address of the guardian\n    function initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers\n    ) external {\n        _initialize(_poolManager, governor, guardian, keepers);\n        withdrawalThreshold = 1000 * wantBase;\n    }\n\n    // ============================= INTERNAL MECHANICS ============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = 0; //default assignments for clarity\n        _loss = 0;\n        _debtPayment = _debtOutstanding;\n\n        uint256 lentAssets = lentTotalAssets();\n\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        uint256 total = looseAssets + lentAssets;\n\n        if (lentAssets == 0) {\n            // No position to harvest or profit to report\n            if (_debtPayment > looseAssets) {\n                // We can only return looseAssets\n                _debtPayment = looseAssets;\n            }\n\n            return (_profit, _loss, _debtPayment);\n        }\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (total > debt) {\n            _profit = total - debt;\n\n            uint256 amountToFree = _profit + _debtPayment;\n            // We need to add outstanding to our profit\n            // don't need to do logic if there is nothing to free\n            if (amountToFree != 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust _debtOutstanding and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_profit > newLoose) {\n                        _profit = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _profit, _debtPayment);\n                    }\n                }\n            }\n        } else {\n            // Serious loss should never happen but if it does lets record it accurately\n            _loss = debt - total;\n\n            uint256 amountToFree = _loss + _debtPayment;\n            if (amountToFree != 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust `_debtOutstanding` and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_loss > newLoose) {\n                        _loss = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _loss, _debtPayment);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Estimates highest and lowest apr lenders among a `lendersList`\n    /// @param lendersList List of all the lender contracts associated to this strategy\n    /// @return _lowest The index of the lender in the `lendersList` with lowest apr\n    /// @return _lowestApr The lowest apr\n    /// @return _highest The index of the lender with highest apr\n    /// @return _potential The potential apr of this lender if funds are moved from lowest to highest\n    /// @dev `lendersList` is kept as a parameter to avoid multiplying reads in storage to the `lenders`\n    /// array\n    function _estimateAdjustPosition(IGenericLender[] memory lendersList)\n        internal\n        view\n        returns (\n            uint256 _lowest,\n            uint256 _lowestApr,\n            uint256 _highest,\n            uint256 _potential\n        )\n    {\n        // All loose assets are to be invested\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        // Simple algo:\n        //  - Get the lowest apr strat\n        //  - Cycle through and see who could take its funds plus want for the highest apr\n        _lowestApr = type(uint256).max;\n        _lowest = 0;\n        uint256 lowestNav = 0;\n        uint256 highestApr = 0;\n        _highest = 0;\n        uint256 length = lendersList.length;\n        for (uint256 i = 0; i < length; i++) {\n            uint256 aprAfterDeposit = lendersList[i].aprAfterDeposit(int256(looseAssets));\n            if (aprAfterDeposit > highestApr) {\n                highestApr = aprAfterDeposit;\n                _highest = i;\n            }\n\n            if (lendersList[i].hasAssets()) {\n                uint256 apr = lendersList[i].apr();\n                if (apr < _lowestApr) {\n                    _lowestApr = apr;\n                    _lowest = i;\n                    lowestNav = lendersList[i].nav();\n                }\n            }\n        }\n\n        //if we can improve apr by withdrawing we do so\n        _potential = lendersList[_highest].aprAfterDeposit(int256(lowestNav + looseAssets));\n    }\n\n    /// @notice Function called by keepers to adjust the position\n    /// @dev The algorithm moves assets from lowest return to highest\n    /// like a very slow idiot bubble sort\n    function _adjustPosition() internal override {\n        // Emergency exit is dealt with at beginning of harvest\n        if (emergencyExit) {\n            return;\n        }\n        // Storing the `lenders` array in a cache variable\n        IGenericLender[] memory lendersList = lenders;\n        // We just keep all money in want if we dont have any lenders\n        if (lendersList.length == 0) {\n            return;\n        }\n\n        (uint256 lowest, uint256 lowestApr, uint256 highest, uint256 potential) = _estimateAdjustPosition(lendersList);\n\n        if (potential > lowestApr) {\n            // Apr should go down after deposit so won't be withdrawing from self\n            lendersList[lowest].withdrawAll();\n        }\n\n        uint256 bal = want.balanceOf(address(this));\n        if (bal > 0) {\n            want.safeTransfer(address(lendersList[highest]), bal);\n            lendersList[highest].deposit();\n        }\n    }\n\n    /// @notice Function needed to inherit the baseStrategyUpgradeable\n    function _adjustPosition(uint256) internal override {\n        _adjustPosition();\n    }\n\n    /// @notice Withdraws a given amount from lenders\n    /// @param _amount The amount to withdraw\n    /// @dev Cycle through withdrawing from worst rate first\n    function _withdrawSome(uint256 _amount) internal returns (uint256 amountWithdrawn) {\n        IGenericLender[] memory lendersList = lenders;\n        if (lendersList.length == 0) {\n            return 0;\n        }\n\n        // Don't withdraw dust\n        if (_amount < withdrawalThreshold) {\n            return 0;\n        }\n\n        amountWithdrawn = 0;\n        // In most situations this will only run once. Only big withdrawals will be a gas guzzler\n        uint256 j = 0;\n        while (amountWithdrawn < _amount - withdrawalThreshold) {\n            uint256 lowestApr = type(uint256).max;\n            uint256 lowest = 0;\n            for (uint256 i = 0; i < lendersList.length; i++) {\n                if (lendersList[i].hasAssets()) {\n                    uint256 apr = lendersList[i].apr();\n                    if (apr < lowestApr) {\n                        lowestApr = apr;\n                        lowest = i;\n                    }\n                }\n            }\n            if (!lendersList[lowest].hasAssets()) {\n                return amountWithdrawn;\n            }\n            uint256 amountWithdrawnFromStrat = lendersList[lowest].withdraw(_amount - amountWithdrawn);\n            // To avoid staying on the same strat if we can't withdraw anythin from it\n            amountWithdrawn = amountWithdrawn + amountWithdrawnFromStrat;\n            j++;\n            // not best solution because it would be better to move to the 2nd lowestAPR instead of quiting\n            if (amountWithdrawnFromStrat == 0) {\n                return amountWithdrawn;\n            }\n            // To avoid want infinite loop\n            if (j >= 6) {\n                return amountWithdrawn;\n            }\n        }\n    }\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other sitution at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _amountFreed, uint256 _loss) {\n        uint256 _balance = want.balanceOf(address(this));\n\n        if (_balance >= _amountNeeded) {\n            //if we don't set reserve here withdrawer will be sent our full balance\n            return (_amountNeeded, 0);\n        } else {\n            uint256 received = _withdrawSome(_amountNeeded - _balance) + (_balance);\n            if (received >= _amountNeeded) {\n                return (_amountNeeded, 0);\n            } else {\n                return (received, 0);\n            }\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        (_amountFreed, ) = _liquidatePosition(estimatedTotalAssets());\n    }\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @notice View function to check the current state of the strategy\n    /// @return Returns the status of all lenders attached the strategy\n    function lendStatuses() external view returns (LendStatus[] memory) {\n        uint256 lendersListLength = lenders.length;\n        LendStatus[] memory statuses = new LendStatus[](lendersListLength);\n        for (uint256 i = 0; i < lendersListLength; i++) {\n            LendStatus memory s;\n            s.name = lenders[i].lenderName();\n            s.add = address(lenders[i]);\n            s.assets = lenders[i].nav();\n            s.rate = lenders[i].apr();\n            statuses[i] = s;\n        }\n        return statuses;\n    }\n\n    /// @notice View function to check the total assets lent\n    function lentTotalAssets() public view returns (uint256) {\n        uint256 nav = 0;\n        for (uint256 i = 0; i < lenders.length; i++) {\n            nav = nav + lenders[i].nav();\n        }\n        return nav;\n    }\n\n    /// @notice View function to check the total assets managed by the strategy\n    function estimatedTotalAssets() public view override returns (uint256 nav) {\n        nav = lentTotalAssets() + want.balanceOf(address(this));\n    }\n\n    /// @notice View function to check the number of lending platforms\n    function numLenders() external view returns (uint256) {\n        return lenders.length;\n    }\n\n    /// @notice The weighted apr of all lenders. sum(nav * apr)/totalNav\n    function estimatedAPR() external view returns (uint256) {\n        uint256 bal = estimatedTotalAssets();\n        if (bal == 0) {\n            return 0;\n        }\n\n        uint256 weightedAPR = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            weightedAPR = weightedAPR + lenders[i].weightedApr();\n        }\n\n        return weightedAPR / bal;\n    }\n\n    /// @notice Prevents the governance from withdrawing want tokens\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n\n    // ================================= GOVERNANCE ================================\n\n    struct LenderRatio {\n        address lender;\n        //share x 1000\n        uint16 share;\n    }\n\n    /// @notice Reallocates all funds according to a new distribution\n    /// @param _newPositions List of shares to specify the new allocation\n    /// @dev Share must add up to 1000. 500 means 50% etc\n    /// @dev This code has been forked, so we have not thoroughly tested it\n    function manualAllocation(LenderRatio[] memory _newPositions) external onlyRole(GUARDIAN_ROLE) {\n        IGenericLender[] memory lendersList = lenders;\n        uint256 share = 0;\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            lendersList[i].withdrawAll();\n        }\n\n        uint256 assets = want.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _newPositions.length; i++) {\n            bool found = false;\n\n            //might be annoying and expensive to do this second loop but worth it for safety\n            for (uint256 j = 0; j < lendersList.length; j++) {\n                if (address(lendersList[j]) == _newPositions[i].lender) {\n                    found = true;\n                }\n            }\n            require(found, \"94\");\n\n            share = share + _newPositions[i].share;\n            uint256 toSend = (assets * _newPositions[i].share) / 1000;\n            want.safeTransfer(_newPositions[i].lender, toSend);\n            IGenericLender(_newPositions[i].lender).deposit();\n        }\n\n        require(share == 1000, \"95\");\n    }\n\n    /// @notice Changes the withdrawal threshold\n    /// @param _threshold The new withdrawal threshold\n    /// @dev governor, guardian or `PoolManager` only\n    function setWithdrawalThreshold(uint256 _threshold) external onlyRole(GUARDIAN_ROLE) {\n        withdrawalThreshold = _threshold;\n    }\n\n    /// @notice Add lenders for the strategy to choose between\n    /// @param newLender The adapter to the added lending platform\n    /// @dev Governor, guardian or `PoolManager` only\n    function addLender(IGenericLender newLender) external onlyRole(GUARDIAN_ROLE) {\n        require(newLender.strategy() == address(this), \"96\");\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            require(address(newLender) != address(lenders[i]), \"97\");\n        }\n        lenders.push(newLender);\n\n        emit AddLender(address(newLender));\n    }\n\n    /// @notice Removes a lending platform and fails if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function safeRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, false);\n    }\n\n    /// @notice Removes a lending platform and even if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function forceRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, true);\n    }\n\n    /// @notice Internal function to handle lending platform removing\n    /// @param lender The address of the adapter for the lending platform to remove\n    /// @param force Whether it is required that all the funds are withdrawn prior to removal\n    function _removeLender(address lender, bool force) internal {\n        IGenericLender[] memory lendersList = lenders;\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            if (lender == address(lendersList[i])) {\n                bool allWithdrawn = lendersList[i].withdrawAll();\n\n                if (!force) {\n                    require(allWithdrawn, \"98\");\n                }\n\n                // Put the last index here\n                // then remove last index\n                if (i != lendersList.length - 1) {\n                    lenders[i] = lendersList[lendersList.length - 1];\n                }\n\n                // Pop shortens array by 1 thereby deleting the last index\n                lenders.pop();\n\n                // If balance to spend we might as well put it into the best lender\n                if (want.balanceOf(address(this)) > 0) {\n                    _adjustPosition();\n                }\n\n                emit RemoveLender(lender);\n\n                return;\n            }\n        }\n        require(false, \"94\");\n    }\n\n    // ============================= MANAGER FUNCTIONS =============================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role in other contract\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].grantRole(GUARDIAN_ROLE, _guardian);\n        }\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].revokeRole(GUARDIAN_ROLE, guardian);\n        }\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/OptimizerAPRStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../BaseStrategyUpgradeable.sol\";\n\nimport \"../../interfaces/IGenericLender.sol\";\n\n/// @title OptimizerAPRStrategy\n/// @author Angle Labs, Inc.\n/// @notice A lender optimisation strategy for any ERC20 asset, leveraging multiple lenders at once\n/// @dev This strategy works by taking plugins designed for standard lending platforms and automatically\n/// chooses to invest its funds in the best platforms to generate yield.\n/// The allocation is greedy and may be sub-optimal so there is an additional option to manually set positions\ncontract OptimizerAPRStrategy is BaseStrategyUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ================================= CONSTANTS =================================\n\n    uint64 internal constant _BPS = 10000;\n\n    // ============================ CONTRACTS REFERENCES ===========================\n\n    IGenericLender[] public lenders;\n\n    // ================================= PARAMETERS ================================\n\n    uint256 public withdrawalThreshold;\n\n    // =================================== EVENTS ==================================\n\n    event AddLender(address indexed lender);\n    event RemoveLender(address indexed lender);\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param governor Address with governor privilege\n    /// @param guardian Address of the guardian\n    function initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers\n    ) external {\n        _initialize(_poolManager, governor, guardian, keepers);\n        withdrawalThreshold = 1000 * wantBase;\n    }\n\n    // ============================= INTERNAL FUNCTIONS ============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _debtPayment = _debtOutstanding;\n\n        uint256 lentAssets = lentTotalAssets();\n\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        uint256 total = looseAssets + lentAssets;\n\n        if (lentAssets == 0) {\n            // No position to harvest or profit to report\n            if (_debtPayment > looseAssets) {\n                // We can only return looseAssets\n                _debtPayment = looseAssets;\n            }\n\n            return (_profit, _loss, _debtPayment);\n        }\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (total > debt) {\n            _profit = total - debt;\n\n            uint256 amountToFree = _profit + _debtPayment;\n            // We need to add outstanding to our profit\n            // don't need to do logic if there is nothing to free\n            if (amountToFree != 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust _debtOutstanding and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_profit > newLoose) {\n                        _profit = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _profit, _debtPayment);\n                    }\n                }\n            }\n        } else {\n            // Serious loss should never happen but if it does lets record it accurately\n            _loss = debt - total;\n\n            uint256 amountToFree = _loss + _debtPayment;\n            if (amountToFree != 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust `_debtOutstanding` and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_loss > newLoose) {\n                        _loss = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _loss, _debtPayment);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Estimates highest and lowest apr lenders among a `lendersList`\n    /// @param lendersList List of all the lender contracts associated to this strategy\n    /// @return _lowest The index of the lender in the `lendersList` with lowest apr\n    /// @return _highest The index of the lender with highest apr\n    /// @return _investmentStrategy Whether we should invest from the lowest to the highest yielding strategy or simply invest loose assets\n    /// @return _totalApr The APR computed according to (greedy) heuristics that will determine whether positions should be adjusted\n    /// according to the solution proposed by the caller or according to the greedy method\n    /// @dev `lendersList` is kept as a parameter to avoid multiplying reads in storage to the `lenders` array\n    function _estimateGreedyAdjustPosition(IGenericLender[] memory lendersList)\n        internal\n        view\n        returns (\n            uint256 _lowest,\n            uint256 _highest,\n            bool _investmentStrategy,\n            uint256 _totalApr\n        )\n    {\n        // All loose assets are to be invested\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        // Simple greedy algo:\n        //  - Get the lowest apr strat\n        //  - Cycle through and see who could take its funds to improve the overall highest APR\n        uint256 lowestNav;\n        uint256 highestApr;\n        uint256 highestLenderNav;\n        uint256 totalNav = looseAssets;\n        uint256[] memory weightedAprs = new uint256[](lendersList.length);\n        uint256 lendersListLength = lendersList.length;\n        {\n            uint256 lowestApr = type(uint256).max;\n            for (uint256 i; i < lendersListLength; ++i) {\n                uint256 aprAfterDeposit = lendersList[i].aprAfterDeposit(int256(looseAssets));\n                uint256 nav = lendersList[i].nav();\n                totalNav += nav;\n                if (aprAfterDeposit > highestApr) {\n                    highestApr = aprAfterDeposit;\n                    highestLenderNav = nav;\n                    _highest = i;\n                }\n                // Checking strategies that have assets\n                if (nav > 10 * wantBase) {\n                    uint256 apr = lendersList[i].apr();\n                    weightedAprs[i] = apr * nav;\n                    if (apr < lowestApr) {\n                        lowestApr = apr;\n                        lowestNav = nav;\n                        _lowest = i;\n                    }\n                }\n            }\n        }\n\n        // Comparing if we are better off removing from the lowest APR yielding strategy to invest in the highest or just invest\n        // the loose assets in the highest yielding strategy\n        if (totalNav > 0) {\n            // Case where only loose assets are invested\n            uint256 weightedApr1;\n            // Case where funds are divested from the strategy with the lowest APR to be invested in the one with the highest APR\n            uint256 weightedApr2;\n            for (uint256 i; i < lendersListLength; ++i) {\n                if (i == _highest) {\n                    weightedApr1 += (highestLenderNav + looseAssets) * highestApr;\n                    if (lowestNav != 0 && lendersListLength > 1)\n                        weightedApr2 +=\n                            (highestLenderNav + looseAssets + lowestNav) *\n                            lendersList[_highest].aprAfterDeposit(int256(lowestNav + looseAssets));\n                } else if (i == _lowest) {\n                    weightedApr1 += weightedAprs[i];\n                    // In the second case funds are divested so the lowest strat does not contribute to the highest APR case\n                } else {\n                    weightedApr1 += weightedAprs[i];\n                    weightedApr2 += weightedAprs[i];\n                }\n            }\n            if (weightedApr2 > weightedApr1 && lendersList.length > 1) {\n                _investmentStrategy = true;\n                _totalApr = weightedApr2 / totalNav;\n            } else _totalApr = weightedApr1 / totalNav;\n        }\n    }\n\n    /// @inheritdoc BaseStrategyUpgradeable\n    function _adjustPosition(bytes memory data) internal override {\n        // Emergency exit is dealt with at beginning of harvest\n        if (emergencyExit) return;\n\n        // Storing the `lenders` array in a cache variable\n        IGenericLender[] memory lendersList = lenders;\n        uint256 lendersListLength = lendersList.length;\n        // We just keep all money in `want` if we dont have any lenders\n        if (lendersListLength == 0) return;\n\n        uint64[] memory lenderSharesHint = abi.decode(data, (uint64[]));\n\n        uint256 estimatedAprHint;\n        int256[] memory lenderAdjustedAmounts;\n        if (lenderSharesHint.length != 0) (estimatedAprHint, lenderAdjustedAmounts) = estimatedAPR(lenderSharesHint);\n        (uint256 lowest, uint256 highest, bool _investmentStrategy, uint256 _totalApr) = _estimateGreedyAdjustPosition(\n            lendersList\n        );\n\n        // The hint was successful --> we find a better allocation than the current one\n        if (_totalApr < estimatedAprHint) {\n            uint256 deltaWithdraw;\n            for (uint256 i; i < lendersListLength; ++i) {\n                if (lenderAdjustedAmounts[i] < 0) {\n                    deltaWithdraw +=\n                        uint256(-lenderAdjustedAmounts[i]) -\n                        lendersList[i].withdraw(uint256(-lenderAdjustedAmounts[i]));\n                }\n            }\n\n            // If the strategy didn't succeed to withdraw the intended funds -> revert and force the greedy path\n            if (deltaWithdraw > withdrawalThreshold) revert IncorrectDistribution();\n\n            for (uint256 i; i < lendersListLength; ++i) {\n                // As `deltaWithdraw` is inferior to `withdrawalThreshold` (a dust)\n                // It is not critical to compensate on an arbitrary lender as it will only slightly impact global APR\n                if (lenderAdjustedAmounts[i] > int256(deltaWithdraw)) {\n                    lenderAdjustedAmounts[i] -= int256(deltaWithdraw);\n                    deltaWithdraw = 0;\n                    want.safeTransfer(address(lendersList[i]), uint256(lenderAdjustedAmounts[i]));\n                    lendersList[i].deposit();\n                } else if (lenderAdjustedAmounts[i] > 0) deltaWithdraw -= uint256(lenderAdjustedAmounts[i]);\n            }\n        } else {\n            if (_investmentStrategy) {\n                lendersList[lowest].withdrawAll();\n            }\n\n            uint256 bal = want.balanceOf(address(this));\n            if (bal != 0) {\n                want.safeTransfer(address(lendersList[highest]), bal);\n                lendersList[highest].deposit();\n            }\n        }\n    }\n\n    /// @inheritdoc BaseStrategyUpgradeable\n    function _adjustPosition() internal override {\n        _adjustPosition(abi.encode(new uint64[](0)));\n    }\n\n    /// @inheritdoc BaseStrategyUpgradeable\n    function _adjustPosition(uint256) internal override {\n        _adjustPosition(abi.encode(new uint64[](0)));\n    }\n\n    /// @notice Withdraws a given amount from lenders\n    /// @param _amount The amount to withdraw\n    /// @dev Cycle through withdrawing from worst rate first\n    function _withdrawSome(uint256 _amount) internal returns (uint256 amountWithdrawn) {\n        IGenericLender[] memory lendersList = lenders;\n        uint256 lendersListLength = lendersList.length;\n        if (lendersListLength == 0) {\n            return 0;\n        }\n\n        // Don't withdraw dust\n        uint256 _withdrawalThreshold = withdrawalThreshold;\n        if (_amount < _withdrawalThreshold) {\n            return 0;\n        }\n\n        amountWithdrawn;\n        // In most situations this will only run once. Only big withdrawals will be a gas guzzler\n        uint256 j;\n        while (amountWithdrawn < _amount - _withdrawalThreshold) {\n            uint256 lowestApr = type(uint256).max;\n            uint256 lowest;\n            for (uint256 i; i < lendersListLength; ++i) {\n                if (lendersList[i].hasAssets()) {\n                    uint256 apr = lendersList[i].apr();\n                    if (apr < lowestApr) {\n                        lowestApr = apr;\n                        lowest = i;\n                    }\n                }\n            }\n            if (!lendersList[lowest].hasAssets()) {\n                return amountWithdrawn;\n            }\n            uint256 amountWithdrawnFromStrat = lendersList[lowest].withdraw(_amount - amountWithdrawn);\n            // To avoid staying on the same strat if we can't withdraw anythin from it\n            amountWithdrawn += amountWithdrawnFromStrat;\n            ++j;\n            // not best solution because it would be better to move to the 2nd lowestAPR instead of quiting\n            if (amountWithdrawnFromStrat == 0) {\n                return amountWithdrawn;\n            }\n            // To avoid want infinite loop\n            if (j >= 6) {\n                return amountWithdrawn;\n            }\n        }\n    }\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other sitution at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _amountFreed, uint256 _loss) {\n        uint256 _balance = want.balanceOf(address(this));\n\n        if (_balance >= _amountNeeded) {\n            //if we don't set reserve here withdrawer will be sent our full balance\n            return (_amountNeeded, 0);\n        } else {\n            uint256 received = _withdrawSome(_amountNeeded - _balance) + (_balance);\n            if (received >= _amountNeeded) {\n                return (_amountNeeded, 0);\n            } else {\n                return (received, 0);\n            }\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        (_amountFreed, ) = _liquidatePosition(estimatedTotalAssets());\n    }\n\n    // =============================== VIEW FUNCTIONS ==============================\n\n    /// @notice View function to check the current state of the strategy\n    /// @return Returns the status of all lenders attached the strategy\n    function lendStatuses() external view returns (LendStatus[] memory) {\n        uint256 lendersLength = lenders.length;\n        LendStatus[] memory statuses = new LendStatus[](lendersLength);\n        for (uint256 i; i < lendersLength; ++i) {\n            LendStatus memory s;\n            s.name = lenders[i].lenderName();\n            s.add = address(lenders[i]);\n            s.assets = lenders[i].nav();\n            s.rate = lenders[i].apr();\n            statuses[i] = s;\n        }\n        return statuses;\n    }\n\n    /// @notice View function to check the total assets lent\n    function lentTotalAssets() public view returns (uint256) {\n        uint256 nav;\n        uint256 lendersLength = lenders.length;\n        for (uint256 i; i < lendersLength; ++i) {\n            nav += lenders[i].nav();\n        }\n        return nav;\n    }\n\n    /// @notice View function to check the total assets managed by the strategy\n    function estimatedTotalAssets() public view override returns (uint256 nav) {\n        nav = lentTotalAssets() + want.balanceOf(address(this));\n    }\n\n    /// @notice View function to check the number of lending platforms\n    function numLenders() external view returns (uint256) {\n        return lenders.length;\n    }\n\n    /// @notice Returns the weighted apr of all lenders\n    /// @dev It's computed by doing: `sum(nav * apr) / totalNav`\n    function estimatedAPR() external view returns (uint256) {\n        uint256 bal = estimatedTotalAssets();\n        if (bal == 0) {\n            return 0;\n        }\n\n        uint256 weightedAPR;\n        uint256 lendersLength = lenders.length;\n        for (uint256 i; i < lendersLength; ++i) {\n            weightedAPR += lenders[i].weightedApr();\n        }\n\n        return weightedAPR / bal;\n    }\n\n    /// @notice Returns the weighted apr in an hypothetical world where the strategy splits its nav\n    /// in respect to shares\n    /// @param shares List of shares (in bps of the nav) that should be allocated to each lender\n    function estimatedAPR(uint64[] memory shares)\n        public\n        view\n        returns (uint256 weightedAPR, int256[] memory lenderAdjustedAmounts)\n    {\n        uint256 lenderLength = lenders.length;\n        lenderAdjustedAmounts = new int256[](lenderLength);\n        if (lenderLength != shares.length) revert IncorrectListLength();\n\n        uint256 bal = estimatedTotalAssets();\n        if (bal == 0) return (weightedAPR, lenderAdjustedAmounts);\n\n        uint256 share;\n        for (uint256 i; i < lenderLength; ++i) {\n            share += shares[i];\n            uint256 futureDeposit = (bal * shares[i]) / _BPS;\n            // It won't overflow for `decimals <= 18`, as it would mean gigantic amounts\n            int256 adjustedAmount = int256(futureDeposit) - int256(lenders[i].nav());\n            lenderAdjustedAmounts[i] = adjustedAmount;\n            weightedAPR += futureDeposit * lenders[i].aprAfterDeposit(adjustedAmount);\n        }\n        if (share != 10000) revert InvalidShares();\n\n        weightedAPR /= bal;\n    }\n\n    /// @notice Prevents governance from withdrawing `want` tokens\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n\n    // ================================= GOVERNANCE ================================\n\n    /// @notice Changes the withdrawal threshold\n    /// @param _threshold New withdrawal threshold\n    /// @dev governor, guardian or `PoolManager` only\n    function setWithdrawalThreshold(uint256 _threshold) external onlyRole(GUARDIAN_ROLE) {\n        withdrawalThreshold = _threshold;\n    }\n\n    /// @notice Add lenders for the strategy to choose between\n    /// @param newLender The adapter to the added lending platform\n    /// @dev Governor, guardian or `PoolManager` only\n    function addLender(IGenericLender newLender) external onlyRole(GUARDIAN_ROLE) {\n        if (newLender.strategy() != address(this)) revert UndockedLender();\n        uint256 lendersLength = lenders.length;\n        for (uint256 i; i < lendersLength; ++i) {\n            if (address(newLender) == address(lenders[i])) revert LenderAlreadyAdded();\n        }\n        lenders.push(newLender);\n\n        emit AddLender(address(newLender));\n    }\n\n    /// @notice Removes a lending platform and fails if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function safeRemoveLender(address lender) external onlyRole(KEEPER_ROLE) {\n        _removeLender(lender, false);\n    }\n\n    /// @notice Removes a lending platform even if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function forceRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, true);\n    }\n\n    /// @notice Internal function to handle lending platform removal\n    /// @param lender The address of the adapter for the lending platform to remove\n    /// @param force Whether it is required that all the funds are withdrawn prior to removal\n    function _removeLender(address lender, bool force) internal {\n        IGenericLender[] memory lendersList = lenders;\n        uint256 lendersListLength = lendersList.length;\n        for (uint256 i; i < lendersListLength; ++i) {\n            if (lender == address(lendersList[i])) {\n                bool allWithdrawn = lendersList[i].withdrawAll();\n\n                if (!force && !allWithdrawn) revert FailedWithdrawal();\n\n                // Put the last index here\n                // then remove last index\n                if (i != lendersListLength - 1) {\n                    lenders[i] = lendersList[lendersListLength - 1];\n                }\n\n                // Pop shortens array by 1 thereby deleting the last index\n                lenders.pop();\n\n                // If balance to spend we might as well put it into the best lender\n                if (want.balanceOf(address(this)) != 0) {\n                    _adjustPosition();\n                }\n\n                emit RemoveLender(lender);\n\n                return;\n            }\n        }\n        revert NonExistentLender();\n    }\n\n    // ============================= MANAGER FUNCTIONS =============================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role to underyling lenders\n        uint256 lendersLength = lenders.length;\n        for (uint256 i; i < lendersLength; ++i) {\n            lenders[i].grantRole(GUARDIAN_ROLE, _guardian);\n        }\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n        uint256 lendersLength = lenders.length;\n        for (uint256 i; i < lendersLength; ++i) {\n            lenders[i].revokeRole(GUARDIAN_ROLE, guardian);\n        }\n    }\n}\n"
    },
    "contracts/strategies/StETHStrategy/StETHStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../../interfaces/external/curve/IStableSwapPool.sol\";\nimport \"../../interfaces/external/lido/ISteth.sol\";\nimport \"../../interfaces/external/IWETH9.sol\";\nimport \"../BaseStrategyUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title StrategyStETHAcc\n/// @author Forked from https://github.com/Grandthrax/yearn-steth-acc/blob/master/contracts/Strategy.sol\n/// @notice A strategy designed to getting yield on wETH by putting ETH in Lido or Curve for stETH and exiting\n/// for wETH\ncontract StETHStrategy is BaseStrategyUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @notice Current `apr` of the strategy: this apr needs to be manually filled by the strategist\n    /// and updated when Lido's APR changes. It is put like that as there is no easy way to compute Lido's APR\n    /// on-chain\n    /// @notice Base used is `BASE_PARAMS`\n    uint256 public apr;\n\n    /// @notice Reference to the Curve ETH/stETH\n    IStableSwapPool public stableSwapSTETH;\n    /// @notice Reference to wETH, it should normally be equal to `want`\n    IWETH9 public weth;\n    /// @notice Reference to the stETH token\n    ISteth public stETH;\n\n    address private _referral = 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8; //stratms. for recycling and redepositing\n    /// @notice Maximum trade size within the strategy\n    uint256 public maxSingleTrade;\n    /// @notice Parameter used for slippage protection\n    uint256 public constant DENOMINATOR = 10_000;\n    /// @notice Slippage parameter for the swaps on Curve: out of `DENOMINATOR`\n    uint256 public slippageProtectionOut; // = 50; //out of 10000. 50 = 0.5%\n\n    /// @notice ID of ETH in the Curve pool\n    int128 private constant _WETHID = 0;\n    /// @notice ID of stETH in the Curve pool\n    int128 private constant _STETHID = 1;\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param governor Address of the governance multisig with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param keepers List of addresses of keepers\n    /// @param _stableSwapSTETH Address of the stETH/ETH Curve pool\n    /// @param _weth Address of wETH\n    /// @param _stETH Address of the stETH token\n    /// @param _apr Estimated apr on staked ETH\n    function initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers,\n        address _stableSwapSTETH,\n        address _weth,\n        ISteth _stETH,\n        uint256 _apr\n    ) external {\n        _initialize(_poolManager, governor, guardian, keepers);\n        require(address(want) == _weth, \"20\");\n        stableSwapSTETH = IStableSwapPool(_stableSwapSTETH);\n        weth = IWETH9(_weth);\n        stETH = ISteth(_stETH);\n        apr = _apr;\n        _stETH.approve(_stableSwapSTETH, type(uint256).max);\n        maxSingleTrade = 10_000 * 1e18;\n        slippageProtectionOut = 30;\n    }\n\n    /// @notice This contract gets ETH and so it needs this function\n    receive() external payable {}\n\n    // ========================== View Functions ===================================\n\n    /// @notice View function to check the total assets managed by the strategy\n    /// @dev We are purposely treating stETH and ETH as being equivalent.\n    /// This is for a few reasons. The main one is that we do not have a good way to value\n    /// stETH at any current time without creating exploit routes.\n    /// Currently you can mint eth for steth but can't burn steth for eth so need to sell.\n    /// Once eth 2.0 is merged you will be able to burn 1-1 as well.\n    /// The main downside here is that we will noramlly overvalue our position as we expect stETH\n    /// to trade slightly below peg. That means we will earn profit on deposits and take losses on withdrawals.\n    /// This may sound scary but it is the equivalent of using virtualprice in a curve lp.\n    /// As we have seen from many exploits, virtual pricing is safer than touch pricing.\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return stethBalance() + wantBalance();\n    }\n\n    /// @notice Returns the wETH balance of the strategy\n    function wantBalance() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @notice Returns the stETH balance of the strategy\n    function stethBalance() public view returns (uint256) {\n        return stETH.balanceOf(address(this));\n    }\n\n    /// @notice The ETH APR of owning stETH\n    function estimatedAPR() external view returns (uint256) {\n        return apr;\n    }\n\n    // ========================== Strategy Functions ===============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt: it is an amount made available for the `PoolManager`\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        uint256 wantBal = wantBalance();\n        uint256 stethBal = stethBalance();\n        uint256 totalAssets = wantBal + stethBal;\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (totalAssets >= debt) {\n            _profit = totalAssets - debt;\n\n            uint256 toWithdraw = _profit + _debtOutstanding;\n            // If more should be withdrawn than what's in the strategy: we divest from Curve\n            if (toWithdraw > wantBal) {\n                // We step our withdrawals. Adjust max single trade to withdraw more\n                uint256 willWithdraw = Math.min(maxSingleTrade, toWithdraw - wantBal);\n                uint256 withdrawn = _divest(willWithdraw);\n                if (withdrawn < willWithdraw) {\n                    _loss = willWithdraw - withdrawn;\n                }\n            }\n            wantBal = wantBalance();\n\n            // Computing net off profit and loss\n            if (_profit >= _loss) {\n                _profit = _profit - _loss;\n                _loss = 0;\n            } else {\n                _profit = 0;\n                _loss = _loss - _profit;\n            }\n\n            // profit + _debtOutstanding must be <= wantbalance. Prioritise profit first\n            if (wantBal < _profit) {\n                _profit = wantBal;\n            } else if (wantBal < toWithdraw) {\n                _debtPayment = wantBal - _profit;\n            } else {\n                _debtPayment = _debtOutstanding;\n            }\n        } else {\n            _loss = debt - totalAssets;\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        _divest(stethBalance());\n        _amountFreed = wantBalance();\n    }\n\n    /// @notice Function called when harvesting to invest in stETH\n    /// Function used in other contracts, in this strategy it is useless\n    function _adjustPosition(uint256) internal override {\n        _adjustPosition();\n    }\n\n    /// @notice Function called when harvesting to invest in stETH\n    function _adjustPosition() internal override {\n        uint256 toInvest = wantBalance();\n        if (toInvest > 0) {\n            uint256 realInvest = Math.min(maxSingleTrade, toInvest);\n            _invest(realInvest);\n        }\n    }\n\n    /// @notice Invests `_amount` wETH in stETH\n    /// @param _amount Amount of wETH to put in stETH\n    /// @return The amount of stETH received from the investment\n    /// @dev This function chooses the optimal route between going to Lido directly or doing a swap on Curve\n    /// @dev This function automatically wraps wETH to ETH\n    function _invest(uint256 _amount) internal returns (uint256) {\n        uint256 before = stethBalance();\n        // Unwrapping the tokens\n        weth.withdraw(_amount);\n        // Test if we should buy from Curve instead of minting from Lido\n        uint256 out = stableSwapSTETH.get_dy(_WETHID, _STETHID, _amount);\n        if (out < _amount) {\n            // If we get less than one stETH per wETH we use Lido\n            stETH.submit{ value: _amount }(_referral);\n        } else {\n            // Otherwise, we do a Curve swap\n            stableSwapSTETH.exchange{ value: _amount }(_WETHID, _STETHID, _amount, _amount);\n        }\n\n        return stethBalance() - before;\n    }\n\n    /// @notice Divests stETH on Curve and gets wETH back to the strategy in exchange\n    /// @param _amount Amount of stETH to divest\n    /// @dev Curve is the only place to convert stETH to ETH\n    function _divest(uint256 _amount) internal returns (uint256) {\n        uint256 before = wantBalance();\n\n        // Computing slippage protection for the swap\n        uint256 slippageAllowance = (_amount * (DENOMINATOR - slippageProtectionOut)) / DENOMINATOR;\n        // Curve swap\n        stableSwapSTETH.exchange(_STETHID, _WETHID, _amount, slippageAllowance);\n\n        weth.deposit{ value: address(this).balance }();\n\n        return wantBalance() - before;\n    }\n\n    /// @notice Attempts to withdraw `_amountNeeded` from the strategy and lets the user decide if they take the loss or not\n    /// @param _amountNeeded Amount to withdraw from the strategy\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 wantBal = wantBalance();\n        if (wantBal < _amountNeeded) {\n            uint256 toWithdraw = _amountNeeded - wantBal;\n            uint256 withdrawn = _divest(toWithdraw);\n            if (withdrawn < toWithdraw) {\n                _loss = toWithdraw - withdrawn;\n            }\n        }\n\n        _liquidatedAmount = _amountNeeded - _loss;\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n\n    // Override this to add all tokens/tokenized positions this contract manages\n    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)\n    // NOTE: Do *not* include `want`, already included in `sweep` below\n    //\n    // Example:\n    //\n    //    function _protectedTokens() internal override view returns (address[] memory) {\n    //      address[] memory protected = new address[](3);\n    //      protected[0] = tokenA;\n    //      protected[1] = tokenB;\n    //      protected[2] = tokenC;\n    //      return protected;\n    //    }\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(stETH);\n\n        return protected;\n    }\n\n    // ============================ Governance =====================================\n\n    /// @notice Updates the referral code for Lido\n    /// @param newReferral Address of the new referral\n    function updateReferral(address newReferral) public onlyRole(GUARDIAN_ROLE) {\n        _referral = newReferral;\n    }\n\n    /// @notice Updates the size of a trade in the strategy\n    /// @param _maxSingleTrade New `maxSingleTrade` value\n    function updateMaxSingleTrade(uint256 _maxSingleTrade) public onlyRole(GUARDIAN_ROLE) {\n        maxSingleTrade = _maxSingleTrade;\n    }\n\n    /// @notice Changes the estimated APR of the strategy\n    /// @param _apr New strategy APR\n    function setApr(uint256 _apr) public onlyRole(GUARDIAN_ROLE) {\n        apr = _apr;\n    }\n\n    /// @notice Updates the maximum slippage protection parameter\n    /// @param _slippageProtectionOut New slippage protection parameter\n    function updateSlippageProtectionOut(uint256 _slippageProtectionOut) public onlyRole(GUARDIAN_ROLE) {\n        slippageProtectionOut = _slippageProtectionOut;\n    }\n\n    /// @notice Invests `_amount` in stETH\n    /// @param _amount Amount to invest\n    /// @dev This function allows to override the behavior that could be obtained through `harvest` calls\n    function invest(uint256 _amount) external onlyRole(GUARDIAN_ROLE) {\n        require(wantBalance() >= _amount);\n        uint256 realInvest = Math.min(maxSingleTrade, _amount);\n        _invest(realInvest);\n    }\n\n    /// @notice Rescues stuck ETH from the strategy\n    /// @dev This strategy should never have stuck eth, but let it just in case\n    function rescueStuckEth() external onlyRole(GUARDIAN_ROLE) {\n        weth.deposit{ value: address(this).balance }();\n    }\n\n    // ========================== Manager functions ================================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n    }\n}\n"
    },
    "contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nerror ErrorSwap();\nerror FailedToMint();\nerror FailedToRecoverETH();\nerror FailedToRedeem();\nerror FailedWithdrawal();\nerror IncompatibleLengths();\nerror IncorrectDistribution();\nerror IncorrectListLength();\nerror InvalidOracleValue();\nerror InvalidSender();\nerror InvalidSetOfParameters();\nerror InvalidShares();\nerror InvalidToken();\nerror InvalidWithdrawCheck();\nerror LenderAlreadyAdded();\nerror NoLockedLiquidity();\nerror NonExistentLender();\nerror PoolNotIncentivized();\nerror ProtectedToken();\nerror TooHighParameterValue();\nerror TooSmallAmount();\nerror TooSmallAmountOut();\nerror TooSmallStakingPeriod();\nerror UndockedLender();\nerror WrongCToken();\nerror ZeroAddress();\n"
    },
    "contracts/utils/FunctionUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title FunctionUtils\n/// @author Angle Core Team\n/// @notice Contains all the utility functions that are needed in different places of the protocol\n/// @dev Functions in this contract should typically be pure functions\n/// @dev This contract is voluntarily a contract and not a library to save some gas cost every time it is used\ncontract FunctionUtils {\n    /// @notice Base that is used to compute ratios and floating point numbers\n    uint256 public constant BASE_TOKENS = 10**18;\n    /// @notice Base that is used to define parameters that need to have a floating point value (for instance parameters\n    /// that are defined as ratios)\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    /// @notice Computes the value of a linear by part function at a given point\n    /// @param x Point of the function we want to compute\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev The evolution of the linear by part function between two breaking points is linear\n    /// @dev Before the first breaking point and after the last one, the function is constant with a value\n    /// equal to the first or last value of the yArray\n    /// @dev This function is relevant if `x` is between O and `BASE_PARAMS`. If `x` is greater than that, then\n    /// everything will be as if `x` is equal to the greater element of the `xArray`\n    function _piecewiseLinear(\n        uint64 x,\n        uint64[] memory xArray,\n        uint64[] memory yArray\n    ) internal pure returns (uint64) {\n        if (x >= xArray[xArray.length - 1]) {\n            return yArray[xArray.length - 1];\n        } else if (x <= xArray[0]) {\n            return yArray[0];\n        } else {\n            uint256 lower;\n            uint256 upper = xArray.length - 1;\n            uint256 mid;\n            while (upper - lower > 1) {\n                mid = lower + (upper - lower) / 2;\n                if (xArray[mid] <= x) {\n                    lower = mid;\n                } else {\n                    upper = mid;\n                }\n            }\n            if (yArray[upper] > yArray[lower]) {\n                // There is no risk of overflow here as in the product of the difference of `y`\n                // with the difference of `x`, the product is inferior to `BASE_PARAMS**2` which does not\n                // overflow for `uint64`\n                return\n                    yArray[lower] +\n                    ((yArray[upper] - yArray[lower]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            } else {\n                return\n                    yArray[lower] -\n                    ((yArray[lower] - yArray[upper]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            }\n        }\n    }\n\n    /// @notice Checks if the input arrays given by governance to update the fee structure is valid\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev This function is a way to avoid some governance attacks or errors\n    /// @dev The modifier checks if the arrays have a non null length, if their length is the same, if the values\n    /// in the `xArray` are in ascending order and if the values in the `xArray` and in the `yArray` are not superior\n    /// to `BASE_PARAMS`\n    modifier onlyCompatibleInputArrays(uint64[] memory xArray, uint64[] memory yArray) {\n        require(xArray.length == yArray.length && xArray.length > 0, \"5\");\n        for (uint256 i = 0; i <= yArray.length - 1; i++) {\n            require(yArray[i] <= uint64(BASE_PARAMS) && xArray[i] <= uint64(BASE_PARAMS), \"6\");\n            if (i > 0) {\n                require(xArray[i] > xArray[i - 1], \"7\");\n            }\n        }\n        _;\n    }\n\n    /// @notice Checks if the new value given for the parameter is consistent (it should be inferior to 1\n    /// if it corresponds to a ratio)\n    /// @param fees Value of the new parameter to check\n    modifier onlyCompatibleFees(uint64 fees) {\n        require(fees <= BASE_PARAMS, \"4\");\n        _;\n    }\n\n    /// @notice Checks if the new address given is not null\n    /// @param newAddress Address to check\n    /// @dev Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation\n    modifier zeroCheck(address newAddress) {\n        require(newAddress != address(0), \"0\");\n        _;\n    }\n}\n"
    },
    "contracts/utils/OracleMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../external/FullMath.sol\";\n\n/// @title OracleMath\n/// @author Forked and adapted by Angle Core Team from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol\n/// @notice Math library for computing prices from ticks\n/// @dev Computes price for ticks of size 1.0001, i.e. sqrt(1.0001^tick). Supports\n/// prices between 2**-128 and 2**128\ncontract OracleMath is FullMath {\n    /// @dev Maximum tick that may be passed to `_getSqrtRatioAtTick` computed from log base 1.0001 of 2**128\n    int24 internal constant _MAX_TICK = 887272;\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param multiply Boolean representing whether the `baseToken` has a lower address than the `quoteToken`\n    /// @return quoteAmount Amount of `quoteToken` received for `baseAmount` of `baseToken`\n    function _getQuoteAtTick(\n        int24 tick,\n        uint256 baseAmount,\n        uint256 multiply\n    ) internal pure returns (uint256 quoteAmount) {\n        uint256 ratio = _getRatioAtTick(tick);\n\n        quoteAmount = (multiply == 1) ? _mulDiv(ratio, baseAmount, 1e18) : _mulDiv(1e18, baseAmount, ratio);\n    }\n\n    /// @notice Calculates 1.0001^tick * in out ERC20 decimals\n    /// @dev Adapted from Uniswap `_getSqrtRatioAtTick` but we don't consider the square root\n    /// anymore but directly the full rate\n    /// @dev Throws if `|tick| > max tick`\n    /// @param tick The input tick for the above formula\n    /// @return rate uint256 representing the ratio of the two assets `(token1/token0) * 10**decimals(token1)`\n    /// at the given tick\n    function _getRatioAtTick(int24 tick) internal pure returns (uint256 rate) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(_MAX_TICK)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfff97272373d413259a46990580e213a : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x149b34ee7ac262) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // We need to modify the 96 decimal to be able to convert it to a D256\n        // 2**59 ~ 10**18 (thus we guarantee the same precision) and 128-59 = 69\n        // We retrieve a Q128.59 decimal. --> we have 69 bits free to reach the uint256 limit.\n        // Now, 2**69 >> 10**18 so we are safe in the Decimal conversion.\n\n        uint256 price = uint256((ratio >> 69) + (ratio % (1 << 69) == 0 ? 0 : 1));\n        rate = ((price * 1e18) >> 59);\n    }\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}