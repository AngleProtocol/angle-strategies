{
  "language": "Solidity",
  "sources": {
    "contracts/external/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../interfaces/IAccessControl.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControl`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == _msgSender(), \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title IAccessControl\n/// @author Forked from OpenZeppelin\n/// @notice Interface for `AccessControl` contracts\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/strategies/BaseStrategyEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../external/AccessControl.sol\";\nimport \"../external/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IPoolManager.sol\";\n\n/// @title BaseStrategyEvents\n/// @author Angle Core Team\n/// @notice Events used in the abstract `BaseStrategy` contract\ncontract BaseStrategyEvents {\n    // So indexers can keep track of this\n    event Harvested(uint256 profit, uint256 loss, uint256 debtPayment, uint256 debtOutstanding);\n\n    event UpdatedMinReportDelayed(uint256 delay);\n\n    event UpdatedMaxReportDelayed(uint256 delay);\n\n    event UpdatedDebtThreshold(uint256 debtThreshold);\n\n    event UpdatedRewards(address rewards);\n\n    event UpdatedIsRewardActivated(bool activated);\n\n    event UpdatedRewardAmountAndMinimumAmountMoved(uint256 _rewardAmount, uint256 _minimumAmountMoved);\n\n    event EmergencyExitActivated();\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/external/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IAccessControl.sol\";\n\n/**\n * @dev This contract is fully forked from OpenZeppelin `AccessControlUpgradeable`.\n * The only difference is the removal of the ERC165 implementation as it's not\n * needed in Angle.\n *\n * Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, IAccessControl {\n    function __AccessControl_init() internal initializer {\n        __AccessControl_init_unchained();\n    }\n\n    function __AccessControl_init_unchained() internal initializer {}\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == msg.sender, \"71\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) internal {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./IAccessControl.sol\";\n\n/// @title IStrategy\n/// @author Inspired by Yearn with slight changes from Angle Core Team\n/// @notice Interface for yield farming strategies\ninterface IStrategy is IAccessControl {\n    function estimatedAPR() external view returns (uint256);\n\n    function poolManager() external view returns (address);\n\n    function want() external view returns (address);\n\n    function isActive() external view returns (bool);\n\n    function estimatedTotalAssets() external view returns (uint256);\n\n    function harvestTrigger(uint256 callCost) external view returns (bool);\n\n    function harvest() external;\n\n    function withdraw(uint256 _amountNeeded) external returns (uint256 amountFreed, uint256 _loss);\n\n    function setEmergencyExit() external;\n\n    function addGuardian(address _guardian) external;\n\n    function revokeGuardian(address _guardian) external;\n}\n"
    },
    "contracts/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n// Struct for the parameters associated to a strategy interacting with a collateral `PoolManager`\n// contract\nstruct StrategyParams {\n    // Timestamp of last report made by this strategy\n    // It is also used to check if a strategy has been initialized\n    uint256 lastReport;\n    // Total amount the strategy is expected to have\n    uint256 totalStrategyDebt;\n    // The share of the total assets in the `PoolManager` contract that the `strategy` can access to.\n    uint256 debtRatio;\n}\n\n/// @title IPoolManagerFunctions\n/// @author Angle Core Team\n/// @notice Interface for the collateral poolManager contracts handling each one type of collateral for\n/// a given stablecoin\n/// @dev Only the functions used in other contracts of the protocol are left here\ninterface IPoolManagerFunctions {\n    // ============================ Yield Farming ==================================\n\n    function creditAvailable() external view returns (uint256);\n\n    function debtOutstanding() external view returns (uint256);\n\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtPayment\n    ) external;\n\n    // ============================= Getters =======================================\n\n    function getBalance() external view returns (uint256);\n\n    function getTotalAsset() external view returns (uint256);\n}\n\n/// @title IPoolManager\n/// @author Angle Core Team\n/// @notice Previous interface with additionnal getters for public variables and mappings\n/// @dev Used in other contracts of the protocol\ninterface IPoolManager is IPoolManagerFunctions {\n    function stableMaster() external view returns (address);\n\n    function perpetualManager() external view returns (address);\n\n    function token() external view returns (address);\n\n    function totalDebt() external view returns (uint256);\n\n    function strategies(address _strategy) external view returns (StrategyParams memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/GenericLenderBaseUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../../external/AccessControlUpgradeable.sol\";\n\nimport \"../../../interfaces/IGenericLender.sol\";\nimport \"../../../interfaces/IPoolManager.sol\";\nimport \"../../../interfaces/IStrategy.sol\";\n\n/// @title GenericLenderBaseUpgradeable\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat/tree/master/contracts/GenericLender\n/// @notice A base contract to build contracts that lend assets to protocols\nabstract contract GenericLenderBaseUpgradeable is IGenericLender, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    // ======================= References to contracts =============================\n\n    address internal constant oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n\n    // ========================= References and Parameters =========================\n\n    string public override lenderName;\n    /// @notice Reference to the protocol's collateral poolManager\n    IPoolManager public poolManager;\n    /// @notice Reference to the `Strategy`\n    address public override strategy;\n    /// @notice Reference to the token lent\n    IERC20 public want;\n    /// @notice Base of the asset handled by the lender\n    uint256 public wantBase;\n\n    // ================================ Errors =====================================\n\n    error ErrorSwap();\n    error IncompatibleLengths();\n    error ProtectedToken();\n    error TooSmallAmount();\n\n    // ================================ Initializer ================================\n\n    /// @notice Initalizer of the `GenericLenderBase`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _name Name of the lender\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param keeperList List of keeper addresses\n    function _initialize(\n        address _strategy,\n        string memory _name,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList\n    ) internal initializer {\n        strategy = _strategy;\n        // The corresponding `PoolManager` is inferred from the `Strategy`\n        poolManager = IPoolManager(IStrategy(strategy).poolManager());\n        want = IERC20(poolManager.token());\n        lenderName = _name;\n\n        _setupRole(GUARDIAN_ROLE, address(poolManager));\n        for (uint256 i = 0; i < governorList.length; i++) {\n            _setupRole(GUARDIAN_ROLE, governorList[i]);\n        }\n\n        _setupRole(KEEPER_ROLE, guardian);\n        for (uint256 i = 0; i < keeperList.length; i++) {\n            _setupRole(KEEPER_ROLE, keeperList[i]);\n        }\n\n        _setRoleAdmin(KEEPER_ROLE, GUARDIAN_ROLE);\n\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(STRATEGY_ROLE, _strategy);\n        _setRoleAdmin(GUARDIAN_ROLE, STRATEGY_ROLE);\n        _setRoleAdmin(STRATEGY_ROLE, GUARDIAN_ROLE);\n        wantBase = 10**IERC20Metadata(address(want)).decimals();\n        want.safeApprove(_strategy, type(uint256).max);\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    // ============================ View Functions =================================\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate\n    function apr() external view override returns (uint256) {\n        return _apr();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate weighted by a factor\n    function weightedApr() external view override returns (uint256) {\n        uint256 a = _apr();\n        return a * _nav();\n    }\n\n    /// @notice Helper function to get the current total of assets managed by the lender.\n    function nav() external view override returns (uint256) {\n        return _nav();\n    }\n\n    /// @notice Check if assets are currently managed by the lender\n    /// @dev We're considering that the strategy has no assets if it has less than 10 of the\n    /// underlying asset in total to avoid the case where there is dust remaining on the lending market we cannot\n    /// withdraw everything\n    function hasAssets() external view override returns (bool) {\n        return _nav() > 10 * wantBase;\n    }\n\n    /// @notice See `nav`\n    function _nav() internal view returns (uint256) {\n        return want.balanceOf(address(this)) + underlyingBalanceStored();\n    }\n\n    /// @notice See `apr`\n    function _apr() internal view virtual returns (uint256);\n\n    /// @notice Returns the current balance invested on the lender and related staking contracts\n    function underlyingBalanceStored() public view virtual returns (uint256 balance);\n\n    // ============================ Governance Functions ===========================\n\n    /// @notice Override this to add all tokens/tokenized positions this contract\n    /// manages on a *persistent* basis (e.g. not just for swapping back to\n    /// want ephemerally).\n    ///\n    /// Example:\n    /// ```\n    ///    function _protectedTokens() internal override view returns (address[] memory) {\n    ///      address[] memory protected = new address[](3);\n    ///      protected[0] = tokenA;\n    ///      protected[1] = tokenB;\n    ///      protected[2] = tokenC;\n    ///      return protected;\n    ///    }\n    /// ```\n    function _protectedTokens() internal view virtual returns (address[] memory);\n\n    /// @notice\n    /// Removes tokens from this Strategy that are not the type of tokens\n    /// managed by this Strategy. This may be used in case of accidentally\n    /// sending the wrong kind of token to this Strategy.\n    ///\n    /// Tokens will be sent to `governance()`.\n    ///\n    /// This will fail if an attempt is made to sweep `want`, or any tokens\n    /// that are protected by this Strategy.\n    ///\n    /// This may only be called by governance.\n    /// @param _token The token to transfer out of this poolManager.\n    /// @param to Address to send the tokens to.\n    /// @dev\n    /// Implement `_protectedTokens()` to specify any additional tokens that\n    /// should be protected from sweeping in addition to `want`.\n    function sweep(address _token, address to) external override onlyRole(GUARDIAN_ROLE) {\n        address[] memory __protectedTokens = _protectedTokens();\n        for (uint256 i = 0; i < __protectedTokens.length; i++)\n            if (_token == __protectedTokens[i]) revert ProtectedToken();\n\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\n    }\n\n    /// @notice Changes allowance of a set of tokens to addresses\n    /// @param tokens Addresses of the tokens for which approvals should be made\n    /// @param spenders Addresses to approve\n    /// @param amounts Approval amounts for each address\n    function changeAllowance(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        uint256[] calldata amounts\n    ) external onlyRole(GUARDIAN_ROLE) {\n        if (tokens.length != spenders.length || tokens.length != amounts.length) revert IncompatibleLengths();\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 currentAllowance = tokens[i].allowance(address(this), address(spenders[i]));\n            if (currentAllowance < amounts[i]) {\n                IERC20(address(tokens[i])).safeIncreaseAllowance(address(spenders[i]), amounts[i] - currentAllowance);\n            } else if (currentAllowance > amounts[i]) {\n                IERC20(address(tokens[i])).safeDecreaseAllowance(address(spenders[i]), currentAllowance - amounts[i]);\n            }\n        }\n    }\n\n    /// @notice Swap earned _stkAave or Aave for `want` through 1Inch\n    /// @param minAmountOut Minimum amount of `want` to receive for the swap to happen\n    /// @param payload Bytes needed for 1Inch API\n    /// @dev In the case of a contract lending to Aave, tokens swapped should typically be: _stkAave -> `want` or Aave -> `want`\n    function sellRewards(uint256 minAmountOut, bytes memory payload) external onlyRole(KEEPER_ROLE) {\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        uint256 amountOut = abi.decode(result, (uint256));\n        if (amountOut < minAmountOut) revert TooSmallAmount();\n    }\n\n    /// @notice Internal function used for error handling\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert ErrorSwap();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IGenericLender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\n\nimport \"./IAccessControl.sol\";\n\n/// @title IGenericLender\n/// @author Yearn with slight modifications from Angle Core Team\n/// @dev Interface for the `GenericLender` contract, the base interface for contracts interacting\n/// with lending and yield farming platforms\ninterface IGenericLender is IAccessControl {\n    function lenderName() external view returns (string memory);\n\n    function nav() external view returns (uint256);\n\n    function strategy() external view returns (address);\n\n    function apr() external view returns (uint256);\n\n    function weightedApr() external view returns (uint256);\n\n    function withdraw(uint256 amount) external returns (uint256);\n\n    function emergencyWithdraw(uint256 amount) external;\n\n    function deposit() external;\n\n    function withdrawAll() external returns (bool);\n\n    function hasAssets() external view returns (bool);\n\n    function aprAfterDeposit(uint256 amount) external view returns (uint256);\n\n    function sweep(address _token, address to) external;\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/GenericCompoundUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../../../interfaces/external/compound/CErc20I.sol\";\nimport \"../../../interfaces/external/compound/IComptroller.sol\";\nimport \"../../../interfaces/external/compound/InterestRateModel.sol\";\n\nimport \"./GenericLenderBaseUpgradeable.sol\";\n\n/// @title GenericCompoundV2\n/// @author Forked from here: https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/master/contracts/GenericLender/GenericCompound.sol\ncontract GenericCompoundUpgradeable is GenericLenderBaseUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    uint256 public constant BLOCKS_PER_YEAR = 2_350_000;\n\n    AggregatorV3Interface public constant oracle = AggregatorV3Interface(0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5);\n    IComptroller public constant comptroller = IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n    address public constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\n    // ======================== References to contracts ============================\n\n    CErc20I public cToken;\n\n    // =============================== Errors ======================================\n\n    error FailedToMint();\n    error FailedToRecoverETH();\n    error FailedToRedeem();\n    error InvalidOracleValue();\n    error WrongCToken();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Initializer of the `GenericCompound`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param _cToken Address of the cToken\n    /// @param governorList List of addresses with governor privilege\n    /// @param keeperList List of addresses with keeper privilege\n    /// @param guardian Address of the guardian\n    function initialize(\n        address _strategy,\n        string memory _name,\n        address _cToken,\n        address[] memory governorList,\n        address[] memory keeperList,\n        address guardian\n    ) external {\n        _initialize(_strategy, _name, governorList, guardian, keeperList);\n\n        cToken = CErc20I(_cToken);\n        if (CErc20I(_cToken).underlying() != address(want)) revert WrongCToken();\n\n        want.safeApprove(_cToken, type(uint256).max);\n        IERC20(comp).safeApprove(oneInch, type(uint256).max);\n    }\n\n    // ===================== External Strategy Functions ===========================\n\n    /// @notice Deposits the current balance of the contract to the lending platform\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        if (cToken.mint(balance) != 0) revert FailedToMint();\n    }\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount The amount the caller wants to withdraw\n    /// @return Amount actually withdrawn\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @notice Withdraws as much as possible from the lending platform\n    /// @return Whether everything was withdrawn or not\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    // ========================== External View Functions ==========================\n\n    /// @notice Helper function the current balance of cTokens\n    function underlyingBalanceStored() public view override returns (uint256 balance) {\n        uint256 currentCr = cToken.balanceOf(address(this));\n        if (currentCr == 0) {\n            balance = 0;\n        } else {\n            //The current exchange rate as an unsigned integer, scaled by 1e18.\n            balance = (currentCr * cToken.exchangeRateStored()) / 1e18;\n        }\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// of `amount`\n    /// @param amount Amount to add to the lending platform, and that we want to take into account\n    /// in the apr computation\n    function aprAfterDeposit(uint256 amount) external view override returns (uint256) {\n        uint256 cashPrior = want.balanceOf(address(cToken));\n\n        uint256 borrows = cToken.totalBorrows();\n\n        uint256 reserves = cToken.totalReserves();\n\n        uint256 reserverFactor = cToken.reserveFactorMantissa();\n\n        InterestRateModel model = cToken.interestRateModel();\n\n        // The supply rate is derived from the borrow rate, reserve factor and the amount of total borrows.\n        uint256 supplyRate = model.getSupplyRate(cashPrior + amount, borrows, reserves, reserverFactor);\n        // Adding the yield from comp\n        return supplyRate * BLOCKS_PER_YEAR + _incentivesRate(amount);\n    }\n\n    // ================================= Governance ================================\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the `PoolManager`\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or if the amount withdrawn is correct\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        // Do not care about errors here, what is important is to withdraw what is possible\n        cToken.redeemUnderlying(amount);\n\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    // ============================= Internal Functions ============================\n\n    /// @notice See `apr`\n    function _apr() internal view override returns (uint256) {\n        return cToken.supplyRatePerBlock() * BLOCKS_PER_YEAR + _incentivesRate(0);\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 balanceUnderlying = cToken.balanceOfUnderlying(address(this));\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            // Can't withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        // Not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(cToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n\n            if (toWithdraw <= liquidity) {\n                // We can take all\n                if (cToken.redeemUnderlying(toWithdraw) != 0) revert FailedToRedeem();\n            } else {\n                // Take all we can\n                if (cToken.redeemUnderlying(liquidity) != 0) revert FailedToRedeem();\n            }\n        }\n        address[] memory holders = new address[](1);\n        CTokenI[] memory cTokens = new CTokenI[](1);\n        holders[0] = address(this);\n        cTokens[0] = cToken;\n        comptroller.claimComp(holders, cTokens, true, true);\n\n        looseBalance = want.balanceOf(address(this));\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice Calculates APR from Compound's Liquidity Mining Program\n    /// @param amountToAdd Amount to add to the `totalSupplyInWant` (for the `aprAfterDeposit` function)\n    function _incentivesRate(uint256 amountToAdd) internal view returns (uint256) {\n        uint256 supplySpeed = comptroller.compSupplySpeeds(address(cToken));\n        uint256 totalSupplyInWant = (cToken.totalSupply() * cToken.exchangeRateStored()) / 1e18 + amountToAdd;\n        // `supplySpeed` is in `COMP` unit -> the following operation is going to put it in `want` unit\n        supplySpeed = _comptoWant(supplySpeed);\n        uint256 incentivesRate;\n        // Added for testing purposes and to handle the edge case where there is nothing left in a market\n        if (totalSupplyInWant == 0) {\n            incentivesRate = supplySpeed * BLOCKS_PER_YEAR;\n        } else {\n            // `incentivesRate` is expressed in base 18 like all APR\n            incentivesRate = (supplySpeed * BLOCKS_PER_YEAR * 1e18) / totalSupplyInWant;\n        }\n        return (incentivesRate * 9500) / 10000; // 95% of estimated APR to avoid overestimations\n    }\n\n    /// @notice Estimates the value of `_amount` COMP tokens\n    /// @param _amount Amount of comp to compute the `want` price of\n    /// @dev This function uses a ChainLink oracle to easily compute the price\n    function _comptoWant(uint256 _amount) internal view returns (uint256) {\n        if (_amount == 0) {\n            return 0;\n        }\n        (uint80 roundId, int256 ratio, , , uint80 answeredInRound) = oracle.latestRoundData();\n        if (ratio == 0 || roundId > answeredInRound) revert InvalidOracleValue();\n        uint256 castedRatio = uint256(ratio);\n\n        // Checking whether we should multiply or divide by the ratio computed\n        return (_amount * castedRatio * wantBase) / 1e26;\n    }\n\n    /// @notice Specifies the token managed by this contract during normal operation\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(cToken);\n        return protected;\n    }\n\n    /// @notice Recovers ETH from the contract\n    /// @param amount Amount to be recovered\n    function recoverETH(address to, uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        if (!payable(to).send(amount)) revert FailedToRecoverETH();\n    }\n\n    receive() external payable {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/interfaces/external/compound/CErc20I.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./CTokenI.sol\";\n\ninterface CErc20I is CTokenI {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./CTokenI.sol\";\n\ninterface IComptroller {\n    function compSupplySpeeds(address cToken) external view returns (uint256);\n\n    function claimComp(\n        address[] memory holders,\n        CTokenI[] memory cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n}\n"
    },
    "contracts/interfaces/external/compound/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\ninterface InterestRateModel {\n    /**\n     * @notice Calculates the current supply interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n\n    // Rinkeby function\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 _reserves\n    ) external view returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/CTokenI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\nimport \"./InterestRateModel.sol\";\n\ninterface CTokenI {\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function interestRateModel() external view returns (InterestRateModel);\n\n    function totalReserves() external view returns (uint256);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/compound/CEtherI.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"./CTokenI.sol\";\n\ninterface CEtherI is CTokenI {\n    function mint() external payable;\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/GenericAaveUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport { IStakedAave, IReserveInterestRateStrategy } from \"../../../interfaces/external/aave/IAave.sol\";\nimport \"../../../interfaces/external/aave/IAaveToken.sol\";\nimport \"../../../interfaces/external/aave/IProtocolDataProvider.sol\";\nimport \"../../../interfaces/external/aave/ILendingPool.sol\";\nimport \"./GenericLenderBaseUpgradeable.sol\";\n\n/// @title GenericAave\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat/blob/master/contracts/GenericLender/GenericAave.sol\n/// @notice A contract to lend any supported ERC20 to Aave and potentially stake them in an external staking contract\n/// @dev This contract is just a base implementation which can be overriden depending on the staking contract on which to stake\n/// or not the aTokens\nabstract contract GenericAaveUpgradeable is GenericLenderBaseUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ======================== Reference to contract ==============================\n    AggregatorV3Interface private constant oracle = AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n\n    // ========================== Aave Protocol Addresses ==========================\n\n    address private constant _aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n    IStakedAave private constant _stkAave = IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n    IAaveIncentivesController private constant _incentivesController =\n        IAaveIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\n    ILendingPool internal constant _lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n    IProtocolDataProvider private constant _protocolDataProvider =\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\n\n    // ========================= Constants and Parameters ==========================\n    uint256 public cooldownSeconds;\n    uint256 public unstakeWindow;\n    bool public cooldownStkAave;\n    bool public isIncentivised;\n    IAToken internal _aToken;\n    uint256 internal constant _SECONDS_IN_YEAR = 365 days;\n\n    // =================================== Event ===================================\n\n    event IncentivisedUpdated(bool _isIncentivised);\n\n    // =================================== Error ===================================\n\n    error PoolNotIncentivized();\n\n    // ================================ Constructor ================================\n\n    /// @notice Initializer of the `GenericAave`\n    /// @param _strategy Reference to the strategy using this lender\n    /// @param name Name of the lender\n    /// @param _isIncentivised Whether the corresponding token is incentivized on Aave or not\n    /// @param governorList List of addresses with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param keeperList List of addresses with keeper privilege\n    function initializeAave(\n        address _strategy,\n        string memory name,\n        bool _isIncentivised,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList\n    ) public {\n        _initialize(_strategy, name, governorList, guardian, keeperList);\n\n        _setAavePoolVariables();\n        if (_isIncentivised && address(_aToken.getIncentivesController()) == address(0)) revert PoolNotIncentivized();\n        isIncentivised = _isIncentivised;\n        cooldownStkAave = true;\n        IERC20(address(want)).safeApprove(address(_lendingPool), type(uint256).max);\n        // Approve swap router spend\n        IERC20(address(_stkAave)).safeApprove(oneInch, type(uint256).max);\n        IERC20(address(_aave)).safeApprove(oneInch, type(uint256).max);\n    }\n\n    // ============================= External Functions ============================\n\n    /// @notice Deposits the current balance to the lending platform\n    function deposit() external override onlyRole(STRATEGY_ROLE) {\n        uint256 balance = want.balanceOf(address(this));\n        // Aave doesn't allow null deposits\n        if (balance == 0) return;\n        _deposit(balance);\n        // We don't stake balance but the whole aTokenBalance\n        // if some dust has been kept idle\n        _stake(_balanceAtoken());\n    }\n\n    /// @notice Withdraws a given amount from lender\n    /// @param amount Amount to withdraw\n    /// @return Amount actually withdrawn\n    function withdraw(uint256 amount) external override onlyRole(STRATEGY_ROLE) returns (uint256) {\n        return _withdraw(amount);\n    }\n\n    /// @notice Withdraws as much as possible in case of emergency and sends it to the `PoolManager`\n    /// @param amount Amount to withdraw\n    /// @dev Does not check if any error occurs or if the amount withdrawn is correct\n    function emergencyWithdraw(uint256 amount) external override onlyRole(GUARDIAN_ROLE) {\n        _unstake(amount);\n        _lendingPool.withdraw(address(want), amount, address(this));\n        want.safeTransfer(address(poolManager), want.balanceOf(address(this)));\n    }\n\n    /// @notice Withdraws as much as possible\n    function withdrawAll() external override onlyRole(STRATEGY_ROLE) returns (bool) {\n        uint256 invested = _nav();\n        uint256 returned = _withdraw(invested);\n        return returned >= invested;\n    }\n\n    /// @notice Claim earned stkAAVE\n    /// @dev stkAAVE require a \"cooldown\" period of 10 days before being claimed\n    function claimRewards() external onlyRole(KEEPER_ROLE) {\n        _claimRewards();\n    }\n\n    /// @notice Triggers the cooldown on Aave for this contract\n    function cooldown() external onlyRole(KEEPER_ROLE) {\n        _stkAave.cooldown();\n    }\n\n    /// @notice Retrieves lending pool variables like the `COOLDOWN_SECONDS` or the `UNSTAKE_WINDOW` on Aave\n    /// @dev No access control is needed here because values are fetched from Aave directly\n    /// @dev We expect the values concerned not to be often modified\n    function setAavePoolVariables() external {\n        _setAavePoolVariables();\n    }\n\n    // ========================== External Setter Functions ========================\n\n    /// @notice Toggle isIncentivised state, to let know the lender if it should harvest aave rewards\n    function toggleIsIncentivised() external onlyRole(GUARDIAN_ROLE) {\n        isIncentivised = !isIncentivised;\n    }\n\n    /// @notice Toggle cooldownStkAave state, which allow or not to call the coolDown stkAave each time rewards are claimed\n    function toggleCooldownStkAave() external onlyRole(GUARDIAN_ROLE) {\n        cooldownStkAave = !cooldownStkAave;\n    }\n\n    // =========================== External View Functions =========================\n\n    /// @notice Returns the current balance of aTokens\n    function underlyingBalanceStored() public view override returns (uint256 balance) {\n        balance = _balanceAtoken() + _stakedBalance();\n    }\n\n    /// @notice Returns an estimation of the current Annual Percentage Rate after a new deposit\n    /// @param extraAmount The amount to add to the lending platform\n    function aprAfterDeposit(uint256 extraAmount) external view override returns (uint256) {\n        // i need to calculate new supplyRate after Deposit (when deposit has not been done yet)\n        DataTypes.ReserveData memory reserveData = _lendingPool.getReserveData(address(want));\n\n        (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            ,\n            ,\n            ,\n            uint256 averageStableBorrowRate,\n            ,\n            ,\n\n        ) = _protocolDataProvider.getReserveData(address(want));\n\n        uint256 newLiquidity = availableLiquidity + extraAmount;\n\n        (, , , , uint256 reserveFactor, , , , , ) = _protocolDataProvider.getReserveConfigurationData(address(want));\n\n        (uint256 newLiquidityRate, , ) = IReserveInterestRateStrategy(reserveData.interestRateStrategyAddress)\n            .calculateInterestRates(\n                address(want),\n                newLiquidity,\n                totalStableDebt,\n                totalVariableDebt,\n                averageStableBorrowRate,\n                reserveFactor\n            );\n        uint256 incentivesRate = _incentivesRate(newLiquidity + totalStableDebt + totalVariableDebt); // total supplied liquidity in Aave v2\n        uint256 stakingApr = _stakingApr(extraAmount);\n\n        return newLiquidityRate / 1e9 + incentivesRate + stakingApr; // divided by 1e9 to go from Ray to Wad\n    }\n\n    // =========================== Internal Functions ==============================\n\n    /// @notice Internal version of the `claimRewards` function\n    function _claimRewards() internal returns (uint256 stkAaveBalance) {\n        stkAaveBalance = _balanceOfStkAave();\n        // If it's the claim period claim\n        if (stkAaveBalance > 0 && _checkCooldown() == 1) {\n            // redeem AAVE from _stkAave\n            _stkAave.claimRewards(address(this), type(uint256).max);\n            _stkAave.redeem(address(this), stkAaveBalance);\n        }\n\n        address[] memory claimOnTokens = new address[](1);\n        claimOnTokens[0] = address(_aToken);\n        // claim _stkAave from lending and borrowing, this will reset the cooldown\n        _incentivesController.claimRewards(claimOnTokens, type(uint256).max, address(this));\n\n        stkAaveBalance = _balanceOfStkAave();\n\n        // request start of cooldown period, if there's no cooldown in progress\n        if (cooldownStkAave && stkAaveBalance > 0 && _checkCooldown() == 0) {\n            _stkAave.cooldown();\n        }\n    }\n\n    /// @notice Returns the `StkAAVE` balance\n    function _balanceOfStkAave() internal view returns (uint256) {\n        return IERC20(address(_stkAave)).balanceOf(address(this));\n    }\n\n    /// @notice Returns the `aToken` balance\n    function _balanceAtoken() internal view returns (uint256) {\n        return _aToken.balanceOf(address(this));\n    }\n\n    /// @notice Estimate the amount of `want` we will get out by swapping it for AAVE\n    /// @param amount Amount of AAVE we want to exchange (in base 18)\n    /// @return amount Amount of `want` we are getting\n    /// @dev Uses Chainlink spot price. Return value will be in base of `want` (6 for USDC)\n    function _estimatedStkAaveToWant(uint256 amount) internal view returns (uint256) {\n        (, int256 aavePriceUSD, , , ) = oracle.latestRoundData(); // stkAavePriceUSD is in base 8\n        // `aavePriceUSD` is in base 8, so ultimately we need to divide by `1e(18+8)\n        return (uint256(aavePriceUSD) * amount * wantBase) / 1e26;\n    }\n\n    /// @notice See `apr`\n    function _apr() internal view override returns (uint256) {\n        (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            ,\n            ,\n            ,\n            ,\n            ,\n\n        ) = _protocolDataProvider.getReserveData(address(want));\n        uint256 incentivesRate = _incentivesRate(availableLiquidity + totalStableDebt + totalVariableDebt); // total supplied liquidity in Aave v2\n        uint256 stakingApr = _stakingApr(0);\n\n        return liquidityRate / 10**9 + incentivesRate + stakingApr;\n    }\n\n    /// @notice Calculates APR from Liquidity Mining Program\n    /// @param totalLiquidity Total liquidity available in the pool\n    function _incentivesRate(uint256 totalLiquidity) internal view returns (uint256) {\n        // only returns != 0 if the incentives are in place at the moment.\n        // it will fail if the isIncentivised is set to true but there are no incentives\n        if (isIncentivised && block.timestamp < _incentivesController.getDistributionEnd() && totalLiquidity > 0) {\n            uint256 _emissionsPerSecond;\n            (, _emissionsPerSecond, ) = _incentivesController.getAssetData(address(_aToken));\n            if (_emissionsPerSecond > 0) {\n                uint256 emissionsInWant = _estimatedStkAaveToWant(_emissionsPerSecond); // amount of emissions in want\n                uint256 incentivesRate = (emissionsInWant * _SECONDS_IN_YEAR * 1e18) / totalLiquidity; // APRs are in 1e18\n\n                return (incentivesRate * 9500) / 10000; // 95% of estimated APR to avoid overestimations\n            }\n        }\n        return 0;\n    }\n\n    /// @notice See `withdraw`\n    function _withdraw(uint256 amount) internal returns (uint256) {\n        uint256 stakedBalance = _stakedBalance();\n        uint256 balanceUnderlying = _balanceAtoken();\n        uint256 looseBalance = want.balanceOf(address(this));\n        uint256 total = stakedBalance + balanceUnderlying + looseBalance;\n\n        if (amount > total) {\n            //cant withdraw more than we own\n            amount = total;\n        }\n\n        if (looseBalance >= amount) {\n            want.safeTransfer(address(strategy), amount);\n            return amount;\n        }\n\n        // Not state changing but OK because of previous call\n        uint256 liquidity = want.balanceOf(address(_aToken));\n\n        if (liquidity > 1) {\n            uint256 toWithdraw = amount - looseBalance;\n            if (toWithdraw <= liquidity) {\n                //we can take all\n                uint256 freedAmount = _unstake(toWithdraw);\n                _lendingPool.withdraw(address(want), freedAmount, address(this));\n            } else {\n                //take all we can\n                uint256 freedAmount = _unstake(liquidity);\n                _lendingPool.withdraw(address(want), freedAmount, address(this));\n            }\n        }\n        looseBalance = want.balanceOf(address(this));\n\n        want.safeTransfer(address(strategy), looseBalance);\n        return looseBalance;\n    }\n\n    /// @notice See `deposit`\n    function _deposit(uint256 amount) internal {\n        ILendingPool lp = _lendingPool;\n        // NOTE: Checks if allowance is enough and acts accordingly\n        // allowance might not be enough if\n        //     i) initial allowance has been used (should take years)\n        //     ii) _lendingPool contract address has changed (Aave updated the contract address)\n        if (want.allowance(address(this), address(lp)) < amount) {\n            IERC20(address(want)).safeApprove(address(lp), 0);\n            IERC20(address(want)).safeApprove(address(lp), type(uint256).max);\n        }\n        lp.deposit(address(want), amount, address(this), 0);\n    }\n\n    /// @notice Internal version of the `_setAavePoolVariables`\n    function _setAavePoolVariables() internal {\n        (address aToken, , ) = _protocolDataProvider.getReserveTokensAddresses(address(want));\n        _aToken = IAToken(aToken);\n        cooldownSeconds = IStakedAave(_stkAave).COOLDOWN_SECONDS();\n        unstakeWindow = IStakedAave(_stkAave).UNSTAKE_WINDOW();\n    }\n\n    /// @notice Verifies the cooldown status for earned stkAAVE\n    /// @return cooldownStatus Status of the coolDown: if it is 0 then there is no cooldown Status, if it is 1 then\n    /// the strategy should claim the stkAave\n    function _checkCooldown() internal view returns (uint256 cooldownStatus) {\n        uint256 cooldownStartTimestamp = IStakedAave(_stkAave).stakersCooldowns(address(this));\n        uint256 nextClaimStartTimestamp = cooldownStartTimestamp + cooldownSeconds;\n        if (cooldownStartTimestamp == 0) {\n            return 0;\n        }\n        if (block.timestamp > nextClaimStartTimestamp && block.timestamp <= nextClaimStartTimestamp + unstakeWindow) {\n            return 1;\n        }\n        if (block.timestamp < nextClaimStartTimestamp) {\n            return 2;\n        }\n    }\n\n    /// @notice Specifies the token managed by this contract during normal operation\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](2);\n        protected[0] = address(want);\n        protected[1] = address(_aToken);\n        return protected;\n    }\n\n    // ========================= Virtual Functions ===========================\n\n    /// @notice Allows the lender to stake its aTokens in an external staking contract\n    /// @param amount Amount of aTokens to stake\n    /// @return Amount of aTokens actually staked\n    function _stake(uint256 amount) internal virtual returns (uint256);\n\n    /// @notice Allows the lender to unstake its aTokens from an external staking contract\n    /// @param amount Amount of aToken to unstake\n    /// @return Amount of aTokens actually unstaked\n    function _unstake(uint256 amount) internal virtual returns (uint256);\n\n    /// @notice Gets the amount of aTokens currently staked\n    function _stakedBalance() internal view virtual returns (uint256);\n\n    /// @notice Gets the APR from staking additional `amount` of aTokens in the associated staking\n    /// contract\n    /// @param amount Virtual amount to be staked\n    function _stakingApr(uint256 amount) internal view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/aave/IAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n}\n\ninterface IOptionalERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IPriceOracle {\n    function getAssetPrice(address _asset) external view returns (uint256);\n\n    function getAssetsPrices(address[] calldata _assets) external view returns (uint256[] memory);\n\n    function getSourceOfAsset(address _asset) external view returns (address);\n\n    function getFallbackOracle() external view returns (address);\n}\n\ninterface IStakedAave is IERC20 {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address) external view returns (uint256);\n\n    function COOLDOWN_SECONDS() external view returns (uint256);\n\n    function stakersCooldowns(address) external view returns (uint256);\n\n    function UNSTAKE_WINDOW() external view returns (uint256);\n}\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n    function baseVariableBorrowRate() external view returns (uint256);\n\n    function getMaxVariableBorrowRate() external view returns (uint256);\n\n    function stableRateSlope1() external view returns (uint256);\n\n    function stableRateSlope2() external view returns (uint256);\n\n    function variableRateSlope1() external view returns (uint256);\n\n    function variableRateSlope2() external view returns (uint256);\n\n    function OPTIMAL_UTILIZATION_RATE() external view returns (uint256);\n\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n\n    function calculateInterestRates(\n        address reserve,\n        address aToken,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n}\n"
    },
    "contracts/interfaces/external/aave/IAaveToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IAaveIncentivesController.sol\";\nimport \"./ILendingPool.sol\";\n\ninterface IScaledBalanceToken {\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     **/\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @dev Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled balance and the scaled total supply\n     **/\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n    /**\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n     * @return The scaled total supply\n     **/\n    function scaledTotalSupply() external view returns (uint256);\n}\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n **/\ninterface IVariableDebtToken is IERC20, IScaledBalanceToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param onBehalfOf The address of the user on which behalf minting has been performed\n     * @param value The amount to be minted\n     * @param index The last index of the reserve\n     **/\n    event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\n\n    /**\n     * @dev Mints debt token to the `onBehalfOf` address\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\n     * of credit delegate, or same as `onBehalfOf` otherwise\n     * @param onBehalfOf The address receiving the debt tokens\n     * @param amount The amount of debt being minted\n     * @param index The variable debt index of the reserve\n     * @return `true` if the the previous balance of the user is 0\n     **/\n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when variable debt is burnt\n     * @param user The user which debt has been burned\n     * @param amount The amount of debt being burned\n     * @param index The index of the user\n     **/\n    event Burn(address indexed user, uint256 amount, uint256 index);\n\n    /**\n     * @dev Burns user variable debt\n     * @param user The user which debt is burnt\n     * @param index The variable debt index of the reserve\n     **/\n    function burn(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n}\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n    /**\n     * @dev Emitted when an aToken is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param pool The address of the associated lending pool\n     * @param treasury The address of the treasury\n     * @param incentivesController The address of the incentives controller for this aToken\n     * @param aTokenDecimals the decimals of the underlying\n     * @param aTokenName the name of the aToken\n     * @param aTokenSymbol the symbol of the aToken\n     * @param params A set of encoded parameters for additional initialization\n     **/\n    event Initialized(\n        address indexed underlyingAsset,\n        address indexed pool,\n        address treasury,\n        address incentivesController,\n        uint8 aTokenDecimals,\n        string aTokenName,\n        string aTokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @dev Initializes the aToken\n     * @param pool The address of the lending pool where this aToken will be used\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @param incentivesController The smart contract managing potential incentives distribution\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n     * @param aTokenName The name of the aToken\n     * @param aTokenSymbol The symbol of the aToken\n     */\n    function initialize(\n        ILendingPool pool,\n        address treasury,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 aTokenDecimals,\n        string calldata aTokenName,\n        string calldata aTokenSymbol,\n        bytes calldata params\n    ) external;\n}\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param value The amount being\n     * @param index The new liquidity index of the reserve\n     **/\n    event Mint(address indexed from, uint256 value, uint256 index);\n\n    /**\n     * @dev Mints `amount` aTokens to `user`\n     * @param user The address receiving the minted tokens\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted after aTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param target The address that will receive the underlying\n     * @param value The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n    /**\n     * @dev Emitted during the transfer action\n     * @param from The user whose tokens are being transferred\n     * @param to The recipient\n     * @param value The amount being transferred\n     * @param index The new liquidity index of the reserve\n     **/\n    event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n    /**\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @param user The owner of the aTokens, getting them burned\n     * @param receiverOfUnderlying The address that will receive the underlying\n     * @param amount The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    function burn(\n        address user,\n        address receiverOfUnderlying,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Mints aTokens to the reserve treasury\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     */\n    function mintToTreasury(uint256 amount, uint256 index) external;\n\n    /**\n     * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n     * @param from The address getting liquidated, current owner of the aTokens\n     * @param to The recipient\n     * @param value The amount of tokens getting transferred\n     **/\n    function transferOnLiquidation(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    /**\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n     * assets in borrow(), withdraw() and flashLoan()\n     * @param user The recipient of the underlying\n     * @param amount The amount getting transferred\n     * @return The amount transferred\n     **/\n    function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n    /**\n     * @dev Invoked to execute actions on the aToken side after a repayment.\n     * @param user The user executing the repayment\n     * @param amount The amount getting repaid\n     **/\n    function handleRepayment(address user, uint256 amount) external;\n\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n\n    /**\n     * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     **/\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/interfaces/external/aave/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { ILendingPoolAddressesProvider } from \"./ILendingPool.sol\";\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n"
    },
    "contracts/interfaces/external/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { DataTypes } from \"./IAave.sol\";\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/external/aave/IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\ninterface IAaveIncentivesController {\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n\n    function getDistributionEnd() external view returns (uint256);\n\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function assets(address asset)\n        external\n        view\n        returns (\n            uint256 emissionPerSecond,\n            uint256 index,\n            uint256 lastUpdateTimestamp\n        );\n\n    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/GenericAaveNoStaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./GenericAaveUpgradeable.sol\";\n\n/// @title GenericAaveNoStaker\n/// @author  Angle Core Team\n/// @notice Only deposit onto Aave lendingPool with no staking\n/// @dev In this implementation, we just have to override the base functions with constant amounts as nothing is\n/// staked in an external contract\ncontract GenericAaveNoStaker is GenericAaveUpgradeable {\n    // ================================ Constructor ================================\n\n    /// @notice Wrapper on top of the `initializeAave` method\n    function initialize(\n        address _strategy,\n        string memory name,\n        bool _isIncentivised,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList\n    ) external {\n        initializeAave(_strategy, name, _isIncentivised, governorList, guardian, keeperList);\n    }\n\n    // =========================== Virtual Functions ===============================\n\n    function _stake(uint256) internal override returns (uint256) {}\n\n    function _unstake(uint256 amount) internal pure override returns (uint256) {\n        return amount;\n    }\n\n    /// @notice Gets current staked balance (e.g 0 if nothing is staked)\n    function _stakedBalance() internal pure override returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Get stakingAPR after staking an additional `amount`: in this case since nothing\n    /// is staked, it simply returns 0\n    function _stakingApr(uint256) internal pure override returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/strategies/StETHStrategy/StETHStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.12;\n\nimport \"../../interfaces/external/curve/IStableSwapPool.sol\";\nimport \"../../interfaces/external/lido/ISteth.sol\";\nimport \"../../interfaces/external/IWETH9.sol\";\nimport \"../BaseStrategyUpgradeable.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title StrategyStETHAcc\n/// @author Forked from https://github.com/Grandthrax/yearn-steth-acc/blob/master/contracts/Strategy.sol\n/// @notice A strategy designed to getting yield on wETH by putting ETH in Lido or Curve for stETH and exiting\n/// for wETH\ncontract StETHStrategy is BaseStrategyUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    /// @notice Current `apr` of the strategy: this apr needs to be manually filled by the strategist\n    /// and updated when Lido's APR changes. It is put like that as there is no easy way to compute Lido's APR\n    /// on-chain\n    /// @notice Base used is `BASE_PARAMS`\n    uint256 public apr;\n\n    /// @notice Reference to the Curve ETH/stETH\n    IStableSwapPool public stableSwapSTETH;\n    /// @notice Reference to wETH, it should normally be equal to `want`\n    IWETH9 public weth;\n    /// @notice Reference to the stETH token\n    ISteth public stETH;\n\n    address private _referral = 0xdC4e6DFe07EFCa50a197DF15D9200883eF4Eb1c8; //stratms. for recycling and redepositing\n    /// @notice Maximum trade size within the strategy\n    uint256 public maxSingleTrade;\n    /// @notice Parameter used for slippage protection\n    uint256 public constant DENOMINATOR = 10_000;\n    /// @notice Slippage parameter for the swaps on Curve: out of `DENOMINATOR`\n    uint256 public slippageProtectionOut; // = 50; //out of 10000. 50 = 0.5%\n\n    /// @notice ID of ETH in the Curve pool\n    int128 private constant _WETHID = 0;\n    /// @notice ID of stETH in the Curve pool\n    int128 private constant _STETHID = 1;\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param governor Address of the governance multisig with governor privilege\n    /// @param guardian Address of the guardian\n    /// @param keepers List of addresses of keepers\n    /// @param _stableSwapSTETH Address of the stETH/ETH Curve pool\n    /// @param _weth Address of wETH\n    /// @param _stETH Address of the stETH token\n    /// @param _apr Estimated apr on staked ETH\n    function initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers,\n        address _stableSwapSTETH,\n        address _weth,\n        ISteth _stETH,\n        uint256 _apr\n    ) external {\n        _initialize(_poolManager, governor, guardian, keepers);\n        require(address(want) == _weth, \"20\");\n        stableSwapSTETH = IStableSwapPool(_stableSwapSTETH);\n        weth = IWETH9(_weth);\n        stETH = ISteth(_stETH);\n        apr = _apr;\n        _stETH.approve(_stableSwapSTETH, type(uint256).max);\n        maxSingleTrade = 10_000 * 1e18;\n        slippageProtectionOut = 30;\n    }\n\n    /// @notice This contract gets ETH and so it needs this function\n    receive() external payable {}\n\n    // ========================== View Functions ===================================\n\n    /// @notice View function to check the total assets managed by the strategy\n    /// @dev We are purposely treating stETH and ETH as being equivalent.\n    /// This is for a few reasons. The main one is that we do not have a good way to value\n    /// stETH at any current time without creating exploit routes.\n    /// Currently you can mint eth for steth but can't burn steth for eth so need to sell.\n    /// Once eth 2.0 is merged you will be able to burn 1-1 as well.\n    /// The main downside here is that we will noramlly overvalue our position as we expect stETH\n    /// to trade slightly below peg. That means we will earn profit on deposits and take losses on withdrawals.\n    /// This may sound scary but it is the equivalent of using virtualprice in a curve lp.\n    /// As we have seen from many exploits, virtual pricing is safer than touch pricing.\n    function estimatedTotalAssets() public view override returns (uint256) {\n        return stethBalance() + wantBalance();\n    }\n\n    /// @notice Returns the wETH balance of the strategy\n    function wantBalance() public view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @notice Returns the stETH balance of the strategy\n    function stethBalance() public view returns (uint256) {\n        return stETH.balanceOf(address(this));\n    }\n\n    /// @notice The ETH APR of owning stETH\n    function estimatedAPR() external view returns (uint256) {\n        return apr;\n    }\n\n    // ========================== Strategy Functions ===============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt: it is an amount made available for the `PoolManager`\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        uint256 wantBal = wantBalance();\n        uint256 stethBal = stethBalance();\n        uint256 totalAssets = wantBal + stethBal;\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (totalAssets >= debt) {\n            _profit = totalAssets - debt;\n\n            uint256 toWithdraw = _profit + _debtOutstanding;\n            // If more should be withdrawn than what's in the strategy: we divest from Curve\n            if (toWithdraw > wantBal) {\n                // We step our withdrawals. Adjust max single trade to withdraw more\n                uint256 willWithdraw = Math.min(maxSingleTrade, toWithdraw - wantBal);\n                uint256 withdrawn = _divest(willWithdraw);\n                if (withdrawn < willWithdraw) {\n                    _loss = willWithdraw - withdrawn;\n                }\n            }\n            wantBal = wantBalance();\n\n            // Computing net off profit and loss\n            if (_profit >= _loss) {\n                _profit = _profit - _loss;\n                _loss = 0;\n            } else {\n                _profit = 0;\n                _loss = _loss - _profit;\n            }\n\n            // profit + _debtOutstanding must be <= wantbalance. Prioritise profit first\n            if (wantBal < _profit) {\n                _profit = wantBal;\n            } else if (wantBal < toWithdraw) {\n                _debtPayment = wantBal - _profit;\n            } else {\n                _debtPayment = _debtOutstanding;\n            }\n        } else {\n            _loss = debt - totalAssets;\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        _divest(stethBalance());\n        _amountFreed = wantBalance();\n    }\n\n    /// @notice Function called when harvesting to invest in stETH\n    /// Function used in other contracts, in this strategy it is useless\n    function _adjustPosition(uint256) internal override {\n        _adjustPosition();\n    }\n\n    /// @notice Function called when harvesting to invest in stETH\n    function _adjustPosition() internal override {\n        uint256 toInvest = wantBalance();\n        if (toInvest > 0) {\n            uint256 realInvest = Math.min(maxSingleTrade, toInvest);\n            _invest(realInvest);\n        }\n    }\n\n    /// @notice Invests `_amount` wETH in stETH\n    /// @param _amount Amount of wETH to put in stETH\n    /// @return The amount of stETH received from the investment\n    /// @dev This function chooses the optimal route between going to Lido directly or doing a swap on Curve\n    /// @dev This function automatically wraps wETH to ETH\n    function _invest(uint256 _amount) internal returns (uint256) {\n        uint256 before = stethBalance();\n        // Unwrapping the tokens\n        weth.withdraw(_amount);\n        // Test if we should buy from Curve instead of minting from Lido\n        uint256 out = stableSwapSTETH.get_dy(_WETHID, _STETHID, _amount);\n        if (out < _amount) {\n            // If we get less than one stETH per wETH we use Lido\n            stETH.submit{ value: _amount }(_referral);\n        } else {\n            // Otherwise, we do a Curve swap\n            stableSwapSTETH.exchange{ value: _amount }(_WETHID, _STETHID, _amount, _amount);\n        }\n\n        return stethBalance() - before;\n    }\n\n    /// @notice Divests stETH on Curve and gets wETH back to the strategy in exchange\n    /// @param _amount Amount of stETH to divest\n    /// @dev Curve is the only place to convert stETH to ETH\n    function _divest(uint256 _amount) internal returns (uint256) {\n        uint256 before = wantBalance();\n\n        // Computing slippage protection for the swap\n        uint256 slippageAllowance = (_amount * (DENOMINATOR - slippageProtectionOut)) / DENOMINATOR;\n        // Curve swap\n        stableSwapSTETH.exchange(_STETHID, _WETHID, _amount, slippageAllowance);\n\n        weth.deposit{ value: address(this).balance }();\n\n        return wantBalance() - before;\n    }\n\n    /// @notice Attempts to withdraw `_amountNeeded` from the strategy and lets the user decide if they take the loss or not\n    /// @param _amountNeeded Amount to withdraw from the strategy\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        override\n        returns (uint256 _liquidatedAmount, uint256 _loss)\n    {\n        uint256 wantBal = wantBalance();\n        if (wantBal < _amountNeeded) {\n            uint256 toWithdraw = _amountNeeded - wantBal;\n            uint256 withdrawn = _divest(toWithdraw);\n            if (withdrawn < toWithdraw) {\n                _loss = toWithdraw - withdrawn;\n            }\n        }\n\n        _liquidatedAmount = _amountNeeded - _loss;\n    }\n\n    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary\n\n    // Override this to add all tokens/tokenized positions this contract manages\n    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)\n    // NOTE: Do *not* include `want`, already included in `sweep` below\n    //\n    // Example:\n    //\n    //    function _protectedTokens() internal override view returns (address[] memory) {\n    //      address[] memory protected = new address[](3);\n    //      protected[0] = tokenA;\n    //      protected[1] = tokenB;\n    //      protected[2] = tokenC;\n    //      return protected;\n    //    }\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(stETH);\n\n        return protected;\n    }\n\n    // ============================ Governance =====================================\n\n    /// @notice Updates the referral code for Lido\n    /// @param newReferral Address of the new referral\n    function updateReferral(address newReferral) public onlyRole(GUARDIAN_ROLE) {\n        _referral = newReferral;\n    }\n\n    /// @notice Updates the size of a trade in the strategy\n    /// @param _maxSingleTrade New `maxSingleTrade` value\n    function updateMaxSingleTrade(uint256 _maxSingleTrade) public onlyRole(GUARDIAN_ROLE) {\n        maxSingleTrade = _maxSingleTrade;\n    }\n\n    /// @notice Changes the estimated APR of the strategy\n    /// @param _apr New strategy APR\n    function setApr(uint256 _apr) public onlyRole(GUARDIAN_ROLE) {\n        apr = _apr;\n    }\n\n    /// @notice Updates the maximum slippage protection parameter\n    /// @param _slippageProtectionOut New slippage protection parameter\n    function updateSlippageProtectionOut(uint256 _slippageProtectionOut) public onlyRole(GUARDIAN_ROLE) {\n        slippageProtectionOut = _slippageProtectionOut;\n    }\n\n    /// @notice Invests `_amount` in stETH\n    /// @param _amount Amount to invest\n    /// @dev This function allows to override the behavior that could be obtained through `harvest` calls\n    function invest(uint256 _amount) external onlyRole(GUARDIAN_ROLE) {\n        require(wantBalance() >= _amount);\n        uint256 realInvest = Math.min(maxSingleTrade, _amount);\n        _invest(realInvest);\n    }\n\n    /// @notice Rescues stuck ETH from the strategy\n    /// @dev This strategy should never have stuck eth, but let it just in case\n    function rescueStuckEth() external onlyRole(GUARDIAN_ROLE) {\n        weth.deposit{ value: address(this).balance }();\n    }\n\n    // ========================== Manager functions ================================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/IStableSwapPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// this interface doesn't wok with 3Pool as it doesn't return anything on add_liquidity, remove_liquidity_one_coin\n\ninterface IStableSwapPool is IERC20 {\n    function A() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(uint256[3] memory amounts, bool deposit) external view returns (uint256);\n\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[3] memory amounts, uint256 max_burn_amount) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/lido/ISteth.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISteth is IERC20 {\n    event Submitted(address sender, uint256 amount, address referral);\n\n    function submit(address) external payable returns (uint256);\n}\n"
    },
    "contracts/interfaces/external/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH9 is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/strategies/BaseStrategyUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./BaseStrategyEvents.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/// @title BaseStrategyUpgradeable\n/// @author Forked from https://github.com/yearn/yearn-managers/blob/master/contracts/BaseStrategy.sol\n/// @notice `BaseStrategyUpgradeable` implements all of the required functionalities to interoperate\n/// with the `PoolManager` Contract.\n/// @dev This contract should be inherited and the abstract methods implemented to adapt the `Strategy`\n/// to the particular needs it has to create a return.\nabstract contract BaseStrategyUpgradeable is BaseStrategyEvents, AccessControlUpgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**18;\n    uint256 public constant SECONDSPERYEAR = 31556952;\n\n    /// @notice Role for `PoolManager` only\n    bytes32 public constant POOLMANAGER_ROLE = keccak256(\"POOLMANAGER_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for keepers\n    bytes32 public constant KEEPER_ROLE = keccak256(\"KEEPER_ROLE\");\n\n    // ======================== References to contracts ============================\n\n    /// @notice Reference to the protocol's collateral `PoolManager`\n    IPoolManager public poolManager;\n\n    /// @notice Reference to the ERC20 farmed by this strategy\n    IERC20 public want;\n\n    /// @notice Base of the ERC20 token farmed by this strategy\n    uint256 public wantBase;\n\n    // ============================ Parameters =====================================\n\n    /// @notice Use this to adjust the threshold at which running a debt causes a\n    /// harvest trigger. See `setDebtThreshold()` for more details\n    uint256 public debtThreshold;\n\n    /// @notice See note on `setEmergencyExit()`\n    bool public emergencyExit;\n\n    // ============================ Errors =========================================\n\n    error InvalidToken();\n    error ZeroAddress();\n\n    // ============================ Constructor ====================================\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @notice Constructor of the `BaseStrategyUpgradeable`\n    /// @param _poolManager Address of the `PoolManager` lending collateral to this strategy\n    /// @param governor Governor address of the protocol\n    /// @param guardian Address of the guardian\n    function _initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers\n    ) internal initializer {\n        poolManager = IPoolManager(_poolManager);\n        want = IERC20(poolManager.token());\n        wantBase = 10**(IERC20Metadata(address(want)).decimals());\n        if (guardian == address(0) || governor == address(0) || governor == guardian) revert ZeroAddress();\n        // AccessControl\n        // Governor is guardian so no need for a governor role\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setupRole(POOLMANAGER_ROLE, address(_poolManager));\n        _setRoleAdmin(POOLMANAGER_ROLE, POOLMANAGER_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, POOLMANAGER_ROLE);\n\n        // Initializing roles first\n        for (uint256 i = 0; i < keepers.length; i++) {\n            if (keepers[i] == address(0)) revert ZeroAddress();\n            _setupRole(KEEPER_ROLE, keepers[i]);\n        }\n        _setRoleAdmin(KEEPER_ROLE, GUARDIAN_ROLE);\n\n        debtThreshold = 100 * BASE;\n        emergencyExit = false;\n        // Give `PoolManager` unlimited access (might save gas)\n        want.safeIncreaseAllowance(address(poolManager), type(uint256).max);\n    }\n\n    // ========================== Core functions ===================================\n\n    /// @notice Harvests the Strategy, recognizing any profits or losses and adjusting\n    /// the Strategy's position.\n    function harvest() external {\n        _report();\n        // Check if free returns are left, and re-invest them\n        _adjustPosition();\n    }\n\n    /// @notice Harvests the Strategy, recognizing any profits or losses and adjusting\n    /// the Strategy's position.\n    /// @param borrowInit Approximate optimal borrows to have faster convergence on the NR method\n    function harvest(uint256 borrowInit) external onlyRole(KEEPER_ROLE) {\n        _report();\n        // Check if free returns are left, and re-invest them, gives an hint on the borrow amount to the NR method\n        // to maximise revenue\n        _adjustPosition(borrowInit);\n    }\n\n    /// @notice Withdraws `_amountNeeded` to `poolManager`.\n    /// @param _amountNeeded How much `want` to withdraw.\n    /// @return amountFreed How much `want` withdrawn.\n    /// @return _loss Any realized losses\n    /// @dev This may only be called by the `PoolManager`\n    function withdraw(uint256 _amountNeeded)\n        external\n        onlyRole(POOLMANAGER_ROLE)\n        returns (uint256 amountFreed, uint256 _loss)\n    {\n        // Liquidate as much as possible `want` (up to `_amountNeeded`)\n        (amountFreed, _loss) = _liquidatePosition(_amountNeeded);\n        // Send it directly back (NOTE: Using `msg.sender` saves some gas here)\n        want.safeTransfer(msg.sender, amountFreed);\n        // NOTE: Reinvest anything leftover on next `tend`/`harvest`\n    }\n\n    // ============================ View functions =================================\n\n    /// @notice Provides an accurate estimate for the total amount of assets\n    /// (principle + return) that this Strategy is currently managing,\n    /// denominated in terms of `want` tokens.\n    /// This total should be \"realizable\" e.g. the total value that could\n    /// *actually* be obtained from this Strategy if it were to divest its\n    /// entire position based on current on-chain conditions.\n    /// @return The estimated total assets in this Strategy.\n    /// @dev Care must be taken in using this function, since it relies on external\n    /// systems, which could be manipulated by the attacker to give an inflated\n    /// (or reduced) value produced by this function, based on current on-chain\n    /// conditions (e.g. this function is possible to influence through\n    /// flashloan attacks, oracle manipulations, or other DeFi attack\n    /// mechanisms).\n    function estimatedTotalAssets() public view virtual returns (uint256);\n\n    /// @notice Provides an indication of whether this strategy is currently \"active\"\n    /// in that it is managing an active position, or will manage a position in\n    /// the future. This should correlate to `harvest()` activity, so that Harvest\n    /// events can be tracked externally by indexing agents.\n    /// @return True if the strategy is actively managing a position.\n    function isActive() public view returns (bool) {\n        return estimatedTotalAssets() > 0;\n    }\n\n    // ============================ Internal Functions =============================\n\n    /// @notice PrepareReturn the Strategy, recognizing any profits or losses\n    /// @dev In the rare case the Strategy is in emergency shutdown, this will exit\n    /// the Strategy's position.\n    /// @dev  When `_report()` is called, the Strategy reports to the Manager (via\n    /// `poolManager.report()`), so in some cases `harvest()` must be called in order\n    /// to take in profits, to borrow newly available funds from the Manager, or\n    /// otherwise adjust its position. In other cases `harvest()` must be\n    /// called to report to the Manager on the Strategy's position, especially if\n    /// any losses have occurred.\n    /// @dev As keepers may directly profit from this function, there may be front-running problems with miners bots,\n    /// we may have to put an access control logic for this function to only allow white-listed addresses to act\n    /// as keepers for the protocol\n    function _report() internal {\n        uint256 profit = 0;\n        uint256 loss = 0;\n        uint256 debtOutstanding = poolManager.debtOutstanding();\n        uint256 debtPayment = 0;\n        if (emergencyExit) {\n            // Free up as much capital as possible\n            uint256 amountFreed = _liquidateAllPositions();\n            if (amountFreed < debtOutstanding) {\n                loss = debtOutstanding - amountFreed;\n            } else if (amountFreed > debtOutstanding) {\n                profit = amountFreed - debtOutstanding;\n            }\n            debtPayment = debtOutstanding - loss;\n        } else {\n            // Free up returns for Manager to pull\n            (profit, loss, debtPayment) = _prepareReturn(debtOutstanding);\n        }\n        emit Harvested(profit, loss, debtPayment, debtOutstanding);\n\n        // Allows Manager to take up to the \"harvested\" balance of this contract,\n        // which is the amount it has earned since the last time it reported to\n        // the Manager.\n        poolManager.report(profit, loss, debtPayment);\n    }\n\n    /// @notice Performs any Strategy unwinding or other calls necessary to capture the\n    /// \"free return\" this Strategy has generated since the last time its core\n    /// position(s) were adjusted. Examples include unwrapping extra rewards.\n    /// This call is only used during \"normal operation\" of a Strategy, and\n    /// should be optimized to minimize losses as much as possible.\n    ///\n    /// This method returns any realized profits and/or realized losses\n    /// incurred, and should return the total amounts of profits/losses/debt\n    /// payments (in `want` tokens) for the Manager's accounting (e.g.\n    /// `want.balanceOf(this) >= _debtPayment + _profit`).\n    ///\n    /// `_debtOutstanding` will be 0 if the Strategy is not past the configured\n    /// debt limit, otherwise its value will be how far past the debt limit\n    /// the Strategy is. The Strategy's debt limit is configured in the Manager.\n    ///\n    /// NOTE: `_debtPayment` should be less than or equal to `_debtOutstanding`.\n    ///       It is okay for it to be less than `_debtOutstanding`, as that\n    ///       should only used as a guide for how much is left to pay back.\n    ///       Payments should be made to minimize loss from slippage, debt,\n    ///       withdrawal fees, etc.\n    ///\n    /// See `poolManager.debtOutstanding()`.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        );\n\n    /// @notice Performs any adjustments to the core position(s) of this Strategy given\n    /// what change the Manager made in the \"investable capital\" available to the\n    /// Strategy. Note that all \"free capital\" in the Strategy after the report\n    /// was made is available for reinvestment. Also note that this number\n    /// could be 0, and you should handle that scenario accordingly.\n    function _adjustPosition() internal virtual;\n\n    /// @notice same as _adjustPosition but with an initial parameters\n    function _adjustPosition(uint256) internal virtual;\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other sitution at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded)\n        internal\n        virtual\n        returns (uint256 _liquidatedAmount, uint256 _loss);\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal virtual returns (uint256 _amountFreed);\n\n    /// @notice Override this to add all tokens/tokenized positions this contract\n    /// manages on a *persistent* basis (e.g. not just for swapping back to\n    /// want ephemerally).\n    ///\n    /// NOTE: Do *not* include `want`, already included in `sweep` below.\n    ///\n    /// Example:\n    /// ```\n    ///    function _protectedTokens() internal override view returns (address[] memory) {\n    ///      address[] memory protected = new address[](3);\n    ///      protected[0] = tokenA;\n    ///      protected[1] = tokenB;\n    ///      protected[2] = tokenC;\n    ///      return protected;\n    ///    }\n    /// ```\n    function _protectedTokens() internal view virtual returns (address[] memory);\n\n    // ============================== Governance ===================================\n\n    /// @notice Activates emergency exit. Once activated, the Strategy will exit its\n    /// position upon the next harvest, depositing all funds into the Manager as\n    /// quickly as is reasonable given on-chain conditions.\n    /// @dev This may only be called by the `PoolManager`, because when calling this the `PoolManager` should at the same\n    /// time update the debt ratio\n    /// @dev This function can only be called once by the `PoolManager` contract\n    /// @dev See `poolManager.setEmergencyExit()` and `harvest()` for further details.\n    function setEmergencyExit() external onlyRole(POOLMANAGER_ROLE) {\n        emergencyExit = true;\n        emit EmergencyExitActivated();\n    }\n\n    /// @notice Sets how far the Strategy can go into loss without a harvest and report\n    /// being required.\n    /// @param _debtThreshold How big of a loss this Strategy may carry without\n    /// @dev By default this is 0, meaning any losses would cause a harvest which\n    /// will subsequently report the loss to the Manager for tracking.\n    function setDebtThreshold(uint256 _debtThreshold) external onlyRole(GUARDIAN_ROLE) {\n        debtThreshold = _debtThreshold;\n        emit UpdatedDebtThreshold(_debtThreshold);\n    }\n\n    /// @notice Removes tokens from this Strategy that are not the type of tokens\n    /// managed by this Strategy. This may be used in case of accidentally\n    /// sending the wrong kind of token to this Strategy.\n    ///\n    /// Tokens will be sent to `governance()`.\n    ///\n    /// This will fail if an attempt is made to sweep `want`, or any tokens\n    /// that are protected by this Strategy.\n    ///\n    /// This may only be called by governance.\n    /// @param _token The token to transfer out of this `PoolManager`.\n    /// @param to Address to send the tokens to.\n    /// @dev\n    /// Implement `_protectedTokens()` to specify any additional tokens that\n    /// should be protected from sweeping in addition to `want`.\n    function sweep(address _token, address to) external onlyRole(GUARDIAN_ROLE) {\n        if (_token == address(want)) revert InvalidToken();\n\n        address[] memory __protectedTokens = _protectedTokens();\n        for (uint256 i = 0; i < __protectedTokens.length; i++)\n            // In the strategy we use so far, the only protectedToken is the want token\n            // and this has been checked above\n            if (_token == __protectedTokens[i]) revert InvalidToken();\n\n        IERC20(_token).safeTransfer(to, IERC20(_token).balanceOf(address(this)));\n    }\n\n    // ============================ Manager functions ==============================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because Access Control is not defined\n    /// in PoolManagerInternal\n    function addGuardian(address _guardian) external virtual;\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external virtual;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/AaveFlashloanStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./AaveLibraries.sol\";\nimport \"./AaveInterfaces.sol\";\nimport \"../BaseStrategyUpgradeable.sol\";\nimport \"./ComputeProfitability.sol\";\n\n/// @title AaveFlashloanStrategy\n/// @author Yearn Finance (https://etherscan.io/address/0xd4E94061183b2DBF24473F28A3559cf4dE4459Db#code)\n/// but heavily reviewed and modified by Angle Core Team\n/// @notice This strategy is used to optimize lending yield on Aave by taking some form or recursivity that is to say\n/// by borrowing to maximize Aave rewards\n/// @dev Angle strategies computes the optimal collateral ratio based on AAVE rewards for deposits and borrows\n// solhint-disable-next-line max-states-count\ncontract AaveFlashloanStrategy is BaseStrategyUpgradeable, IERC3156FlashBorrower {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // =========================== Constant Addresses ==============================\n\n    /// @notice Router used for swaps\n    address private constant _oneInch = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\n    /// @notice Chainlink oracle used to fetch data\n    AggregatorV3Interface private constant _chainlinkOracle =\n        AggregatorV3Interface(0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n\n    // ========================== Aave Protocol Addresses ==========================\n\n    IAaveIncentivesController private constant _incentivesController =\n        IAaveIncentivesController(0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5);\n    ILendingPool private constant _lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n    IProtocolDataProvider private constant _protocolDataProvider =\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\n\n    // ============================== Token Addresses ==============================\n\n    address private constant _aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n    IStakedAave private constant _stkAave = IStakedAave(0x4da27a545c0c5B758a6BA100e3a049001de870f5);\n    address private constant _weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant _dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    // ============================== Ops Constants ================================\n\n    uint256 private constant _DEFAULT_COLLAT_TARGET_MARGIN = 0.02 ether;\n    uint256 private constant _DEFAULT_COLLAT_MAX_MARGIN = 0.005 ether;\n    uint256 private constant _LIQUIDATION_WARNING_THRESHOLD = 0.01 ether;\n    uint256 private constant _BPS_WAD_RATIO = 1e14;\n    uint256 private constant _COLLATERAL_RATIO_PRECISION = 1 ether;\n    uint16 private constant _referral = 0;\n\n    // ========================= Aave Protocol Parameters ==========================\n\n    IReserveInterestRateStrategy private _interestRateStrategyAddress;\n    uint256 public cooldownSeconds;\n    uint256 public unstakeWindow;\n    int256 public reserveFactor;\n    int256 public slope1;\n    int256 public slope2;\n    int256 public r0;\n    int256 public uOptimal;\n\n    // =============================== Parameters and Variables ====================\n\n    /// @notice Maximum the Aave protocol will let us borrow\n    uint256 public maxBorrowCollatRatio;\n    /// @notice LTV the strategy is going to lever up to\n    uint256 public targetCollatRatio;\n    /// @notice Closest to liquidation we'll risk\n    uint256 public maxCollatRatio;\n    /// @notice Parameter used for flash mints\n    uint256 public daiBorrowCollatRatio;\n    /// @notice Minimum amount to be moved before a deposit or a borrow\n    uint256 public minWant;\n    /// @notice Minimum gap between the collat ratio and the target collat ratio before\n    /// rectifying it\n    uint256 public minRatio;\n    /// @notice Discount factor applied to the StkAAVE price\n    uint256 public discountFactor;\n    /// @notice Max number of iterations possible for the computation of the optimal lever\n    uint8 public maxIterations;\n\n    struct BoolParams {\n        // Whether collateral ratio will be automatically computed\n        bool automaticallyComputeCollatRatio;\n        // Whether Flash mint is active\n        bool isFlashMintActive;\n        // Whether we should check withdrawals\n        bool withdrawCheck;\n        // Whether StkAAVE should be sent to cooldown or simply swapped for Aave all the time\n        bool cooldownStkAave;\n    }\n    /// @notice Struct with some boolean parameters of the contract\n    /// These parameters are packed in a struct for efficiency of SLOAD operations\n    BoolParams public boolParams;\n\n    // ========================= Supply and Borrow Tokens ==========================\n\n    IAToken private _aToken;\n    IVariableDebtToken private _debtToken;\n\n    // ================================== Errors ===================================\n\n    error ErrorSwap();\n    error InvalidSender();\n    error InvalidSetOfParameters();\n    error InvalidWithdrawCheck();\n    error TooSmallAmountOut();\n    error TooHighParameterValue();\n\n    // ============================ Initializer ====================================\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param interestRateStrategyAddress_ Address of the `InterestRateStrategy` defining borrow rates for the collateral\n    /// @param governor Governor address of the protocol\n    /// @param guardian Address of the guardian\n    /// @param keepers List of the addresses with keeper privilege\n    function initialize(\n        address _poolManager,\n        IReserveInterestRateStrategy interestRateStrategyAddress_,\n        address governor,\n        address guardian,\n        address[] memory keepers\n    ) external {\n        _initialize(_poolManager, governor, guardian, keepers);\n\n        // Then initializing operational state\n        maxIterations = 6;\n        // Setting mins\n        minWant = 100;\n        minRatio = 0.005 ether;\n        discountFactor = 9000;\n\n        boolParams = BoolParams({\n            automaticallyComputeCollatRatio: true,\n            isFlashMintActive: true,\n            withdrawCheck: false,\n            cooldownStkAave: true\n        });\n\n        _interestRateStrategyAddress = interestRateStrategyAddress_;\n        // Setting reward params\n        _setAavePoolVariables();\n\n        // Set AAVE tokens\n        (address aToken_, , address debtToken_) = _protocolDataProvider.getReserveTokensAddresses(address(want));\n        _aToken = IAToken(aToken_);\n        _debtToken = IVariableDebtToken(debtToken_);\n\n        // Let collateral targets\n        (uint256 ltv, uint256 liquidationThreshold) = _getProtocolCollatRatios(address(want));\n        targetCollatRatio = liquidationThreshold - _DEFAULT_COLLAT_TARGET_MARGIN;\n        maxCollatRatio = liquidationThreshold - _DEFAULT_COLLAT_MAX_MARGIN;\n        maxBorrowCollatRatio = ltv - _DEFAULT_COLLAT_MAX_MARGIN;\n        (uint256 daiLtv, ) = _getProtocolCollatRatios(_dai);\n        daiBorrowCollatRatio = daiLtv - _DEFAULT_COLLAT_MAX_MARGIN;\n\n        // Performing all the different approvals possible\n        _approveMaxSpend(address(want), address(_lendingPool));\n        _approveMaxSpend(aToken_, address(_lendingPool));\n        // Approve flashloan spend\n        _approveMaxSpend(_dai, FlashMintLib.LENDER);\n        // Approve swap router spend\n        _approveMaxSpend(address(_stkAave), _oneInch);\n        _approveMaxSpend(_aave, _oneInch);\n        if (address(want) != _dai) {\n            _approveMaxSpend(_dai, address(_lendingPool));\n        }\n    }\n\n    // ======================= Helper View Functions ===============================\n\n    /// @notice Estimates the total assets controlled by the strategy\n    /// @dev It sums the effective deposit amount to the rewards accumulated\n    function estimatedTotalAssets() public view override returns (uint256) {\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\n        return\n            _balanceOfWant() +\n            deposits -\n            borrows +\n            _estimatedStkAaveToWant(\n                _balanceOfStkAave() +\n                    _balanceOfAave() +\n                    _incentivesController.getRewardsBalance(_getAaveAssets(), address(this))\n            );\n    }\n\n    /// @notice Get the current position of the strategy: that is to say the amount deposited\n    /// and the amount borrowed on Aave\n    /// @dev The actual amount brought is `deposits - borrows`\n    function getCurrentPosition() public view returns (uint256 deposits, uint256 borrows) {\n        deposits = _balanceOfAToken();\n        borrows = _balanceOfDebtToken();\n    }\n\n    // ====================== Internal Strategy Functions ==========================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        // account for profit / losses\n        uint256 totalDebt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        // Assets immediately convertible to want only\n        uint256 amountAvailable = _balanceOfWant();\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\n        uint256 totalAssets = amountAvailable + deposits - borrows;\n\n        if (totalDebt > totalAssets) {\n            // we have losses\n            _loss = totalDebt - totalAssets;\n        } else {\n            // we have profit\n            _profit = totalAssets - totalDebt;\n        }\n\n        // free funds to repay debt + profit to the strategy\n        uint256 amountRequired = _debtOutstanding + _profit;\n\n        if (amountRequired > amountAvailable) {\n            // we need to free funds\n            // we dismiss losses here, they cannot be generated from withdrawal\n            // but it is possible for the strategy to unwind full position\n            (amountAvailable, ) = _liquidatePosition(amountRequired, amountAvailable, deposits, borrows);\n\n            if (amountAvailable >= amountRequired) {\n                _debtPayment = _debtOutstanding;\n                // profit remains unchanged unless there is not enough to pay it\n                if (amountRequired - _debtPayment < _profit) {\n                    _profit = amountRequired - _debtPayment;\n                }\n            } else {\n                // we were not able to free enough funds\n                if (amountAvailable < _debtOutstanding) {\n                    // available funds are lower than the repayment that we need to do\n                    _profit = 0;\n                    _debtPayment = amountAvailable;\n                    // we dont report losses here as the strategy might not be able to return in this harvest\n                    // but it will still be there for the next harvest\n                } else {\n                    // NOTE: amountRequired is always equal or greater than _debtOutstanding\n                    // important to use amountRequired just in case amountAvailable is > amountAvailable\n                    _debtPayment = _debtOutstanding;\n                    _profit = amountAvailable - _debtPayment;\n                }\n            }\n        } else {\n            _debtPayment = _debtOutstanding;\n            // profit remains unchanged unless there is not enough to pay it\n            if (amountRequired - _debtPayment < _profit) {\n                _profit = amountRequired - _debtPayment;\n            }\n        }\n    }\n\n    /// @notice Function called by _harvest()\n    function _adjustPosition() internal override {\n        _adjustPosition(type(uint256).max);\n    }\n\n    /// @notice Function called by _adjustPosition()\n    /// @param guessedBorrow First guess to the borrow amount to maximise revenue\n    /// @dev It computes the optimal collateral ratio and adjusts deposits/borrows accordingly\n    function _adjustPosition(uint256 guessedBorrow) internal override {\n        uint256 _debtOutstanding = poolManager.debtOutstanding();\n\n        uint256 wantBalance = _balanceOfWant();\n        // deposit available want as collateral\n        if (wantBalance > _debtOutstanding && wantBalance - _debtOutstanding > minWant) {\n            _depositCollateral(wantBalance - _debtOutstanding);\n            // Updating the `wantBalance` value\n            wantBalance = _balanceOfWant();\n        }\n\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\n        guessedBorrow = (guessedBorrow == type(uint256).max) ? borrows : guessedBorrow;\n        uint256 _targetCollatRatio;\n        if (boolParams.automaticallyComputeCollatRatio) {\n            _targetCollatRatio = _computeOptimalCollatRatio(\n                wantBalance + deposits - borrows,\n                deposits,\n                borrows,\n                guessedBorrow\n            );\n        } else {\n            _targetCollatRatio = targetCollatRatio;\n        }\n\n        // check current position\n        uint256 currentCollatRatio = _getCollatRatio(deposits, borrows);\n\n        // Either we need to free some funds OR we want to be max levered\n        if (_debtOutstanding > wantBalance) {\n            // we should free funds\n            uint256 amountRequired = _debtOutstanding - wantBalance;\n\n            // NOTE: vault will take free funds during the next harvest\n            _freeFunds(amountRequired, deposits, borrows);\n        } else if (currentCollatRatio < _targetCollatRatio) {\n            // we should lever up\n            if (_targetCollatRatio - currentCollatRatio > minRatio) {\n                // we only act on relevant differences\n                _leverMax(deposits, borrows);\n            }\n        } else if (currentCollatRatio > _targetCollatRatio) {\n            if (currentCollatRatio - _targetCollatRatio > minRatio) {\n                uint256 newBorrow = _getBorrowFromSupply(deposits - borrows, _targetCollatRatio);\n                _leverDownTo(newBorrow, deposits, borrows);\n            }\n        }\n    }\n\n    /// @notice Liquidates `_amountNeeded` from a position\n    /// @dev For gas efficiency this function calls another internal function\n    function _liquidatePosition(uint256 _amountNeeded) internal override returns (uint256, uint256) {\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\n        return _liquidatePosition(_amountNeeded, _balanceOfWant(), deposits, borrows);\n    }\n\n    /// @notice Withdraws `_amountNeeded` of `want` from Aave\n    /// @param _amountNeeded Amount of `want` to free\n    /// @return _liquidatedAmount Amount of `want` available\n    /// @return _loss Difference between `_amountNeeded` and what is actually available\n    function _liquidatePosition(\n        uint256 _amountNeeded,\n        uint256 wantBalance,\n        uint256 deposits,\n        uint256 borrows\n    ) internal returns (uint256 _liquidatedAmount, uint256 _loss) {\n        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`\n        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`\n        if (wantBalance > _amountNeeded) {\n            // if there is enough free want, let's use it\n            return (_amountNeeded, 0);\n        }\n\n        // we need to free funds\n        uint256 amountRequired = _amountNeeded - wantBalance;\n        _freeFunds(amountRequired, deposits, borrows);\n        // Updating the `wantBalance` variable\n        wantBalance = _balanceOfWant();\n        if (_amountNeeded > wantBalance) {\n            _liquidatedAmount = wantBalance;\n            uint256 diff = _amountNeeded - _liquidatedAmount;\n            if (diff <= minWant) {\n                _loss = diff;\n            }\n        } else {\n            _liquidatedAmount = _amountNeeded;\n        }\n\n        if (boolParams.withdrawCheck) {\n            if (_amountNeeded != _liquidatedAmount + _loss) revert InvalidWithdrawCheck(); // dev: withdraw safety check\n        }\n    }\n\n    /// @notice Withdraw as much as we can from Aave\n    /// @return _amountFreed Amount successfully freed\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        (_amountFreed, ) = _liquidatePosition(type(uint256).max);\n    }\n\n    function _protectedTokens() internal view override returns (address[] memory) {}\n\n    // ============================== Setters ======================================\n\n    /// @notice Sets collateral targets and value for collateral ratio\n    function setCollateralTargets(\n        uint256 _targetCollatRatio,\n        uint256 _maxCollatRatio,\n        uint256 _maxBorrowCollatRatio,\n        uint256 _daiBorrowCollatRatio\n    ) external onlyRole(GUARDIAN_ROLE) {\n        (uint256 ltv, uint256 liquidationThreshold) = _getProtocolCollatRatios(address(want));\n        (uint256 daiLtv, ) = _getProtocolCollatRatios(_dai);\n        if (\n            _targetCollatRatio >= liquidationThreshold ||\n            _maxCollatRatio >= liquidationThreshold ||\n            _targetCollatRatio >= _maxCollatRatio ||\n            _maxBorrowCollatRatio >= ltv ||\n            _daiBorrowCollatRatio >= daiLtv\n        ) revert InvalidSetOfParameters();\n\n        targetCollatRatio = _targetCollatRatio;\n        maxCollatRatio = _maxCollatRatio;\n        maxBorrowCollatRatio = _maxBorrowCollatRatio;\n        daiBorrowCollatRatio = _daiBorrowCollatRatio;\n    }\n\n    /// @notice Sets `minWant`, `minRatio` and `maxItrations` values\n    function setMinsAndMaxs(\n        uint256 _minWant,\n        uint256 _minRatio,\n        uint8 _maxIterations\n    ) external onlyRole(GUARDIAN_ROLE) {\n        if (_minRatio >= maxBorrowCollatRatio || _maxIterations == 0 || _maxIterations >= 16)\n            revert InvalidSetOfParameters();\n        minWant = _minWant;\n        minRatio = _minRatio;\n        maxIterations = _maxIterations;\n    }\n\n    /// @notice Sets all boolean parameters related to cooldown, withdraw check, flash loan and so on\n    function setBoolParams(BoolParams memory _boolParams) external onlyRole(GUARDIAN_ROLE) {\n        boolParams = _boolParams;\n    }\n\n    /// @notice Sets the discount factor for the StkAAVE price\n    function setDiscountFactor(uint256 _discountFactor) external onlyRole(GUARDIAN_ROLE) {\n        if (_discountFactor > 10000) revert TooHighParameterValue();\n        discountFactor = _discountFactor;\n    }\n\n    /// @notice Retrieves lending pool variables for `want`. Those variables are mostly used in the function\n    /// to compute the optimal borrow amount\n    /// @dev No access control needed because they fetch the values from Aave directly.\n    /// If it changes there, it will need to be updated here too\n    /// @dev We expect the values concerned not to be often modified\n    function setAavePoolVariables() external {\n        _setAavePoolVariables();\n    }\n\n    // ========================== External Actions =================================\n\n    /// @notice Emergency function that we can use to deleverage manually if something is broken\n    /// @param amount Amount of `want` to withdraw/repay\n    function manualDeleverage(uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        _withdrawCollateral(amount);\n        _repayWant(amount);\n    }\n\n    /// @notice Emergency function that we can use to deleverage manually if something is broken\n    /// @param amount Amount of `want` to withdraw\n    function manualReleaseWant(uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        _withdrawCollateral(amount);\n    }\n\n    /// @notice Adds a new guardian address\n    /// @param _guardian New guardian address\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n    }\n\n    /// @notice Revokes the guardian role\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n    }\n\n    /// @notice Swap earned stkAave or Aave for `want` through 1Inch\n    /// @param minAmountOut Minimum amount of `want` to receive for the swap to happen\n    /// @param payload Bytes needed for 1Inch API. Tokens swapped should be: stkAave -> `want` or Aave -> `want`\n    function sellRewards(uint256 minAmountOut, bytes memory payload) external onlyRole(KEEPER_ROLE) {\n        //solhint-disable-next-line\n        (bool success, bytes memory result) = _oneInch.call(payload);\n        if (!success) _revertBytes(result);\n\n        uint256 amountOut = abi.decode(result, (uint256));\n        if (amountOut < minAmountOut) revert TooSmallAmountOut();\n    }\n\n    /// @notice Flashload callback, as defined by EIP-3156\n    /// @notice We check that the call is coming from the DAI lender and then execute the load logic\n    /// @dev If everything went smoothly, will return `keccak256(\"ERC3156FlashBorrower.onFlashLoan\")`\n    function onFlashLoan(\n        address initiator,\n        address,\n        uint256 amount,\n        uint256,\n        bytes calldata data\n    ) external override returns (bytes32) {\n        if (msg.sender != FlashMintLib.LENDER || initiator != address(this)) revert InvalidSender();\n        (bool deficit, uint256 amountWant) = abi.decode(data, (bool, uint256));\n\n        return FlashMintLib.loanLogic(deficit, amountWant, amount, address(want));\n    }\n\n    // ========================== Internal Actions =================================\n\n    /// @notice Claim earned stkAAVE (only called at `harvest`)\n    /// @dev stkAAVE require a \"cooldown\" period of 10 days before being claimed\n    function _claimRewards() internal returns (uint256 stkAaveBalance) {\n        stkAaveBalance = _balanceOfStkAave();\n        // If it's the claim period claim\n        if (stkAaveBalance > 0 && _checkCooldown() == 1) {\n            // redeem AAVE from stkAave\n            _stkAave.claimRewards(address(this), type(uint256).max);\n            _stkAave.redeem(address(this), stkAaveBalance);\n        }\n\n        // claim stkAave from lending and borrowing, this will reset the cooldown\n        _incentivesController.claimRewards(_getAaveAssets(), type(uint256).max, address(this));\n\n        stkAaveBalance = _balanceOfStkAave();\n\n        // request start of cooldown period, if there's no cooldown in progress\n        if (boolParams.cooldownStkAave && stkAaveBalance > 0 && _checkCooldown() == 0) {\n            _stkAave.cooldown();\n        }\n    }\n\n    function claimRewards() external onlyRole(KEEPER_ROLE) {\n        _claimRewards();\n    }\n\n    function cooldown() external onlyRole(KEEPER_ROLE) {\n        _stkAave.cooldown();\n    }\n\n    /// @notice Reduce exposure by withdrawing funds and repaying debt\n    /// @param amountToFree Amount of `want` to withdraw/repay\n    /// @return balance Current balance of `want`\n    /// @dev `deposits` and `borrows` are always computed prior to the call\n    function _freeFunds(\n        uint256 amountToFree,\n        uint256 deposits,\n        uint256 borrows\n    ) internal returns (uint256) {\n        if (amountToFree == 0) return 0;\n\n        uint256 realAssets = deposits - borrows;\n        uint256 newBorrow = _getBorrowFromSupply(realAssets - Math.min(amountToFree, realAssets), targetCollatRatio);\n\n        // repay required amount\n        _leverDownTo(newBorrow, deposits, borrows);\n\n        return _balanceOfWant();\n    }\n\n    /// @notice Get exposure up to `targetCollatRatio`\n    function _leverMax(uint256 deposits, uint256 borrows) internal {\n        uint256 totalAmountToBorrow = _getBorrowFromSupply(deposits - borrows, targetCollatRatio) - borrows;\n\n        if (boolParams.isFlashMintActive) {\n            // The best approach is to lever up using regular method, then finish with flash loan\n            totalAmountToBorrow = totalAmountToBorrow - _leverUpStep(totalAmountToBorrow, deposits, borrows);\n\n            if (totalAmountToBorrow > minWant) {\n                totalAmountToBorrow = totalAmountToBorrow - _leverUpFlashLoan(totalAmountToBorrow);\n            }\n        } else {\n            for (uint8 i = 0; i < maxIterations && totalAmountToBorrow > minWant; i++) {\n                totalAmountToBorrow = totalAmountToBorrow - _leverUpStep(totalAmountToBorrow, deposits, borrows);\n                deposits = 0;\n                borrows = 0;\n            }\n        }\n    }\n\n    /// @notice Use a flashloan to increase our exposure in `want` on Aave\n    /// @param amount Amount we will deposit and borrow on Aave\n    /// @return amount Actual amount deposited/borrowed\n    /// @dev Amount returned should equal `amount` but can be lower if we try to flashloan more than `maxFlashLoan` authorized\n    function _leverUpFlashLoan(uint256 amount) internal returns (uint256) {\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\n        uint256 depositsToMeetLtv = _getDepositFromBorrow(borrows, maxBorrowCollatRatio, deposits);\n        uint256 depositsDeficitToMeetLtv = 0;\n        if (depositsToMeetLtv > deposits) {\n            depositsDeficitToMeetLtv = depositsToMeetLtv - deposits;\n        }\n        return FlashMintLib.doFlashMint(false, amount, address(want), daiBorrowCollatRatio, depositsDeficitToMeetLtv);\n    }\n\n    /// @notice Increase exposure in `want`\n    /// @param amount Amount of `want` to borrow\n    /// @return amount Amount of `want` that was borrowed\n    function _leverUpStep(\n        uint256 amount,\n        uint256 deposits,\n        uint256 borrows\n    ) internal returns (uint256) {\n        if (deposits == 0 && borrows == 0) (deposits, borrows) = getCurrentPosition();\n\n        uint256 wantBalance = _balanceOfWant();\n\n        uint256 canBorrow = _getBorrowFromDeposit(deposits + wantBalance, maxBorrowCollatRatio);\n\n        if (canBorrow <= borrows) {\n            return 0;\n        }\n        canBorrow = canBorrow - borrows;\n\n        if (canBorrow < amount) {\n            amount = canBorrow;\n        }\n\n        _depositCollateral(wantBalance);\n        _borrowWant(amount);\n        _depositCollateral(amount);\n\n        return amount;\n    }\n\n    /// @notice Reduce our exposure to `want` on Aave\n    /// @param newAmountBorrowed Total amount we want to be borrowing\n    /// @param deposits Amount currently lent\n    /// @param currentBorrowed Amount currently borrowed\n    function _leverDownTo(\n        uint256 newAmountBorrowed,\n        uint256 deposits,\n        uint256 currentBorrowed\n    ) internal {\n        if (currentBorrowed > newAmountBorrowed) {\n            uint256 totalRepayAmount = currentBorrowed - newAmountBorrowed;\n\n            if (boolParams.isFlashMintActive) {\n                totalRepayAmount = totalRepayAmount - _leverDownFlashLoan(totalRepayAmount, currentBorrowed);\n            }\n\n            uint256 _maxCollatRatio = maxCollatRatio;\n\n            // in case the flashloan didn't repay the entire amount we have to repay it \"manually\"\n            // by withdrawing a bit of collateral and then repaying the debt with it\n            for (uint8 i = 0; i < maxIterations && totalRepayAmount > minWant; i++) {\n                _withdrawExcessCollateral(_maxCollatRatio, 0, 0);\n                uint256 toRepay = totalRepayAmount;\n                uint256 wantBalance = _balanceOfWant();\n                if (toRepay > wantBalance) {\n                    toRepay = wantBalance;\n                }\n                uint256 repaid = _repayWant(toRepay);\n                totalRepayAmount = totalRepayAmount - repaid;\n            }\n            (deposits, currentBorrowed) = getCurrentPosition();\n        }\n\n        // Deposit back to get `targetCollatRatio` (we always need to leave this in this ratio)\n        uint256 _targetCollatRatio = targetCollatRatio;\n        uint256 targetDeposit = _getDepositFromBorrow(currentBorrowed, _targetCollatRatio, deposits);\n        if (targetDeposit > deposits) {\n            uint256 toDeposit = targetDeposit - deposits;\n            if (toDeposit > minWant) {\n                _depositCollateral(Math.min(toDeposit, _balanceOfWant()));\n            }\n        } else {\n            if (deposits - targetDeposit > minWant) {\n                _withdrawExcessCollateral(_targetCollatRatio, deposits, currentBorrowed);\n            }\n        }\n    }\n\n    /// @notice Use a flashloan to reduce our exposure in `want` on Aave\n    /// @param amount Amount we will need to withdraw and repay to Aave\n    /// @return amount Actual amount repaid\n    /// @dev Amount returned should equal `amount` but can be lower if we try to flashloan more than `maxFlashLoan` authorized\n    /// @dev `amount` will be withdrawn from deposits and then used to repay borrows\n    function _leverDownFlashLoan(uint256 amount, uint256 borrows) internal returns (uint256) {\n        if (amount <= minWant) return 0;\n        if (amount > borrows) {\n            amount = borrows;\n        }\n        return FlashMintLib.doFlashMint(true, amount, address(want), daiBorrowCollatRatio, 0);\n    }\n\n    /// @notice Adjusts the deposits based on the wanted collateral ratio (does not touch the borrow)\n    /// @param collatRatio Collateral ratio to target\n    function _withdrawExcessCollateral(\n        uint256 collatRatio,\n        uint256 deposits,\n        uint256 borrows\n    ) internal returns (uint256 amount) {\n        if (deposits == 0 && borrows == 0) (deposits, borrows) = getCurrentPosition();\n        uint256 theoDeposits = _getDepositFromBorrow(borrows, collatRatio, deposits);\n        if (deposits > theoDeposits) {\n            uint256 toWithdraw = deposits - theoDeposits;\n            return _withdrawCollateral(toWithdraw);\n        }\n    }\n\n    /// @notice Deposit `want` tokens in Aave and start earning interests\n    /// @param amount Amount to be deposited\n    /// @return amount The amount deposited\n    function _depositCollateral(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n        _lendingPool.deposit(address(want), amount, address(this), _referral);\n        return amount;\n    }\n\n    /// @notice Withdraw `want` tokens from Aave\n    /// @param amount Amount to be withdrawn\n    /// @return amount The amount withdrawn\n    function _withdrawCollateral(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n        _lendingPool.withdraw(address(want), amount, address(this));\n        return amount;\n    }\n\n    /// @notice Repay what we borrowed of `want` from Aave\n    /// @param amount Amount to repay\n    /// @return amount The amount repaid\n    /// @dev `interestRateMode` is set to variable rate (2)\n    function _repayWant(uint256 amount) internal returns (uint256) {\n        if (amount == 0) return 0;\n        return _lendingPool.repay(address(want), amount, 2, address(this));\n    }\n\n    /// @notice Borrow `want` from Aave\n    /// @param amount Amount of `want` we are borrowing\n    /// @return amount The amount borrowed\n    /// @dev The third variable is the `interestRateMode`\n    /// @dev set at 2 which means we will get a variable interest rate on our borrowed tokens\n    function _borrowWant(uint256 amount) internal returns (uint256) {\n        _lendingPool.borrow(address(want), amount, 2, _referral, address(this));\n        return amount;\n    }\n\n    /// @notice Computes the optimal collateral ratio based on current interests and incentives on Aave\n    /// @notice It modifies the state by updating the `targetCollatRatio`\n    function _computeOptimalCollatRatio(\n        uint256 balanceExcludingRewards,\n        uint256 deposits,\n        uint256 currentBorrowed,\n        uint256 guessedBorrow\n    ) internal returns (uint256) {\n        uint256 borrow = _computeMostProfitableBorrow(\n            balanceExcludingRewards,\n            deposits,\n            currentBorrowed,\n            guessedBorrow\n        );\n        uint256 _collatRatio = _getCollatRatio(balanceExcludingRewards + borrow, borrow);\n        uint256 _maxCollatRatio = maxCollatRatio;\n        if (_collatRatio > _maxCollatRatio) {\n            _collatRatio = _maxCollatRatio;\n        }\n        targetCollatRatio = _collatRatio;\n        return _collatRatio;\n    }\n\n    /// @notice Approve `spender` maxuint of `token`\n    /// @param token Address of token to approve\n    /// @param spender Address of spender to approve\n    function _approveMaxSpend(address token, address spender) internal {\n        IERC20(token).safeApprove(spender, type(uint256).max);\n    }\n\n    /// @notice Internal version of the `_setAavePoolVariables`\n    function _setAavePoolVariables() internal {\n        (, , , , uint256 reserveFactor_, , , , , ) = _protocolDataProvider.getReserveConfigurationData(address(want));\n        cooldownSeconds = IStakedAave(_stkAave).COOLDOWN_SECONDS();\n        unstakeWindow = IStakedAave(_stkAave).UNSTAKE_WINDOW();\n        reserveFactor = int256(reserveFactor_ * 10**23);\n        slope1 = int256(_interestRateStrategyAddress.variableRateSlope1());\n        slope2 = int256(_interestRateStrategyAddress.variableRateSlope2());\n        r0 = int256(_interestRateStrategyAddress.baseVariableBorrowRate());\n        uOptimal = int256(_interestRateStrategyAddress.OPTIMAL_UTILIZATION_RATE());\n    }\n\n    // ========================= Internal View Functions ===========================\n\n    /// @notice Computes the optimal amounts to borrow based on current interest rates and incentives\n    /// @dev Returns optimal `borrow` amount in base of `want`\n    function _computeMostProfitableBorrow(\n        uint256 balanceExcludingRewards,\n        uint256 deposits,\n        uint256 currentBorrow,\n        uint256 guessedBorrow\n    ) internal view returns (uint256 borrow) {\n        // This works if `wantBase < 10**27` which we should expect to be very the case for the strategies we are\n        // launching at the moment\n        uint256 normalizationFactor = 10**27 / wantBase;\n\n        ComputeProfitability.SCalculateBorrow memory parameters;\n\n        {\n            (\n                uint256 availableLiquidity,\n                uint256 totalStableDebt,\n                uint256 totalVariableDebt,\n                ,\n                ,\n                ,\n                uint256 averageStableBorrowRate,\n                ,\n                ,\n\n            ) = _protocolDataProvider.getReserveData(address(want));\n\n            parameters = ComputeProfitability.SCalculateBorrow({\n                reserveFactor: reserveFactor,\n                totalStableDebt: int256(totalStableDebt * normalizationFactor),\n                totalVariableDebt: int256((totalVariableDebt - currentBorrow) * normalizationFactor),\n                totalDeposits: int256(\n                    (availableLiquidity +\n                        totalStableDebt +\n                        totalVariableDebt +\n                        // to adapt to our future balance\n                        // add the wantBalance and remove the currentBorrowed from the optimisation\n                        balanceExcludingRewards -\n                        deposits) * normalizationFactor\n                ),\n                stableBorrowRate: int256(averageStableBorrowRate),\n                rewardDeposit: 0,\n                rewardBorrow: 0,\n                strategyAssets: int256(balanceExcludingRewards * normalizationFactor),\n                guessedBorrowAssets: int256(guessedBorrow * normalizationFactor),\n                slope1: slope1,\n                slope2: slope2,\n                r0: r0,\n                uOptimal: uOptimal\n            });\n        }\n\n        {\n            uint256 stkAavePriceInWant = _estimatedStkAaveToWant(1 ether);\n\n            (uint256 emissionPerSecondAToken, , ) = _incentivesController.assets(address(_aToken));\n            (uint256 emissionPerSecondDebtToken, , ) = _incentivesController.assets(address(_debtToken));\n\n            parameters.rewardDeposit = int256(\n                (emissionPerSecondAToken * 86400 * 365 * stkAavePriceInWant * 10**9) / wantBase\n            );\n            parameters.rewardBorrow = int256(\n                (emissionPerSecondDebtToken * 86400 * 365 * stkAavePriceInWant * 10**9) / wantBase\n            );\n        }\n\n        borrow = uint256(ComputeProfitability.computeProfitability(parameters)) / normalizationFactor;\n    }\n\n    function estimatedAPR() public view returns (uint256) {\n        (\n            ,\n            ,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            ,\n            ,\n            ,\n            ,\n\n        ) = _protocolDataProvider.getReserveData(address(want));\n\n        uint256 _totalAssets = _balanceOfWant() + _balanceOfAToken() - _balanceOfDebtToken();\n        if (_totalAssets == 0 || totalVariableDebt == 0 || _aToken.totalSupply() == 0) return 0;\n\n        (uint256 deposits, uint256 borrows) = getCurrentPosition();\n        uint256 yearlyRewardsATokenInUSD;\n        uint256 yearlyRewardsDebtTokenInUSD;\n        {\n            uint256 stkAavePriceInWant = _estimatedStkAaveToWant(1 ether);\n            (uint256 emissionPerSecondAToken, , ) = (_aToken.getIncentivesController()).assets(address(_aToken));\n            (uint256 emissionPerSecondDebtToken, , ) = (_debtToken.getIncentivesController()).assets(\n                address(_debtToken)\n            );\n\n            uint256 yearlyEmissionsAToken = emissionPerSecondAToken * 60 * 60 * 24 * 365; // BASE: 18\n            uint256 yearlyEmissionsDebtToken = emissionPerSecondDebtToken * 60 * 60 * 24 * 365; // BASE: 18\n            yearlyRewardsATokenInUSD =\n                ((deposits * yearlyEmissionsAToken) / _aToken.totalSupply()) *\n                stkAavePriceInWant; // BASE 18 + want\n            yearlyRewardsDebtTokenInUSD =\n                ((borrows * yearlyEmissionsDebtToken) / totalVariableDebt) *\n                stkAavePriceInWant; // BASE 18 + want\n        }\n\n        return\n            ((liquidityRate * deposits) /\n                10**9 +\n                yearlyRewardsATokenInUSD +\n                yearlyRewardsDebtTokenInUSD -\n                (variableBorrowRate * borrows) /\n                10**9) / _totalAssets; // BASE 18\n    }\n\n    /// @notice Returns the `want` balance\n    function _balanceOfWant() internal view returns (uint256) {\n        return want.balanceOf(address(this));\n    }\n\n    /// @notice Returns the `aToken` balance\n    function _balanceOfAToken() internal view returns (uint256) {\n        return _aToken.balanceOf(address(this));\n    }\n\n    /// @notice Returns the `debtToken` balance\n    function _balanceOfDebtToken() internal view returns (uint256) {\n        return _debtToken.balanceOf(address(this));\n    }\n\n    /// @notice Returns the `AAVE` balance\n    function _balanceOfAave() internal view returns (uint256) {\n        return IERC20(_aave).balanceOf(address(this));\n    }\n\n    /// @notice Returns the `StkAAVE` balance\n    function _balanceOfStkAave() internal view returns (uint256) {\n        return IERC20(address(_stkAave)).balanceOf(address(this));\n    }\n\n    /// @notice Estimate the amount of `want` we will get out by swapping it for AAVE\n    /// @param amount Amount of AAVE we want to exchange (in base 18)\n    /// @return amount Amount of `want` we are getting. We include a discount to account for slippage equal to 9000\n    /// @dev Uses Chainlink spot price. Return value will be in base of `want` (6 for USDC)\n    function _estimatedStkAaveToWant(uint256 amount) internal view returns (uint256) {\n        (, int256 aavePriceUSD, , , ) = _chainlinkOracle.latestRoundData(); // stkAavePriceUSD is in base 8\n        // `aavePriceUSD` is in base 8, and the discount factor is in base 4, so ultimately we need to divide\n        // by `1e(18+8+4)\n        return (uint256(aavePriceUSD) * amount * wantBase * discountFactor) / 1e30;\n    }\n\n    /// @notice Verifies the cooldown status for earned stkAAVE\n    /// @return cooldownStatus Status of the coolDown: if it is 0 then there is no cooldown Status, if it is 1 then\n    /// the strategy should claim\n    function _checkCooldown() internal view returns (uint256 cooldownStatus) {\n        uint256 cooldownStartTimestamp = IStakedAave(_stkAave).stakersCooldowns(address(this));\n        uint256 nextClaimStartTimestamp = cooldownStartTimestamp + cooldownSeconds;\n        if (cooldownStartTimestamp == 0) {\n            return 0;\n        }\n        if (block.timestamp > nextClaimStartTimestamp && block.timestamp <= nextClaimStartTimestamp + unstakeWindow) {\n            return 1;\n        }\n        if (block.timestamp < nextClaimStartTimestamp) {\n            return 2;\n        }\n    }\n\n    /// @notice Get the deposit and debt token for our `want` token\n    function _getAaveAssets() internal view returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = address(_aToken);\n        assets[1] = address(_debtToken);\n    }\n\n    /// @notice Get Aave ratios for a token in order to compute later our collateral ratio\n    /// @param token Address of the token for which to check the ratios (usually `want` token)\n    /// @dev `getReserveConfigurationData` returns values in base 4. So here `ltv` and `liquidationThreshold` are returned in base 18\n    function _getProtocolCollatRatios(address token) internal view returns (uint256 ltv, uint256 liquidationThreshold) {\n        (, ltv, liquidationThreshold, , , , , , , ) = _protocolDataProvider.getReserveConfigurationData(token);\n        // convert bps to wad\n        ltv = ltv * _BPS_WAD_RATIO;\n        liquidationThreshold = liquidationThreshold * _BPS_WAD_RATIO;\n    }\n\n    // ========================= Internal Pure Functions ===========================\n\n    /// @notice Get target borrow amount based on deposit and collateral ratio\n    /// @param deposit Current total deposited on Aave\n    /// @param collatRatio Collateral ratio to target\n    function _getBorrowFromDeposit(uint256 deposit, uint256 collatRatio) internal pure returns (uint256) {\n        return (deposit * collatRatio) / _COLLATERAL_RATIO_PRECISION;\n    }\n\n    /// @notice Get target deposit amount based on borrow and collateral ratio\n    /// @param borrow Current total borrowed on Aave\n    /// @param collatRatio Collateral ratio to target\n    /// @param deposits Current deposit amount: this is what the function should return if the `collatRatio` is null\n    function _getDepositFromBorrow(\n        uint256 borrow,\n        uint256 collatRatio,\n        uint256 deposits\n    ) internal pure returns (uint256) {\n        if (collatRatio > 0) return (borrow * _COLLATERAL_RATIO_PRECISION) / collatRatio;\n        else return deposits;\n    }\n\n    /// @notice Get target borrow amount based on supply (deposits - borrow) and collateral ratio\n    /// @param supply = deposits - borrows. The supply is what is \"actually\" deposited in Aave\n    /// @param collatRatio Collateral ratio to target\n    function _getBorrowFromSupply(uint256 supply, uint256 collatRatio) internal pure returns (uint256) {\n        return (supply * collatRatio) / (_COLLATERAL_RATIO_PRECISION - collatRatio);\n    }\n\n    /// @notice Computes the position collateral ratio from deposits and borrows\n    function _getCollatRatio(uint256 deposits, uint256 borrows) internal pure returns (uint256 currentCollatRatio) {\n        if (deposits > 0) {\n            currentCollatRatio = (borrows * _COLLATERAL_RATIO_PRECISION) / deposits;\n        }\n    }\n\n    /// @notice Processes 1Inch revert messages\n    function _revertBytes(bytes memory errMsg) internal pure {\n        if (errMsg.length > 0) {\n            //solhint-disable-next-line\n            assembly {\n                revert(add(32, errMsg), mload(errMsg))\n            }\n        }\n        revert ErrorSwap();\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashBorrower.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC3156 FlashBorrower, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashBorrower {\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/AaveLibraries.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { IAToken, IProtocolDataProvider, IProtocolDataProvider, ILendingPool, IPriceOracle, IOptionalERC20 } from \"./AaveInterfaces.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n}\n\nlibrary FlashMintLib {\n    event Leverage(\n        uint256 amountRequested,\n        uint256 amountUsed,\n        uint256 requiredDAI,\n        uint256 amountToCloseLTVGap,\n        bool deficit,\n        address flashLoan\n    );\n\n    address public constant LENDER = 0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853;\n    uint256 private constant _DAI_DECIMALS = 1e18;\n    uint256 private constant _COLLAT_RATIO_PRECISION = 1 ether;\n    address private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address private constant _DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    IAToken public constant ADAI = IAToken(0x028171bCA77440897B824Ca71D1c56caC55b68A3);\n    IProtocolDataProvider private constant _protocolDataProvider =\n        IProtocolDataProvider(0x057835Ad21a177dbdd3090bB1CAE03EaCF78Fc6d);\n    ILendingPool private constant _lendingPool = ILendingPool(0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9);\n\n    bytes32 public constant CALLBACK_SUCCESS = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    uint16 private constant _referral = 0; // TODO: get our own referral code\n\n    uint256 private constant _RAY = 10**27;\n\n    function doFlashMint(\n        bool deficit,\n        uint256 amountDesired,\n        address token,\n        uint256 collatRatioDAI,\n        uint256 depositToCloseLTVGap\n    ) public returns (uint256 amount) {\n        if (amountDesired == 0) {\n            return 0;\n        }\n        amount = amountDesired;\n        address dai = _DAI;\n\n        // calculate amount of dai we need\n        uint256 requiredDAI;\n        {\n            requiredDAI = (toDAI(amount, token) * _COLLAT_RATIO_PRECISION) / collatRatioDAI;\n\n            uint256 requiredDAIToCloseLTVGap = 0;\n            if (depositToCloseLTVGap > 0) {\n                requiredDAIToCloseLTVGap = toDAI(depositToCloseLTVGap, token);\n                requiredDAI = requiredDAI + requiredDAIToCloseLTVGap;\n            }\n\n            uint256 _maxLiquidity = maxLiquidity();\n\n            /*\n            When depositing/withdrawing in the `lendingPool` the amounts are scaled by a `liquidityIndex` and rounded with the functions rayDiv and rayMul (in the aDAI contract)\n            Weirdly, 2 different indexes are used: `liquidityIndex` is used when depositing and `getReserveNormalizedIncome` when withdrawing\n            Therefore, we need to round `requiredDAI`, or we may get some rounding errors and revert\n            because the amount we try to withdraw (to pay back the flashloan) is not equal to the amount deposited\n            */\n            uint256 liquidityIndex = _lendingPool.getReserveData(dai).liquidityIndex;\n            uint256 getReserveNormalizedIncome = _lendingPool.getReserveNormalizedIncome(dai);\n            uint256 rayDiv = ((requiredDAI * _RAY + liquidityIndex / 2) / liquidityIndex);\n            requiredDAI = (rayDiv * getReserveNormalizedIncome + (_RAY / 2)) / _RAY;\n\n            if (requiredDAI > _maxLiquidity) {\n                requiredDAI = (_maxLiquidity * _RAY - (_RAY / 2)) / getReserveNormalizedIncome;\n                requiredDAI = (requiredDAI * liquidityIndex - liquidityIndex / 2) / _RAY;\n\n                // NOTE: if we cap amountDAI, we reduce amountToken we are taking too\n                amount =\n                    (fromDAI(requiredDAI - requiredDAIToCloseLTVGap, token) * collatRatioDAI) /\n                    _COLLAT_RATIO_PRECISION;\n            }\n        }\n\n        bytes memory data = abi.encode(deficit, amount);\n        uint256 _fee = IERC3156FlashLender(LENDER).flashFee(dai, requiredDAI);\n        // Check that fees have not been increased without us knowing\n        require(_fee == 0);\n        uint256 _allowance = IERC20(dai).allowance(address(this), address(LENDER));\n        if (_allowance < requiredDAI) {\n            IERC20(dai).approve(address(LENDER), 0);\n            IERC20(dai).approve(address(LENDER), type(uint256).max);\n        }\n\n        IERC3156FlashLender(LENDER).flashLoan(IERC3156FlashBorrower(address(this)), dai, requiredDAI, data);\n\n        emit Leverage(amountDesired, amount, requiredDAI, depositToCloseLTVGap, deficit, LENDER);\n\n        return amount; // we need to return the amount of Token we have changed our position in\n    }\n\n    function loanLogic(\n        bool deficit,\n        uint256 amount,\n        uint256 amountFlashmint,\n        address want\n    ) public returns (bytes32) {\n        address dai = _DAI;\n        bool isDai = (want == dai);\n\n        ILendingPool lp = _lendingPool;\n\n        if (isDai) {\n            if (deficit) {\n                lp.deposit(dai, amountFlashmint - amount, address(this), _referral);\n                lp.repay(dai, IERC20(dai).balanceOf(address(this)), 2, address(this));\n                lp.withdraw(dai, amountFlashmint, address(this));\n            } else {\n                lp.deposit(dai, IERC20(dai).balanceOf(address(this)), address(this), _referral);\n                lp.borrow(dai, amount, 2, _referral, address(this));\n                lp.withdraw(dai, amountFlashmint - amount, address(this));\n            }\n        } else {\n            // 1. Deposit DAI in Aave as collateral\n            lp.deposit(dai, amountFlashmint, address(this), _referral);\n\n            if (deficit) {\n                // 2a. if in deficit withdraw amount and repay it\n                lp.withdraw(want, amount, address(this));\n                lp.repay(want, IERC20(want).balanceOf(address(this)), 2, address(this));\n            } else {\n                // 2b. if levering up borrow and deposit\n                lp.borrow(want, amount, 2, _referral, address(this));\n                lp.deposit(want, IERC20(want).balanceOf(address(this)), address(this), _referral);\n            }\n            // 3. Withdraw DAI\n            lp.withdraw(dai, amountFlashmint, address(this));\n        }\n\n        return CALLBACK_SUCCESS;\n    }\n\n    function priceOracle() internal view returns (IPriceOracle) {\n        return IPriceOracle(_protocolDataProvider.ADDRESSES_PROVIDER().getPriceOracle());\n    }\n\n    function toDAI(uint256 _amount, address asset) internal view returns (uint256) {\n        address dai = _DAI;\n        if (_amount == 0 || _amount == type(uint256).max || asset == dai) {\n            return _amount;\n        }\n\n        if (asset == _WETH) {\n            return\n                (_amount * (uint256(10)**uint256(IOptionalERC20(dai).decimals()))) / priceOracle().getAssetPrice(dai);\n        }\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = asset;\n        tokens[1] = dai;\n        uint256[] memory prices = priceOracle().getAssetsPrices(tokens);\n\n        uint256 ethPrice = (_amount * prices[0]) / (uint256(10)**uint256(IOptionalERC20(asset).decimals()));\n        return (ethPrice * _DAI_DECIMALS) / prices[1];\n    }\n\n    function fromDAI(uint256 _amount, address asset) internal view returns (uint256) {\n        address dai = _DAI;\n        if (_amount == 0 || _amount == type(uint256).max || asset == dai) {\n            return _amount;\n        }\n\n        if (asset == _WETH) {\n            return\n                (_amount * priceOracle().getAssetPrice(dai)) / (uint256(10)**uint256(IOptionalERC20(dai).decimals()));\n        }\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = asset;\n        tokens[1] = dai;\n        uint256[] memory prices = priceOracle().getAssetsPrices(tokens);\n\n        uint256 ethPrice = (_amount * prices[1]) / _DAI_DECIMALS;\n\n        return (ethPrice * (uint256(10)**uint256(IOptionalERC20(asset).decimals()))) / prices[0];\n    }\n\n    function maxLiquidity() public view returns (uint256) {\n        return IERC3156FlashLender(LENDER).maxFlashLoan(_DAI);\n    }\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/AaveInterfaces.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { DataTypes } from \"./AaveLibraries.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAaveIncentivesController {\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user) external view returns (uint256);\n\n    /**\n     * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user) external view returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    //solhint-disable-next-line\n    function REWARD_TOKEN() external view returns (address);\n\n    function getDistributionEnd() external view returns (uint256);\n\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function assets(address asset)\n        external\n        view\n        returns (\n            uint256 emissionPerSecond,\n            uint256 index,\n            uint256 lastUpdateTimestamp\n        );\n\n    function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond) external;\n}\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     **/\n    event Repay(address indexed reserve, address indexed user, address indexed repayer, uint256 amount);\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider() external view returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    //solhint-disable-next-line\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider);\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n}\n\ninterface IScaledBalanceToken {\n    /**\n     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n     * updated stored balance divided by the reserve's liquidity index at the moment of the update\n     * @param user The user whose balance is calculated\n     * @return The scaled balance of the user\n     **/\n    function scaledBalanceOf(address user) external view returns (uint256);\n\n    /**\n     * @dev Returns the scaled balance of the user and the scaled total supply.\n     * @param user The address of the user\n     * @return The scaled balance of the user\n     * @return The scaled balance and the scaled total supply\n     **/\n    function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256);\n\n    /**\n     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n     * @return The scaled total supply\n     **/\n    function scaledTotalSupply() external view returns (uint256);\n}\n\n/**\n * @title IVariableDebtToken\n * @author Aave\n * @notice Defines the basic interface for a variable debt token.\n **/\ninterface IVariableDebtToken is IERC20, IScaledBalanceToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param onBehalfOf The address of the user on which behalf minting has been performed\n     * @param value The amount to be minted\n     * @param index The last index of the reserve\n     **/\n    event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index);\n\n    /**\n     * @dev Mints debt token to the `onBehalfOf` address\n     * @param user The address receiving the borrowed underlying, being the delegatee in case\n     * of credit delegate, or same as `onBehalfOf` otherwise\n     * @param onBehalfOf The address receiving the debt tokens\n     * @param amount The amount of debt being minted\n     * @param index The variable debt index of the reserve\n     * @return `true` if the the previous balance of the user is 0\n     **/\n    function mint(\n        address user,\n        address onBehalfOf,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when variable debt is burnt\n     * @param user The user which debt has been burned\n     * @param amount The amount of debt being burned\n     * @param index The index of the user\n     **/\n    event Burn(address indexed user, uint256 amount, uint256 index);\n\n    /**\n     * @dev Burns user variable debt\n     * @param user The user which debt is burnt\n     * @param index The variable debt index of the reserve\n     **/\n    function burn(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n}\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n\ninterface IOptionalERC20 {\n    function decimals() external view returns (uint8);\n}\n\ninterface IPriceOracle {\n    function getAssetPrice(address _asset) external view returns (uint256);\n\n    function getAssetsPrices(address[] calldata _assets) external view returns (uint256[] memory);\n\n    function getSourceOfAsset(address _asset) external view returns (address);\n\n    function getFallbackOracle() external view returns (address);\n}\n\ninterface IStakedAave is IERC20 {\n    function stake(address to, uint256 amount) external;\n\n    function redeem(address to, uint256 amount) external;\n\n    function cooldown() external;\n\n    function claimRewards(address to, uint256 amount) external;\n\n    function getTotalRewardsBalance(address) external view returns (uint256);\n\n    //solhint-disable-next-line\n    function COOLDOWN_SECONDS() external view returns (uint256);\n\n    function stakersCooldowns(address) external view returns (uint256);\n\n    //solhint-disable-next-line\n    function UNSTAKE_WINDOW() external view returns (uint256);\n}\n\n/**\n * @title IInitializableAToken\n * @notice Interface for the initialize function on AToken\n * @author Aave\n **/\ninterface IInitializableAToken {\n    /**\n     * @dev Emitted when an aToken is initialized\n     * @param underlyingAsset The address of the underlying asset\n     * @param pool The address of the associated lending pool\n     * @param treasury The address of the treasury\n     * @param incentivesController The address of the incentives controller for this aToken\n     * @param aTokenDecimals the decimals of the underlying\n     * @param aTokenName the name of the aToken\n     * @param aTokenSymbol the symbol of the aToken\n     * @param params A set of encoded parameters for additional initialization\n     **/\n    event Initialized(\n        address indexed underlyingAsset,\n        address indexed pool,\n        address treasury,\n        address incentivesController,\n        uint8 aTokenDecimals,\n        string aTokenName,\n        string aTokenSymbol,\n        bytes params\n    );\n\n    /**\n     * @dev Initializes the aToken\n     * @param pool The address of the lending pool where this aToken will be used\n     * @param treasury The address of the Aave treasury, receiving the fees on this aToken\n     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @param incentivesController The smart contract managing potential incentives distribution\n     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's\n     * @param aTokenName The name of the aToken\n     * @param aTokenSymbol The symbol of the aToken\n     */\n    function initialize(\n        ILendingPool pool,\n        address treasury,\n        address underlyingAsset,\n        IAaveIncentivesController incentivesController,\n        uint8 aTokenDecimals,\n        string calldata aTokenName,\n        string calldata aTokenSymbol,\n        bytes calldata params\n    ) external;\n}\n\ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken {\n    /**\n     * @dev Emitted after the mint action\n     * @param from The address performing the mint\n     * @param value The amount being\n     * @param index The new liquidity index of the reserve\n     **/\n    event Mint(address indexed from, uint256 value, uint256 index);\n\n    /**\n     * @dev Mints `amount` aTokens to `user`\n     * @param user The address receiving the minted tokens\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     * @return `true` if the the previous balance of the user was 0\n     */\n    function mint(\n        address user,\n        uint256 amount,\n        uint256 index\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted after aTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param target The address that will receive the underlying\n     * @param value The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    event Burn(address indexed from, address indexed target, uint256 value, uint256 index);\n\n    /**\n     * @dev Emitted during the transfer action\n     * @param from The user whose tokens are being transferred\n     * @param to The recipient\n     * @param value The amount being transferred\n     * @param index The new liquidity index of the reserve\n     **/\n    event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index);\n\n    /**\n     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n     * @param user The owner of the aTokens, getting them burned\n     * @param receiverOfUnderlying The address that will receive the underlying\n     * @param amount The amount being burned\n     * @param index The new liquidity index of the reserve\n     **/\n    function burn(\n        address user,\n        address receiverOfUnderlying,\n        uint256 amount,\n        uint256 index\n    ) external;\n\n    /**\n     * @dev Mints aTokens to the reserve treasury\n     * @param amount The amount of tokens getting minted\n     * @param index The new liquidity index of the reserve\n     */\n    function mintToTreasury(uint256 amount, uint256 index) external;\n\n    /**\n     * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n     * @param from The address getting liquidated, current owner of the aTokens\n     * @param to The recipient\n     * @param value The amount of tokens getting transferred\n     **/\n    function transferOnLiquidation(\n        address from,\n        address to,\n        uint256 value\n    ) external;\n\n    /**\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n     * assets in borrow(), withdraw() and flashLoan()\n     * @param user The recipient of the underlying\n     * @param amount The amount getting transferred\n     * @return The amount transferred\n     **/\n    function transferUnderlyingTo(address user, uint256 amount) external returns (uint256);\n\n    /**\n     * @dev Invoked to execute actions on the aToken side after a repayment.\n     * @param user The user executing the repayment\n     * @param amount The amount getting repaid\n     **/\n    function handleRepayment(address user, uint256 amount) external;\n\n    /**\n     * @dev Returns the address of the incentives controller contract\n     **/\n    function getIncentivesController() external view returns (IAaveIncentivesController);\n\n    /**\n     * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     **/\n    //solhint-disable-next-line\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n    function baseVariableBorrowRate() external view returns (uint256);\n\n    function getMaxVariableBorrowRate() external view returns (uint256);\n\n    function stableRateSlope1() external view returns (uint256);\n\n    function stableRateSlope2() external view returns (uint256);\n\n    function variableRateSlope1() external view returns (uint256);\n\n    function variableRateSlope2() external view returns (uint256);\n\n    //solhint-disable-next-line\n    function OPTIMAL_UTILIZATION_RATE() external view returns (uint256);\n\n    function calculateInterestRates(\n        address reserve,\n        uint256 availableLiquidity,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n\n    function calculateInterestRates(\n        address reserve,\n        address aToken,\n        uint256 liquidityAdded,\n        uint256 liquidityTaken,\n        uint256 totalStableDebt,\n        uint256 totalVariableDebt,\n        uint256 averageStableBorrowRate,\n        uint256 reserveFactor\n    )\n        external\n        view\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        );\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/ComputeProfitability.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\n/// @title ComputeProfitability\n/// @author Angle Core Team\n/// @notice Helper contract to get the optimal borrow amount from a set of provided parameters from Aave\nlibrary ComputeProfitability {\n    struct SCalculateBorrow {\n        int256 reserveFactor;\n        int256 totalStableDebt;\n        int256 totalVariableDebt;\n        int256 totalDeposits;\n        int256 stableBorrowRate;\n        int256 rewardDeposit;\n        int256 rewardBorrow;\n        int256 strategyAssets;\n        int256 guessedBorrowAssets;\n        int256 slope1;\n        int256 slope2;\n        int256 r0;\n        int256 uOptimal;\n    }\n\n    int256 private constant _BASE_RAY = 10**27;\n\n    /// @notice Computes the Aave utilization ratio\n    function _computeUtilization(int256 borrow, SCalculateBorrow memory parameters) internal pure returns (int256) {\n        return\n            ((parameters.totalStableDebt + parameters.totalVariableDebt + borrow) * _BASE_RAY) /\n            (parameters.totalDeposits + borrow);\n    }\n\n    /// @notice Computes the derivative of the utilization ratio with respect to the amount borrowed\n    function _computeUprime(int256 borrow, SCalculateBorrow memory parameters) internal pure returns (int256) {\n        return\n            ((parameters.totalDeposits - parameters.totalStableDebt - parameters.totalVariableDebt) * _BASE_RAY) /\n            (parameters.totalDeposits + borrow);\n    }\n\n    /// @notice Computes the value of the interest rate, its first and second order derivatives\n    /// @dev The returned value is in `_BASE_RAY`\n    function _calculateInterestPrimes(int256 borrow, SCalculateBorrow memory parameters)\n        internal\n        pure\n        returns (\n            int256 interest,\n            int256 interestPrime,\n            int256 interestPrime2\n        )\n    {\n        int256 newUtilization = _computeUtilization(borrow, parameters);\n        int256 denomUPrime = (parameters.totalDeposits + borrow);\n        int256 uprime = _computeUprime(borrow, parameters);\n        uprime = (uprime * _BASE_RAY) / denomUPrime;\n        int256 uprime2nd = -2 * uprime;\n        uprime2nd = (uprime2nd * _BASE_RAY) / denomUPrime;\n        if (newUtilization < parameters.uOptimal) {\n            interest = parameters.r0 + (parameters.slope1 * newUtilization) / parameters.uOptimal;\n            interestPrime = (parameters.slope1 * uprime) / parameters.uOptimal;\n            interestPrime2 = (parameters.slope1 * uprime2nd) / parameters.uOptimal;\n        } else {\n            interest =\n                parameters.r0 +\n                parameters.slope1 +\n                (parameters.slope2 * (newUtilization - parameters.uOptimal)) /\n                (_BASE_RAY - parameters.uOptimal);\n            interestPrime = (parameters.slope2 * uprime) / (_BASE_RAY - parameters.uOptimal);\n            interestPrime2 = (parameters.slope2 * uprime2nd) / (_BASE_RAY - parameters.uOptimal);\n        }\n    }\n\n    /// @notice Computes the value of the revenue, as well as its first and second order derivatives\n    function _revenuePrimes(\n        int256 borrow,\n        SCalculateBorrow memory parameters,\n        bool onlyRevenue\n    )\n        internal\n        pure\n        returns (\n            int256 revenue,\n            int256 revenuePrime,\n            int256 revenuePrime2nd\n        )\n    {\n        (int256 newRate, int256 newRatePrime, int256 newRatePrime2) = _calculateInterestPrimes(borrow, parameters);\n\n        // 0 order derivative\n        int256 proportionStrat = ((borrow + parameters.strategyAssets) * (_BASE_RAY - parameters.reserveFactor)) /\n            (borrow + parameters.totalDeposits);\n        int256 poolYearlyRevenue = (parameters.totalStableDebt *\n            parameters.stableBorrowRate +\n            (borrow + parameters.totalVariableDebt) *\n            newRate) / _BASE_RAY;\n\n        revenue =\n            (proportionStrat * poolYearlyRevenue) /\n            _BASE_RAY +\n            (borrow * parameters.rewardBorrow) /\n            (borrow + parameters.totalVariableDebt) +\n            ((borrow + parameters.strategyAssets) * parameters.rewardDeposit) /\n            (borrow + parameters.totalDeposits) -\n            (borrow * newRate) /\n            _BASE_RAY;\n\n        if (!onlyRevenue) {\n            // 1st order derivative\n            {\n                // Computing block per block to avoid stack too deep errors\n                int256 proportionStratPrime = ((parameters.totalDeposits - parameters.strategyAssets) *\n                    (_BASE_RAY - parameters.reserveFactor)) / (borrow + parameters.totalDeposits);\n                proportionStratPrime = (proportionStratPrime * _BASE_RAY) / (borrow + parameters.totalDeposits);\n                int256 poolYearlyRevenuePrime = (newRate *\n                    _BASE_RAY +\n                    (borrow + parameters.totalVariableDebt) *\n                    newRatePrime) / _BASE_RAY;\n\n                revenuePrime = ((proportionStratPrime * poolYearlyRevenue + poolYearlyRevenuePrime * proportionStrat) /\n                    _BASE_RAY);\n\n                {\n                    int256 proportionStratPrime2nd = (-2 * (proportionStratPrime * (_BASE_RAY))) /\n                        ((borrow + parameters.totalDeposits));\n                    revenuePrime2nd =\n                        2 *\n                        proportionStratPrime *\n                        poolYearlyRevenuePrime +\n                        proportionStratPrime2nd *\n                        poolYearlyRevenue;\n                }\n                poolYearlyRevenuePrime =\n                    (2 * newRatePrime * _BASE_RAY + (borrow + parameters.totalVariableDebt) * newRatePrime2) /\n                    _BASE_RAY;\n\n                revenuePrime2nd = (revenuePrime2nd + poolYearlyRevenuePrime * proportionStrat) / _BASE_RAY;\n            }\n\n            int256 costPrime = (newRate * _BASE_RAY + borrow * newRatePrime) / _BASE_RAY;\n            int256 rewardBorrowPrime = (parameters.rewardBorrow * (parameters.totalVariableDebt)) /\n                (borrow + parameters.totalVariableDebt);\n            rewardBorrowPrime = (rewardBorrowPrime * _BASE_RAY) / (borrow + parameters.totalVariableDebt);\n            int256 rewardDepositPrime = (parameters.rewardDeposit *\n                (parameters.totalDeposits - parameters.strategyAssets)) / (borrow + parameters.totalDeposits);\n            rewardDepositPrime = (rewardDepositPrime * _BASE_RAY) / (borrow + parameters.totalDeposits);\n\n            revenuePrime += rewardBorrowPrime + rewardDepositPrime - costPrime;\n\n            // 2nd order derivative\n            // Reusing variables for the stack too deep issue\n            costPrime = ((2 * newRatePrime * _BASE_RAY) + borrow * newRatePrime2) / _BASE_RAY;\n            rewardBorrowPrime = (-2 * rewardBorrowPrime * _BASE_RAY) / (borrow + parameters.totalVariableDebt);\n            rewardDepositPrime = (-2 * rewardDepositPrime * _BASE_RAY) / (borrow + parameters.totalDeposits);\n\n            revenuePrime2nd += (rewardBorrowPrime + rewardDepositPrime) - costPrime;\n        }\n    }\n\n    /// @notice Returns the absolute value of an integer\n    function _abs(int256 x) private pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n\n    /// @notice Computes the optimal borrow amount of the strategy depending on Aave protocol parameters\n    /// to maximize folding revenues\n    /// @dev Performs a newton Raphson approximation to get the zero point of the derivative of the\n    /// revenue function of the protocol depending on the amount borrowed\n    function computeProfitability(SCalculateBorrow memory parameters) internal pure returns (int256 borrow) {\n        (int256 y, , ) = _revenuePrimes(0, parameters, true);\n        (int256 revenueWithBorrow, , ) = _revenuePrimes(_BASE_RAY, parameters, true);\n\n        if (revenueWithBorrow <= y) {\n            return 0;\n        }\n        uint256 count;\n        int256 borrowInit;\n        int256 grad;\n        int256 grad2nd;\n        borrow = parameters.guessedBorrowAssets;\n        // Tolerance is 1% in this method: indeed we're stopping: `_abs(borrowInit - borrow)/ borrowInit < 10**(-2)`\n        while (count < 10 && (count == 0 || _abs(borrowInit - borrow) * (10**2 / 5) > borrowInit)) {\n            (, grad, grad2nd) = _revenuePrimes(borrow, parameters, false);\n            borrowInit = borrow;\n            borrow = borrowInit - (grad * _BASE_RAY) / grad2nd;\n            count += 1;\n        }\n\n        (int256 x, , ) = _revenuePrimes(borrow, parameters, true);\n        if (x <= y) {\n            borrow = 0;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC3156FlashLender.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC3156FlashBorrower.sol\";\n\n/**\n * @dev Interface of the ERC3156 FlashLender, as defined in\n * https://eips.ethereum.org/EIPS/eip-3156[ERC-3156].\n *\n * _Available since v4.1._\n */\ninterface IERC3156FlashLender {\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}\n"
    },
    "contracts/strategies/AaveFlashloanStrategy/ComputeProfitabilityTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"./ComputeProfitability.sol\";\n\n/// @title ComputeProfitabilityTest\n/// @author Angle Core Team\n/// @notice Wrapper contract to ComputeProfitability for testing purpose\ncontract ComputeProfitabilityTest {\n    /// @notice external version of _calculateInterestPrimes\n    function calculateInterestPrimes(int256 borrow, ComputeProfitability.SCalculateBorrow memory parameters)\n        external\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        return ComputeProfitability._calculateInterestPrimes(borrow, parameters);\n    }\n\n    /// @notice External version of _revenuePrimes\n    function revenuePrimes(\n        int256 borrow,\n        ComputeProfitability.SCalculateBorrow memory parameters,\n        bool onlyRevenue\n    )\n        external\n        pure\n        returns (\n            int256,\n            int256,\n            int256\n        )\n    {\n        return ComputeProfitability._revenuePrimes(borrow, parameters, onlyRevenue);\n    }\n\n    /// @notice Computes the optimal borrow amount of the strategy depending on Aave protocol parameters\n    /// to maximize folding revenues\n    function computeProfitability(ComputeProfitability.SCalculateBorrow memory parameters)\n        external\n        pure\n        returns (int256)\n    {\n        return ComputeProfitability.computeProfitability(parameters);\n    }\n}\n"
    },
    "contracts/strategies/OptimizerAPR/OptimizerAPRStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../BaseStrategyUpgradeable.sol\";\nimport \"../../interfaces/IGenericLender.sol\";\n\n/// @title Strategy\n/// @author Forked from https://github.com/Grandthrax/yearnV2-generic-lender-strat\n/// @notice A lender optimisation strategy for any ERC20 asset\n/// @dev This strategy works by taking plugins designed for standard lending platforms\n/// It automatically chooses the best yield generating platform and adjusts accordingly\n/// The adjustment is sub optimal so there is an additional option to manually set position\ncontract OptimizerAPRStrategy is BaseStrategyUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ======================== References to contracts ============================\n\n    IGenericLender[] public lenders;\n\n    // ======================== Parameters =========================================\n\n    uint256 public withdrawalThreshold;\n\n    event AddLender(address indexed lender);\n\n    event RemoveLender(address indexed lender);\n\n    // ============================== Constructor ==================================\n\n    /// @notice Constructor of the `Strategy`\n    /// @param _poolManager Address of the `PoolManager` lending to this strategy\n    /// @param governor Address with governor privilege\n    /// @param guardian Address of the guardian\n    function initialize(\n        address _poolManager,\n        address governor,\n        address guardian,\n        address[] memory keepers\n    ) external {\n        _initialize(_poolManager, governor, guardian, keepers);\n        withdrawalThreshold = 1000 * wantBase;\n    }\n\n    // ========================== Internal Mechanics ===============================\n\n    /// @notice Frees up profit plus `_debtOutstanding`.\n    /// @param _debtOutstanding Amount to withdraw\n    /// @return _profit Profit freed by the call\n    /// @return _loss Loss discovered by the call\n    /// @return _debtPayment Amount freed to reimburse the debt\n    /// @dev If `_debtOutstanding` is more than we can free we get as much as possible.\n    function _prepareReturn(uint256 _debtOutstanding)\n        internal\n        override\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        )\n    {\n        _profit = 0;\n        _loss = 0; //for clarity\n        _debtPayment = _debtOutstanding;\n\n        uint256 lentAssets = lentTotalAssets();\n\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        uint256 total = looseAssets + lentAssets;\n\n        if (lentAssets == 0) {\n            // No position to harvest or profit to report\n            if (_debtPayment > looseAssets) {\n                // We can only return looseAssets\n                _debtPayment = looseAssets;\n            }\n\n            return (_profit, _loss, _debtPayment);\n        }\n\n        uint256 debt = poolManager.strategies(address(this)).totalStrategyDebt;\n\n        if (total > debt) {\n            _profit = total - debt;\n\n            uint256 amountToFree = _profit + _debtPayment;\n            // We need to add outstanding to our profit\n            // don't need to do logic if there is nothing to free\n            if (amountToFree > 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust _debtOutstanding and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_profit > newLoose) {\n                        _profit = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _profit, _debtPayment);\n                    }\n                }\n            }\n        } else {\n            // Serious loss should never happen but if it does lets record it accurately\n            _loss = debt - total;\n\n            uint256 amountToFree = _loss + _debtPayment;\n            if (amountToFree > 0 && looseAssets < amountToFree) {\n                // Withdraw what we can withdraw\n\n                _withdrawSome(amountToFree - looseAssets);\n                uint256 newLoose = want.balanceOf(address(this));\n\n                // If we dont have enough money adjust `_debtOutstanding` and only change profit if needed\n                if (newLoose < amountToFree) {\n                    if (_loss > newLoose) {\n                        _loss = newLoose;\n                        _debtPayment = 0;\n                    } else {\n                        _debtPayment = Math.min(newLoose - _loss, _debtPayment);\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Estimates highest and lowest apr lenders among a `lendersList`\n    /// @param lendersList List of all the lender contracts associated to this strategy\n    /// @return _lowest The index of the lender in the `lendersList` with lowest apr\n    /// @return _lowestApr The lowest apr\n    /// @return _highest The index of the lender with highest apr\n    /// @return _potential The potential apr of this lender if funds are moved from lowest to highest\n    /// @dev `lendersList` is kept as a parameter to avoid multiplying reads in storage to the `lenders`\n    /// array\n    function _estimateAdjustPosition(IGenericLender[] memory lendersList)\n        internal\n        view\n        returns (\n            uint256 _lowest,\n            uint256 _lowestApr,\n            uint256 _highest,\n            uint256 _potential\n        )\n    {\n        //all loose assets are to be invested\n        uint256 looseAssets = want.balanceOf(address(this));\n\n        // our simple algo\n        // get the lowest apr strat\n        // cycle through and see who could take its funds plus want for the highest apr\n        _lowestApr = type(uint256).max;\n        _lowest = 0;\n        uint256 lowestNav = 0;\n\n        uint256 highestApr = 0;\n        _highest = 0;\n\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            uint256 aprAfterDeposit = lendersList[i].aprAfterDeposit(looseAssets);\n            if (aprAfterDeposit > highestApr) {\n                highestApr = aprAfterDeposit;\n                _highest = i;\n            }\n\n            if (lendersList[i].hasAssets()) {\n                uint256 apr = lendersList[i].apr();\n                if (apr < _lowestApr) {\n                    _lowestApr = apr;\n                    _lowest = i;\n                    lowestNav = lendersList[i].nav();\n                }\n            }\n        }\n\n        //if we can improve apr by withdrawing we do so\n        _potential = lendersList[_highest].aprAfterDeposit(lowestNav + looseAssets);\n    }\n\n    /// @notice Function called by keepers to adjust the position\n    /// @dev The algorithm moves assets from lowest return to highest\n    /// like a very slow idiot bubble sort\n    function _adjustPosition() internal override {\n        // Emergency exit is dealt with at beginning of harvest\n        if (emergencyExit) {\n            return;\n        }\n        // Storing the `lenders` array in a cache variable\n        IGenericLender[] memory lendersList = lenders;\n        // We just keep all money in want if we dont have any lenders\n        if (lendersList.length == 0) {\n            return;\n        }\n\n        (uint256 lowest, uint256 lowestApr, uint256 highest, uint256 potential) = _estimateAdjustPosition(lendersList);\n\n        if (potential > lowestApr) {\n            // Apr should go down after deposit so won't be withdrawing from self\n            lendersList[lowest].withdrawAll();\n        }\n\n        uint256 bal = want.balanceOf(address(this));\n        if (bal > 0) {\n            want.safeTransfer(address(lendersList[highest]), bal);\n            lendersList[highest].deposit();\n        }\n    }\n\n    /// @notice Function needed to inherit the baseStrategyUpgradeable\n    function _adjustPosition(uint256) internal override {\n        _adjustPosition();\n    }\n\n    /// @notice Withdraws a given amount from lenders\n    /// @param _amount The amount to withdraw\n    /// @dev Cycle through withdrawing from worst rate first\n    function _withdrawSome(uint256 _amount) internal returns (uint256 amountWithdrawn) {\n        IGenericLender[] memory lendersList = lenders;\n        if (lendersList.length == 0) {\n            return 0;\n        }\n\n        // Don't withdraw dust\n        if (_amount < withdrawalThreshold) {\n            return 0;\n        }\n\n        amountWithdrawn = 0;\n        // In most situations this will only run once. Only big withdrawals will be a gas guzzler\n        uint256 j = 0;\n        while (amountWithdrawn < _amount) {\n            uint256 lowestApr = type(uint256).max;\n            uint256 lowest = 0;\n            for (uint256 i = 0; i < lendersList.length; i++) {\n                if (lendersList[i].hasAssets()) {\n                    uint256 apr = lendersList[i].apr();\n                    if (apr < lowestApr) {\n                        lowestApr = apr;\n                        lowest = i;\n                    }\n                }\n            }\n            if (!lendersList[lowest].hasAssets()) {\n                return amountWithdrawn;\n            }\n            amountWithdrawn = amountWithdrawn + lendersList[lowest].withdraw(_amount - amountWithdrawn);\n            j++;\n            // To avoid want infinite loop\n            if (j >= 6) {\n                return amountWithdrawn;\n            }\n        }\n    }\n\n    /// @notice Liquidates up to `_amountNeeded` of `want` of this strategy's positions,\n    /// irregardless of slippage. Any excess will be re-invested with `_adjustPosition()`.\n    /// This function should return the amount of `want` tokens made available by the\n    /// liquidation. If there is a difference between them, `_loss` indicates whether the\n    /// difference is due to a realized loss, or if there is some other sitution at play\n    /// (e.g. locked funds) where the amount made available is less than what is needed.\n    ///\n    /// NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n    function _liquidatePosition(uint256 _amountNeeded) internal override returns (uint256 _amountFreed, uint256 _loss) {\n        uint256 _balance = want.balanceOf(address(this));\n\n        if (_balance >= _amountNeeded) {\n            //if we don't set reserve here withdrawer will be sent our full balance\n            return (_amountNeeded, 0);\n        } else {\n            uint256 received = _withdrawSome(_amountNeeded - _balance) + (_balance);\n            if (received >= _amountNeeded) {\n                return (_amountNeeded, 0);\n            } else {\n                return (received, 0);\n            }\n        }\n    }\n\n    /// @notice Liquidates everything and returns the amount that got freed.\n    /// This function is used during emergency exit instead of `_prepareReturn()` to\n    /// liquidate all of the Strategy's positions back to the Manager.\n    function _liquidateAllPositions() internal override returns (uint256 _amountFreed) {\n        (_amountFreed, ) = _liquidatePosition(estimatedTotalAssets());\n    }\n\n    // ========================== View Functions ===================================\n\n    struct LendStatus {\n        string name;\n        uint256 assets;\n        uint256 rate;\n        address add;\n    }\n\n    /// @notice View function to check the current state of the strategy\n    /// @return Returns the status of all lenders attached the strategy\n    function lendStatuses() external view returns (LendStatus[] memory) {\n        uint256 lendersListLength = lenders.length;\n        LendStatus[] memory statuses = new LendStatus[](lendersListLength);\n        for (uint256 i = 0; i < lendersListLength; i++) {\n            LendStatus memory s;\n            s.name = lenders[i].lenderName();\n            s.add = address(lenders[i]);\n            s.assets = lenders[i].nav();\n            s.rate = lenders[i].apr();\n            statuses[i] = s;\n        }\n        return statuses;\n    }\n\n    /// @notice View function to check the total assets lent\n    function lentTotalAssets() public view returns (uint256) {\n        uint256 nav = 0;\n        for (uint256 i = 0; i < lenders.length; i++) {\n            nav = nav + lenders[i].nav();\n        }\n        return nav;\n    }\n\n    /// @notice View function to check the total assets managed by the strategy\n    function estimatedTotalAssets() public view override returns (uint256 nav) {\n        nav = lentTotalAssets() + want.balanceOf(address(this));\n    }\n\n    /// @notice View function to check the number of lending platforms\n    function numLenders() external view returns (uint256) {\n        return lenders.length;\n    }\n\n    /// @notice The weighted apr of all lenders. sum(nav * apr)/totalNav\n    function estimatedAPR() external view returns (uint256) {\n        uint256 bal = estimatedTotalAssets();\n        if (bal == 0) {\n            return 0;\n        }\n\n        uint256 weightedAPR = 0;\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            weightedAPR = weightedAPR + lenders[i].weightedApr();\n        }\n\n        return weightedAPR / bal;\n    }\n\n    /// @notice Prevents the governance from withdrawing want tokens\n    function _protectedTokens() internal view override returns (address[] memory) {\n        address[] memory protected = new address[](1);\n        protected[0] = address(want);\n        return protected;\n    }\n\n    // ============================ Governance =====================================\n\n    struct LenderRatio {\n        address lender;\n        //share x 1000\n        uint16 share;\n    }\n\n    /// @notice Reallocates all funds according to a new distributions\n    /// @param _newPositions List of shares to specify the new allocation\n    /// @dev Share must add up to 1000. 500 means 50% etc\n    /// @dev This code has been forked, so we have not thoroughly tested it on our own\n    function manualAllocation(LenderRatio[] memory _newPositions) external onlyRole(GUARDIAN_ROLE) {\n        IGenericLender[] memory lendersList = lenders;\n        uint256 share = 0;\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            lendersList[i].withdrawAll();\n        }\n\n        uint256 assets = want.balanceOf(address(this));\n\n        for (uint256 i = 0; i < _newPositions.length; i++) {\n            bool found = false;\n\n            //might be annoying and expensive to do this second loop but worth it for safety\n            for (uint256 j = 0; j < lendersList.length; j++) {\n                if (address(lendersList[j]) == _newPositions[i].lender) {\n                    found = true;\n                }\n            }\n            require(found, \"94\");\n\n            share = share + _newPositions[i].share;\n            uint256 toSend = (assets * _newPositions[i].share) / 1000;\n            want.safeTransfer(_newPositions[i].lender, toSend);\n            IGenericLender(_newPositions[i].lender).deposit();\n        }\n\n        require(share == 1000, \"95\");\n    }\n\n    /// @notice Changes the withdrawal threshold\n    /// @param _threshold The new withdrawal threshold\n    /// @dev governor, guardian or `PoolManager` only\n    function setWithdrawalThreshold(uint256 _threshold) external onlyRole(GUARDIAN_ROLE) {\n        withdrawalThreshold = _threshold;\n    }\n\n    /// @notice Add lenders for the strategy to choose between\n    /// @param newLender The adapter to the added lending platform\n    /// @dev Governor, guardian or `PoolManager` only\n    function addLender(IGenericLender newLender) external onlyRole(GUARDIAN_ROLE) {\n        require(newLender.strategy() == address(this), \"96\");\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n            require(address(newLender) != address(lenders[i]), \"97\");\n        }\n        lenders.push(newLender);\n\n        emit AddLender(address(newLender));\n    }\n\n    /// @notice Removes a lending platform and fails if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function safeRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, false);\n    }\n\n    /// @notice Removes a lending platform and even if total withdrawal is impossible\n    /// @param lender The address of the adapter to the lending platform to remove\n    function forceRemoveLender(address lender) external onlyRole(GUARDIAN_ROLE) {\n        _removeLender(lender, true);\n    }\n\n    /// @notice Internal function to handle lending platform removing\n    /// @param lender The address of the adapter for the lending platform to remove\n    /// @param force Whether it is required that all the funds are withdrawn prior to removal\n    function _removeLender(address lender, bool force) internal {\n        IGenericLender[] memory lendersList = lenders;\n        for (uint256 i = 0; i < lendersList.length; i++) {\n            if (lender == address(lendersList[i])) {\n                bool allWithdrawn = lendersList[i].withdrawAll();\n\n                if (!force) {\n                    require(allWithdrawn, \"98\");\n                }\n\n                // Put the last index here\n                // then remove last index\n                if (i != lendersList.length - 1) {\n                    lenders[i] = lendersList[lendersList.length - 1];\n                }\n\n                // Pop shortens array by 1 thereby deleting the last index\n                lenders.pop();\n\n                // If balance to spend we might as well put it into the best lender\n                if (want.balanceOf(address(this)) > 0) {\n                    _adjustPosition();\n                }\n\n                emit RemoveLender(lender);\n\n                return;\n            }\n        }\n        require(false, \"94\");\n    }\n\n    // ========================== Manager functions ================================\n\n    /// @notice Adds a new guardian address and echoes the change to the contracts\n    /// that interact with this collateral `PoolManager`\n    /// @param _guardian New guardian address\n    /// @dev This internal function has to be put in this file because `AccessControl` is not defined\n    /// in `PoolManagerInternal`\n    function addGuardian(address _guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role in other contract\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].grantRole(GUARDIAN_ROLE, _guardian);\n        }\n    }\n\n    /// @notice Revokes the guardian role and propagates the change to other contracts\n    /// @param guardian Old guardian address to revoke\n    function revokeGuardian(address guardian) external override onlyRole(POOLMANAGER_ROLE) {\n        _revokeRole(GUARDIAN_ROLE, guardian);\n        for (uint256 i = 0; i < lenders.length; i++) {\n            lenders[i].revokeRole(GUARDIAN_ROLE, guardian);\n        }\n    }\n}\n"
    },
    "contracts/mock/MockPoolManager2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../external/AccessControlUpgradeable.sol\";\n\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\nimport \"../utils/FunctionUtils.sol\";\n\nstruct SLPData {\n    // Last timestamp at which the `sanRate` has been updated for SLPs\n    uint256 lastBlockUpdated;\n    // Fees accumulated from previous blocks and to be distributed to SLPs\n    uint256 lockedInterests;\n    // Max interests used to update the `sanRate` in a single block\n    // Should be in collateral token base\n    uint256 maxInterestsDistributed;\n    // Amount of fees left aside for SLPs and that will be distributed\n    // when the protocol is collateralized back again\n    uint256 feesAside;\n    // Part of the fees normally going to SLPs that is left aside\n    // before the protocol is collateralized back again (depends on collateral ratio)\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippageFee;\n    // Portion of the fees from users minting and burning\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 feesForSLPs;\n    // Slippage factor that's applied to SLPs exiting (depends on collateral ratio)\n    // If `slippage = BASE_PARAMS`, SLPs can get nothing, if `slippage = 0` they get their full claim\n    // Updated by keepers and scaled by `BASE_PARAMS`\n    uint64 slippage;\n    // Portion of the interests from lending\n    // that goes to SLPs (the rest goes to surplus)\n    uint64 interestsForSLPs;\n}\n\nstruct MintBurnData {\n    // Values of the thresholds to compute the minting fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeMint;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeMint;\n    // Values of the thresholds to compute the burning fees\n    // depending on HA hedge (scaled by `BASE_PARAMS`)\n    uint64[] xFeeBurn;\n    // Values of the fees at thresholds (scaled by `BASE_PARAMS`)\n    uint64[] yFeeBurn;\n    // Max proportion of collateral from users that can be covered by HAs\n    // It is exactly the same as the parameter of the same name in `PerpetualManager`, whenever one is updated\n    // the other changes accordingly\n    uint64 targetHAHedge;\n    // Minting fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusMint;\n    // Burning fees correction set by the `FeeManager` contract: they are going to be multiplied\n    // to the value of the fees computed using the hedge curve\n    // Scaled by `BASE_PARAMS`\n    uint64 bonusMalusBurn;\n    // Parameter used to limit the number of stablecoins that can be issued using the concerned collateral\n    uint256 capOnStableMinted;\n}\n\ninterface IOracle {\n    function read() external view returns (uint256);\n\n    function readAll() external view returns (uint256 lowerRate, uint256 upperRate);\n\n    function readLower() external view returns (uint256);\n\n    function readUpper() external view returns (uint256);\n\n    function readQuote(uint256 baseAmount) external view returns (uint256);\n\n    function readQuoteLower(uint256 baseAmount) external view returns (uint256);\n\n    function inBase() external view returns (uint256);\n}\n\ninterface ISanToken is IERC20 {\n    function mint(address account, uint256 amount) external;\n\n    function burnFrom(\n        uint256 amount,\n        address burner,\n        address sender\n    ) external;\n\n    function burnSelf(uint256 amount, address burner) external;\n\n    function stableMaster() external view returns (address);\n\n    function poolManager() external view returns (address);\n}\n\ninterface IStableMaster {\n    function agToken() external view returns (address);\n\n    function signalLoss(uint256 loss) external;\n\n    function accumulateInterest(uint256 gain) external;\n\n    function collateralMap(IPoolManager poolManager)\n        external\n        view\n        returns (\n            IERC20 token,\n            ISanToken sanToken,\n            address perpetualManager,\n            IOracle oracle,\n            uint256 stocksUsers,\n            uint256 sanRate,\n            uint256 collatBase,\n            SLPData memory slpData,\n            MintBurnData memory feeData\n        );\n}\n\n/// @title PoolManager\n/// @author Angle Core Team\n/// @notice The `PoolManager` contract corresponds to a collateral pool of the protocol for a stablecoin,\n/// it manages a single ERC20 token. It is responsible for interacting with the strategies enabling the protocol\n/// to get yield on its collateral\n/// @dev This file contains the functions that are callable by governance or by other contracts of the protocol\n/// @dev References to this contract are called `PoolManager`\ncontract PoolManager is IPoolManagerFunctions, AccessControlUpgradeable, FunctionUtils {\n    using SafeERC20 for IERC20;\n\n    /// @notice Interface for the underlying token accepted by this contract\n    IERC20 public token;\n\n    /// @notice Reference to the `StableMaster` contract corresponding to this `PoolManager`\n    IStableMaster public stableMaster;\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Funds currently given to strategies\n    uint256 public totalDebt;\n\n    /// @notice Proportion of the funds managed dedicated to strategies\n    /// Has to be between 0 and `BASE_PARAMS`\n    uint256 public debtRatio;\n\n    /// The struct `StrategyParams` is defined in the interface `IPoolManager`\n    /// @notice Mapping between the address of a strategy contract and its corresponding details\n    mapping(address => StrategyParams) public strategies;\n\n    /// @notice List of the current strategies\n    address[] public strategyList;\n\n    /// @notice Address of the surplus distributor allowed to distribute rewards\n    address public surplusConverter;\n\n    /// @notice Share of the interests going to surplus and share going to SLPs\n    uint64 public interestsForSurplus;\n\n    /// @notice Interests accumulated by the protocol and to be distributed through ANGLE or veANGLE\n    /// token holders\n    uint256 public interestsAccumulated;\n\n    /// @notice Debt that must be paid by admins after a loss on a strategy\n    uint256 public adminDebt;\n\n    event FeesDistributed(uint256 amountDistributed);\n\n    event Recovered(address indexed token, address indexed to, uint256 amount);\n\n    event StrategyAdded(address indexed strategy, uint256 debtRatio);\n\n    event InterestsForSurplusUpdated(uint64 _interestsForSurplus);\n\n    event SurplusConverterUpdated(address indexed newSurplusConverter, address indexed oldSurplusConverter);\n\n    event StrategyRevoked(address indexed strategy);\n\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 totalDebt\n    );\n\n    // Roles need to be defined here because there are some internal access control functions\n    // in the `PoolManagerInternal` file\n\n    /// @notice Role for `StableMaster` only\n    bytes32 public constant STABLEMASTER_ROLE = keccak256(\"STABLEMASTER_ROLE\");\n    /// @notice Role for governors only\n    bytes32 public constant GOVERNOR_ROLE = keccak256(\"GOVERNOR_ROLE\");\n    /// @notice Role for guardians and governors\n    bytes32 public constant GUARDIAN_ROLE = keccak256(\"GUARDIAN_ROLE\");\n    /// @notice Role for `Strategy` only\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n\n    constructor(\n        address _token,\n        address governor,\n        address guardian\n    ) {\n        token = IERC20(_token);\n        _setupRole(GUARDIAN_ROLE, guardian);\n        _setupRole(GUARDIAN_ROLE, governor);\n        _setupRole(GOVERNOR_ROLE, governor);\n        _setRoleAdmin(GOVERNOR_ROLE, GOVERNOR_ROLE);\n        _setRoleAdmin(GUARDIAN_ROLE, GOVERNOR_ROLE);\n    }\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Internal version of `updateStrategyDebtRatio`\n    /// @dev Updates the debt ratio for a strategy\n    function _updateStrategyDebtRatio(address strategy, uint256 _debtRatio) internal {\n        StrategyParams storage params = strategies[strategy];\n        require(params.lastReport != 0, \"78\");\n        debtRatio = debtRatio + _debtRatio - params.debtRatio;\n        require(debtRatio <= BASE_PARAMS, \"76\");\n        params.debtRatio = _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n    }\n\n    // ============================ Utils ==========================================\n\n    /// @notice Returns this `PoolManager`'s reserve of collateral (not including what has been lent)\n    function _getBalance() internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Returns the amount of assets owned by this `PoolManager`\n    /// @dev This sums the current balance of the contract to what has been given to strategies\n    /// @dev This amount can be manipulated by flash loans\n    function _getTotalAsset() internal view returns (uint256) {\n        return _getBalance() + totalDebt;\n    }\n\n    // ============================= Yield Farming =================================\n\n    /// @notice Provides an estimated Annual Percentage Rate for SLPs based on lending to other protocols\n    /// @dev This function is an estimation and is made for external use only\n    /// @dev This does not take into account transaction fees which accrue to SLPs too\n    /// @dev This can be manipulated by a flash loan attack (SLP deposit/ withdraw) via `_getTotalAsset`\n    /// when entering you should make sure this hasn't be called by a flash loan and look\n    /// at a mean of past APR.\n    function estimatedAPR() external view returns (uint256 apr) {\n        apr = 0;\n        (, ISanToken sanTokenForAPR, , , , uint256 sanRate, , SLPData memory slpData, ) = stableMaster.collateralMap(\n            IPoolManager(address(this))\n        );\n        uint256 supply = sanTokenForAPR.totalSupply();\n\n        // `sanRate` should never be equal to 0\n        if (supply == 0) return type(uint256).max;\n\n        for (uint256 i = 0; i < strategyList.length; i++) {\n            apr =\n                apr +\n                (strategies[strategyList[i]].debtRatio * IStrategy(strategyList[i]).estimatedAPR()) /\n                BASE_PARAMS;\n        }\n        apr = (apr * slpData.interestsForSLPs * _getTotalAsset()) / sanRate / supply;\n    }\n\n    /// @notice Tells a strategy how much it can borrow from this `PoolManager`\n    /// @return Amount of token a strategy has access to as a credit line\n    /// @dev Since this function is a view function, there is no need to have an access control logic\n    /// even though it will just be relevant for a strategy\n    /// @dev Manipulating `_getTotalAsset` with a flashloan will only\n    /// result in tokens being transferred at the cost of the caller\n    function creditAvailable() external view override returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        if (target < params.totalStrategyDebt) return 0;\n\n        return Math.min(target - params.totalStrategyDebt, _getBalance());\n    }\n\n    /// @notice Tells a strategy how much it owes to this `PoolManager`\n    /// @return Amount of token a strategy has to reimburse\n    /// @dev Manipulating `_getTotalAsset` with a flashloan will only\n    /// result in tokens being transferred at the cost of the caller\n    function debtOutstanding() external view override returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        if (target > params.totalStrategyDebt) return 0;\n\n        return (params.totalStrategyDebt - target);\n    }\n\n    /// @notice Reports the gains or loss made by a strategy\n    /// @param gain Amount strategy has realized as a gain on its investment since its\n    /// last report, and is free to be given back to `PoolManager` as earnings\n    /// @param loss Amount strategy has realized as a loss on its investment since its\n    /// last report, and should be accounted for on the `PoolManager`'s balance sheet.\n    /// The loss will reduce the `debtRatio`. The next time the strategy will harvest,\n    /// it will pay back the debt in an attempt to adjust to the new debt limit.\n    /// @param debtPayment Amount strategy has made available to cover outstanding debt\n    /// @dev This is the main contact point where the strategy interacts with the `PoolManager`\n    /// @dev The strategy reports back what it has free, then the `PoolManager` contract \"decides\"\n    /// whether to take some back or give it more. Note that the most it can\n    /// take is `gain + _debtPayment`, and the most it can give is all of the\n    /// remaining reserves. Anything outside of those bounds is abnormal behavior.\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external override onlyRole(STRATEGY_ROLE) {\n        require(token.balanceOf(msg.sender) >= gain + debtPayment, \"72\");\n\n        StrategyParams storage params = strategies[msg.sender];\n        // Updating parameters in the `perpetualManager`\n        // This needs to be done now because it has implications in `_getTotalAsset()`\n        params.totalStrategyDebt = params.totalStrategyDebt + gain - loss;\n        totalDebt = totalDebt + gain - loss;\n        params.lastReport = block.timestamp;\n\n        // Warning: `_getTotalAsset` could be manipulated by flashloan attacks.\n        // It may allow external users to transfer funds into strategy or remove funds\n        // from the strategy. Yet, as it does not impact the profit or loss and as attackers\n        // have no interest in making such txs to have a direct profit, we let it as is.\n        // The only issue is if the strategy is compromised; in this case governance\n        // should revoke the strategy\n        uint256 target = ((_getTotalAsset()) * params.debtRatio) / BASE_PARAMS;\n\n        if (target > params.totalStrategyDebt) {\n            // If the strategy has some credit left, tokens can be transferred to this strategy\n            uint256 available = Math.min(target - params.totalStrategyDebt, _getBalance());\n            params.totalStrategyDebt = params.totalStrategyDebt + available;\n            totalDebt = totalDebt + available;\n            if (available > 0) {\n                token.safeTransfer(msg.sender, available);\n            }\n        } else {\n            uint256 available = Math.min(params.totalStrategyDebt - target, debtPayment + gain);\n            params.totalStrategyDebt = params.totalStrategyDebt - available;\n            totalDebt = totalDebt - available;\n            if (available > 0) {\n                token.safeTransferFrom(msg.sender, address(this), available);\n            }\n        }\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, params.totalStrategyDebt);\n\n        // Handle gains before losses\n        if (gain > 0) {\n            uint256 gainForSurplus = (gain * interestsForSurplus) / BASE_PARAMS;\n            uint256 adminDebtPre = adminDebt;\n            // Depending on the current admin debt distribute the necessary gain from the strategies\n            if (adminDebtPre == 0) interestsAccumulated += gainForSurplus;\n            else if (adminDebtPre <= gainForSurplus) {\n                interestsAccumulated += gainForSurplus - adminDebtPre;\n                adminDebt = 0;\n            } else adminDebt -= gainForSurplus;\n            // stableMaster.accumulateInterest(gain - gainForSurplus);\n            emit FeesDistributed(gain);\n        }\n\n        // Handle eventual losses\n        if (loss > 0) {\n            uint256 lossForSurplus = (loss * interestsForSurplus) / BASE_PARAMS;\n            uint256 interestsAccumulatedPreLoss = interestsAccumulated;\n            // If the loss can not be entirely soaked by the interests to be distributed then\n            // the protocol keeps track of the debt\n            if (lossForSurplus > interestsAccumulatedPreLoss) {\n                interestsAccumulated = 0;\n                adminDebt += lossForSurplus - interestsAccumulatedPreLoss;\n            } else interestsAccumulated -= lossForSurplus;\n            // The rest is incurred to SLPs\n            // stableMaster.signalLoss(loss - lossForSurplus);\n        }\n    }\n\n    // =========================== Governor Functions ==============================\n\n    /// @notice Allows to recover any ERC20 token, including the token handled by this contract, and to send it\n    /// to a contract\n    /// @param tokenAddress Address of the token to recover\n    /// @param to Address of the contract to send collateral to\n    /// @param amountToRecover Amount of collateral to transfer\n    /// @dev As this function can be used to transfer funds to another contract, it has to be a `GOVERNOR` function\n    /// @dev In case the concerned token is the specific token handled by this contract, this function checks that the\n    /// amount entered is not too big and approximates the surplus of the protocol\n    /// @dev To esimate the amount of user claims on the concerned collateral, this function uses the `stocksUsers` for\n    /// this collateral, but this is just an approximation as users can claim the collateral of their choice provided\n    /// that they own a stablecoin\n    /// @dev The sanity check excludes the HA claims: to get a sense of it, this function would need to compute the cash out\n    /// amount of all the perpetuals, and this cannot be done on-chain in a cheap manner\n    /// @dev Overall, even though there is a sanity check, this function relies on the fact that governance is not corrupted\n    /// in this protocol and will not try to withdraw too much funds\n    function recoverERC20(\n        address tokenAddress,\n        address to,\n        uint256 amountToRecover\n    ) external onlyRole(GOVERNOR_ROLE) {\n        if (tokenAddress == address(token)) {\n            // Fetching info from the `StableMaster`\n            (\n                ,\n                ISanToken sanToken,\n                ,\n                IOracle oracle,\n                uint256 stocksUsers,\n                uint256 sanRate,\n                uint256 collatBase,\n                ,\n\n            ) = stableMaster.collateralMap(IPoolManager(address(this)));\n\n            // Checking if there are enough reserves for the amount to withdraw\n            require(\n                _getTotalAsset() >=\n                    amountToRecover +\n                        (sanToken.totalSupply() * sanRate) /\n                        BASE_TOKENS +\n                        (stocksUsers * collatBase) /\n                        oracle.readUpper() +\n                        interestsAccumulated,\n                \"66\"\n            );\n\n            token.safeTransfer(to, amountToRecover);\n        } else {\n            IERC20(tokenAddress).safeTransfer(to, amountToRecover);\n        }\n        emit Recovered(tokenAddress, to, amountToRecover);\n    }\n\n    /// @notice Adds a strategy to the `PoolManager`\n    /// @param strategy The address of the strategy to add\n    /// @param _debtRatio The share of the total assets that the strategy has access to\n    /// @dev Multiple checks are made. For instance, the contract must not already belong to the `PoolManager`\n    /// and the underlying token of the strategy has to be consistent with the `PoolManager` contracts\n    /// @dev This function is a `governor` function and not a `guardian` one because a `guardian` could add a strategy\n    /// enabling the withdraw of the funds of the protocol\n    /// @dev The `_debtRatio` should be expressed in `BASE_PARAMS`\n    function addStrategy(address strategy, uint256 _debtRatio) external onlyRole(GOVERNOR_ROLE) {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.lastReport == 0, \"73\");\n        require(address(this) == IStrategy(strategy).poolManager(), \"74\");\n        // Using current code, this condition should always be verified as in the constructor\n        // of the strategy the `want()` is set to the token of this `PoolManager`\n        require(address(token) == IStrategy(strategy).want(), \"75\");\n        require(debtRatio + _debtRatio <= BASE_PARAMS, \"76\");\n\n        // Add strategy to approved strategies\n        params.lastReport = 1;\n        params.totalStrategyDebt = 0;\n        params.debtRatio = _debtRatio;\n\n        _grantRole(STRATEGY_ROLE, strategy);\n\n        // Update global parameters\n        debtRatio += _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n\n        strategyList.push(strategy);\n    }\n\n    // =========================== Guardian Functions ==============================\n\n    /// @notice Changes the guardian address and echoes it to other contracts that interact with this `PoolManager`\n    /// @param _guardian New guardian address\n    /// @param guardian Old guardian address to revoke\n    function setGuardian(address _guardian, address guardian) external onlyRole(GUARDIAN_ROLE) {\n        // Granting the new role\n        // Access control for this contract\n        _grantRole(GUARDIAN_ROLE, _guardian);\n        // Propagating the new role in other contract\n        uint256 strategyListLength = strategyList.length;\n        for (uint256 i = 0; i < strategyListLength; i++) {\n            IStrategy(strategyList[i]).addGuardian(_guardian);\n        }\n        for (uint256 i = 0; i < strategyListLength; i++) {\n            IStrategy(strategyList[i]).revokeGuardian(guardian);\n        }\n        _revokeRole(GUARDIAN_ROLE, guardian);\n    }\n\n    /// @notice Modifies the funds a strategy has access to\n    /// @param strategy The address of the Strategy\n    /// @param _debtRatio The share of the total assets that the strategy has access to\n    /// @dev The update has to be such that the `debtRatio` does not exceeds the 100% threshold\n    /// as this `PoolManager` cannot lend collateral that it doesn't not own.\n    /// @dev `_debtRatio` is stored as a uint256 but as any parameter of the protocol, it should be expressed\n    /// in `BASE_PARAMS`\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external onlyRole(GUARDIAN_ROLE) {\n        _updateStrategyDebtRatio(strategy, _debtRatio);\n    }\n\n    /// @notice Triggers an emergency exit for a strategy and then harvests it to fetch all the funds\n    /// @param strategy The address of the `Strategy`\n    function setStrategyEmergencyExit(address strategy) external onlyRole(GUARDIAN_ROLE) {\n        _updateStrategyDebtRatio(strategy, 0);\n        IStrategy(strategy).setEmergencyExit();\n        IStrategy(strategy).harvest();\n    }\n\n    /// @notice Revokes a strategy\n    /// @param strategy The address of the strategy to revoke\n    /// @dev This should only be called after the following happened in order: the `strategy.debtRatio` has been set to 0,\n    /// `harvest` has been called enough times to recover all capital gain/losses.\n    function revokeStrategy(address strategy) external onlyRole(GUARDIAN_ROLE) {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.debtRatio == 0, \"77\");\n        require(params.totalStrategyDebt == 0, \"77\");\n        uint256 strategyListLength = strategyList.length;\n        require(params.lastReport != 0 && strategyListLength >= 1, \"78\");\n        // It has already been checked whether the strategy was a valid strategy\n        for (uint256 i = 0; i < strategyListLength - 1; i++) {\n            if (strategyList[i] == strategy) {\n                strategyList[i] = strategyList[strategyListLength - 1];\n                break;\n            }\n        }\n\n        strategyList.pop();\n\n        // Update global parameters\n        debtRatio -= params.debtRatio;\n        delete strategies[strategy];\n\n        _revokeRole(STRATEGY_ROLE, strategy);\n\n        emit StrategyRevoked(strategy);\n    }\n\n    /// @notice Withdraws a given amount from a strategy\n    /// @param strategy The address of the strategy\n    /// @param amount The amount to withdraw\n    /// @dev This function tries to recover `amount` from the strategy, but it may not go through\n    /// as we may not be able to withdraw from the lending protocol the full amount\n    /// @dev In this last case we only update the parameters by setting the loss as the gap between\n    /// what has been asked and what has been returned.\n    function withdrawFromStrategy(IStrategy strategy, uint256 amount) external onlyRole(GUARDIAN_ROLE) {\n        StrategyParams storage params = strategies[address(strategy)];\n        require(params.lastReport != 0, \"78\");\n\n        uint256 loss;\n        (amount, loss) = strategy.withdraw(amount);\n\n        // Handling eventual losses\n        params.totalStrategyDebt = params.totalStrategyDebt - loss - amount;\n        totalDebt = totalDebt - loss - amount;\n\n        emit StrategyReported(address(strategy), 0, loss, amount - loss, params.totalStrategyDebt);\n\n        // Handle eventual losses\n        // With the strategy we are using in current tests, it is going to be impossible to have\n        // a positive loss by calling strategy.withdraw, this function indeed calls _liquidatePosition\n        // which output value is always zero\n        // if (loss > 0) stableMaster.signalLoss(loss);\n    }\n\n    // =================== Surplus Distributor Function ============================\n\n    /// @notice Allows to push interests revenue accumulated by the protocol to the `surplusConverter` to do buybacks\n    ///  or another form of redistribution to ANGLE or veANGLE token holders\n    /// @dev This function is permissionless and anyone can transfer the `interestsAccumulated` by the protocol\n    /// to the `surplusConverter`\n    function pushSurplus() external {\n        // If the `surplusConverter` has not been initialized, surplus should not be distributed\n        // Storing the `surplusConverter` in an intermediate variable to avoid multiple reads in\n        // storage\n        address surplusConverterMem = surplusConverter;\n        require(surplusConverterMem != address(0), \"0\");\n        uint256 amount = interestsAccumulated;\n        interestsAccumulated = 0;\n        // Storing the `token` in memory to avoid duplicate reads in storage\n        IERC20 tokenMem = token;\n        tokenMem.safeTransfer(surplusConverterMem, amount);\n        emit Recovered(address(tokenMem), surplusConverterMem, amount);\n    }\n\n    // ======================== Getters - View Functions ===========================\n\n    /// @notice Gets the current balance of this `PoolManager` contract\n    /// @return The amount of the underlying collateral that the contract currently owns\n    /// @dev This balance does not take into account what has been lent to strategies\n    function getBalance() external view override returns (uint256) {\n        return _getBalance();\n    }\n\n    /// @notice Gets the total amount of collateral that is controlled by this `PoolManager` contract\n    /// @return The amount of collateral owned by this contract plus the amount that has been lent to strategies\n    /// @dev This is the value that is used to compute the debt ratio for a given strategy\n    function getTotalAsset() external view override returns (uint256) {\n        return _getTotalAsset();\n    }\n}\n"
    },
    "contracts/utils/FunctionUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\n/// @title FunctionUtils\n/// @author Angle Core Team\n/// @notice Contains all the utility functions that are needed in different places of the protocol\n/// @dev Functions in this contract should typically be pure functions\n/// @dev This contract is voluntarily a contract and not a library to save some gas cost every time it is used\ncontract FunctionUtils {\n    /// @notice Base that is used to compute ratios and floating numbers\n    uint256 public constant BASE_TOKENS = 10**18;\n    /// @notice Base that is used to define parameters that need to have a floating value (for instance parameters\n    /// that are defined as ratios)\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    /// @notice Computes the value of a linear by part function at a given point\n    /// @param x Point of the function we want to compute\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev The evolution of the linear by part function between two breaking points is linear\n    /// @dev Before the first breaking point and after the last one, the function is constant with a value\n    /// equal to the first or last value of the yArray\n    /// @dev This function is relevant if `x` is between O and `BASE_PARAMS`. If `x` is greater than that, then\n    /// everything will be as if `x` is equal to the greater element of the `xArray`\n    function _piecewiseLinear(\n        uint64 x,\n        uint64[] memory xArray,\n        uint64[] memory yArray\n    ) internal pure returns (uint64) {\n        if (x >= xArray[xArray.length - 1]) {\n            return yArray[xArray.length - 1];\n        } else if (x <= xArray[0]) {\n            return yArray[0];\n        } else {\n            uint256 lower;\n            uint256 upper = xArray.length - 1;\n            uint256 mid;\n            while (upper - lower > 1) {\n                mid = lower + (upper - lower) / 2;\n                if (xArray[mid] <= x) {\n                    lower = mid;\n                } else {\n                    upper = mid;\n                }\n            }\n            if (yArray[upper] > yArray[lower]) {\n                // There is no risk of overflow here as in the product of the difference of `y`\n                // with the difference of `x`, the product is inferior to `BASE_PARAMS**2` which does not\n                // overflow for `uint64`\n                return\n                    yArray[lower] +\n                    ((yArray[upper] - yArray[lower]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            } else {\n                return\n                    yArray[lower] -\n                    ((yArray[lower] - yArray[upper]) * (x - xArray[lower])) /\n                    (xArray[upper] - xArray[lower]);\n            }\n        }\n    }\n\n    /// @notice Checks if the input arrays given by governance to update the fee structure is valid\n    /// @param xArray List of breaking points (in ascending order) that define the linear by part function\n    /// @param yArray List of values at breaking points (not necessarily in ascending order)\n    /// @dev This function is a way to avoid some governance attacks or errors\n    /// @dev The modifier checks if the arrays have a non null length, if their length is the same, if the values\n    /// in the `xArray` are in ascending order and if the values in the `xArray` and in the `yArray` are not superior\n    /// to `BASE_PARAMS`\n    modifier onlyCompatibleInputArrays(uint64[] memory xArray, uint64[] memory yArray) {\n        require(xArray.length == yArray.length && xArray.length > 0, \"5\");\n        for (uint256 i = 0; i <= yArray.length - 1; i++) {\n            require(yArray[i] <= uint64(BASE_PARAMS) && xArray[i] <= uint64(BASE_PARAMS), \"6\");\n            if (i > 0) {\n                require(xArray[i] > xArray[i - 1], \"7\");\n            }\n        }\n        _;\n    }\n\n    /// @notice Checks if the new value given for the parameter is consistent (it should be inferior to 1\n    /// if it corresponds to a ratio)\n    /// @param fees Value of the new parameter to check\n    modifier onlyCompatibleFees(uint64 fees) {\n        require(fees <= BASE_PARAMS, \"4\");\n        _;\n    }\n\n    /// @notice Checks if the new address given is not null\n    /// @param newAddress Address to check\n    /// @dev Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation\n    modifier zeroCheck(address newAddress) {\n        require(newAddress != address(0), \"0\");\n        _;\n    }\n}\n"
    },
    "contracts/mock/MockPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { AccessControl } from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../interfaces/IPoolManager.sol\";\nimport \"../interfaces/IStrategy.sol\";\n\ncontract MockPoolManager is AccessControl {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE_TOKENS = 10**18;\n    uint256 public constant BASE_PARAMS = 10**9;\n\n    bytes32 public constant STRATEGY_ROLE = keccak256(\"STRATEGY_ROLE\");\n\n    mapping(address => StrategyParams) public strategies;\n    address[] public strategyList;\n\n    IERC20 public token;\n    uint256 public creditAvailable;\n    uint256 public totalDebt;\n    uint256 public debtRatio;\n\n    event StrategyReported(\n        address indexed strategy,\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment,\n        uint256 totalDebt\n    );\n    event StrategyAdded(address indexed strategy, uint256 debtRatio);\n    event StrategyRevoked(address indexed strategy);\n\n    constructor(address _token, uint256 _creditAvailable) {\n        token = IERC20(_token);\n        creditAvailable = _creditAvailable;\n    }\n\n    function debtOutstanding() external view returns (uint256) {\n        StrategyParams storage params = strategies[msg.sender];\n\n        uint256 target = (_getTotalAsset() * params.debtRatio) / BASE_PARAMS;\n\n        // console.log(\"debtOutstanding: totalStrategyDebt %s / target: %s / debtRatio: %s\", params.totalStrategyDebt, target, params.debtRatio);\n\n        if (target > params.totalStrategyDebt) return 0;\n\n        return (params.totalStrategyDebt - target);\n    }\n\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external {\n        require(token.balanceOf(msg.sender) >= gain + debtPayment, \"72\");\n\n        StrategyParams storage params = strategies[msg.sender];\n        // Updating parameters in the `perpetualManager`\n        // This needs to be done now because it has implications in `_getTotalAsset()`\n        params.totalStrategyDebt = params.totalStrategyDebt + gain - loss;\n        totalDebt = totalDebt + gain - loss;\n        params.lastReport = block.timestamp;\n\n        // Warning: `_getTotalAsset` could be manipulated by flashloan attacks.\n        // It may allow external users to transfer funds into strategy or remove funds\n        // from the strategy. Yet, as it does not impact the profit or loss and as attackers\n        // have no interest in making such txs to have a direct profit, we let it as is.\n        // The only issue is if the strategy is compromised; in this case governance\n        // should revoke the strategy\n        uint256 target = ((_getTotalAsset()) * params.debtRatio) / BASE_PARAMS;\n        // console.log(\"PoolManager - report\");\n        // console.log(\"_getTotalAsset %s / target %s\", _getTotalAsset(), target);\n        if (target > params.totalStrategyDebt) {\n            // If the strategy has some credit left, tokens can be transferred to this strategy\n            uint256 available = Math.min(target - params.totalStrategyDebt, _getBalance());\n            // console.log(\"available1 %s\", available);\n            params.totalStrategyDebt = params.totalStrategyDebt + available;\n            totalDebt = totalDebt + available;\n            if (available > 0) {\n                token.safeTransfer(msg.sender, available);\n            }\n        } else {\n            uint256 available = Math.min(params.totalStrategyDebt - target, debtPayment + gain);\n            // console.log(\"available2 %s\", available);\n            params.totalStrategyDebt = params.totalStrategyDebt - available;\n            totalDebt = totalDebt - available;\n            if (available > 0) {\n                token.safeTransferFrom(msg.sender, address(this), available);\n            }\n        }\n        emit StrategyReported(msg.sender, gain, loss, debtPayment, params.totalStrategyDebt);\n    }\n\n    function _getBalance() internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    function getTotalAsset() external view returns (uint256) {\n        return _getTotalAsset();\n    }\n\n    function _getTotalAsset() internal view returns (uint256) {\n        return _getBalance() + totalDebt;\n    }\n\n    function addStrategy(address strategy, uint256 _debtRatio) external {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.lastReport == 0, \"73\");\n        require(address(this) == IStrategy(strategy).poolManager(), \"74\");\n        // Using current code, this condition should always be verified as in the constructor\n        // of the strategy the `want()` is set to the token of this `PoolManager`\n        require(address(token) == IStrategy(strategy).want(), \"75\");\n        require(debtRatio + _debtRatio <= BASE_PARAMS, \"76\");\n\n        // Add strategy to approved strategies\n        params.lastReport = 1;\n        params.totalStrategyDebt = 0;\n        params.debtRatio = _debtRatio;\n\n        _grantRole(STRATEGY_ROLE, strategy);\n\n        // Update global parameters\n        debtRatio += _debtRatio;\n        emit StrategyAdded(strategy, debtRatio);\n\n        strategyList.push(strategy);\n    }\n\n    function revokeStrategy(address strategy) external {\n        StrategyParams storage params = strategies[strategy];\n\n        require(params.debtRatio == 0, \"77\");\n        require(params.totalStrategyDebt == 0, \"77\");\n        uint256 strategyListLength = strategyList.length;\n        require(params.lastReport != 0 && strategyListLength >= 1, \"78\");\n        // It has already been checked whether the strategy was a valid strategy\n        for (uint256 i = 0; i < strategyListLength - 1; i++) {\n            if (strategyList[i] == strategy) {\n                strategyList[i] = strategyList[strategyListLength - 1];\n                break;\n            }\n        }\n\n        strategyList.pop();\n\n        // Update global parameters\n        debtRatio -= params.debtRatio;\n        delete strategies[strategy];\n\n        _revokeRole(STRATEGY_ROLE, strategy);\n\n        emit StrategyRevoked(strategy);\n    }\n\n    function updateStrategyDebtRatio(address strategy, uint256 _debtRatio) external {\n        StrategyParams storage params = strategies[strategy];\n        require(params.lastReport != 0, \"78\");\n        debtRatio = debtRatio + _debtRatio - params.debtRatio;\n        require(debtRatio <= BASE_PARAMS, \"76\");\n        params.debtRatio = _debtRatio;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    uint8 internal _decimal;\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) ERC20(name_, symbol_) {\n        _decimal = decimal_;\n    }\n\n    /// @dev Returns the number of decimals used to get its user representation.\n    /// For example, if `decimals` equals `2`, a balance of `505` tokens should\n    /// be displayed to a user as `5,05` (`505 / 10 ** 2`).\n    function decimals() public view override returns (uint8) {\n        return _decimal;\n    }\n\n    /// @notice allow to mint\n    /// @param account the account to mint to\n    /// @param amount the amount to mint\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    /// @notice allow to burn\n    /// @param account the account to burn from\n    /// @param amount the amount of agToken to burn from caller\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function setAllowance(address from, address to) public {\n        _approve(from, to, type(uint256).max);\n    }\n}\n"
    },
    "contracts/mock/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./MockToken.sol\";\n\ncontract MockWETH is MockToken {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    receive() external payable {}\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) MockToken(name_, symbol_, decimal_) {}\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        _burn(msg.sender, wad);\n        (bool sent, ) = msg.sender.call{ value: wad }(\"\");\n        require(sent, \"Failed to send Ether\");\n        emit Withdrawal(msg.sender, wad);\n    }\n}\n"
    },
    "contracts/mock/MockStETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"./MockToken.sol\";\n\ncontract MockStETH is MockToken {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    /// @notice stablecoin constructor\n    /// @param name_ the stablecoin name (example 'agEUR')\n    /// @param symbol_ the stablecoin symbol ('agEUR')\n    /// @dev To account for the fact that the balance increases we can simply mint stETH to the concerned address\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimal_\n    ) MockToken(name_, symbol_, decimal_) {}\n\n    receive() external payable {}\n\n    function submit(address) external payable returns (uint256) {\n        _mint(msg.sender, msg.value);\n        return msg.value;\n    }\n}\n"
    },
    "contracts/mock/MockAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol\";\n\nimport \"../strategies/AaveFlashloanStrategy/AaveInterfaces.sol\";\n\nabstract contract MockAave is\n    IAaveIncentivesController,\n    ILendingPoolAddressesProvider,\n    IReserveInterestRateStrategy,\n    IStakedAave\n{\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**27;\n\n    uint256 public distributionEnd = type(uint256).max;\n    uint256 public emissionsPerSecond = 10;\n    uint256 public unstakeWindow = type(uint256).max;\n    uint256 public stakersCooldownsValue = 0;\n    uint256 public rewardsBalance = 0;\n\n    function getRewardsBalance(address[] calldata, address) external view override returns (uint256) {\n        return rewardsBalance;\n    }\n\n    function setRewardsBalance(uint256 _rewardsBalance) external {\n        rewardsBalance = _rewardsBalance;\n    }\n\n    function claimRewards(\n        address[] calldata,\n        uint256,\n        address\n    ) external pure override returns (uint256) {\n        return uint256(0);\n    }\n\n    function getDistributionEnd() external view override returns (uint256) {\n        return distributionEnd;\n    }\n\n    function setDistributionEnd(uint256 _distributionEnd) external {\n        distributionEnd = _distributionEnd;\n    }\n\n    function getAssetData(address)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (0, emissionsPerSecond, 0);\n    }\n\n    function setEmissionsPerSecond(uint256 _emissionsPerSecond) external {\n        emissionsPerSecond = _emissionsPerSecond;\n    }\n\n    function getLendingPool() external view override returns (address) {\n        return address(this);\n    }\n\n    function calculateInterestRates(\n        address,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        uint256\n    )\n        external\n        pure\n        override\n        returns (\n            uint256 liquidityRate,\n            uint256 stableBorrowRate,\n            uint256 variableBorrowRate\n        )\n    {\n        return (0.04 ether, 0.04 ether, 0.04 ether);\n    }\n\n    function stake(address to, uint256 amount) external override {}\n\n    function redeem(address to, uint256 amount) external override {}\n\n    function cooldown() external override {}\n\n    function claimRewards(address to, uint256 amount) external override {}\n\n    function getTotalRewardsBalance(address) external view override returns (uint256) {}\n\n    function COOLDOWN_SECONDS() external pure override returns (uint256) {\n        return 0;\n    }\n\n    function stakersCooldowns(address) external view override returns (uint256) {\n        return stakersCooldownsValue;\n    }\n\n    function UNSTAKE_WINDOW() external view override returns (uint256) {\n        return unstakeWindow;\n    }\n\n    function setUnstakeWindowAndStakers(uint256 _unstakeWindow, uint256 _stakersCooldownsValue) external {\n        unstakeWindow = _unstakeWindow;\n        stakersCooldownsValue = _stakersCooldownsValue;\n    }\n\n    function getPriceOracle() external view override returns (address) {\n        return address(this);\n    }\n\n    function getAssetsPrices(address[] calldata) external pure returns (uint256[] memory) {\n        uint256[] memory _ret = new uint256[](2);\n        _ret[0] = uint256(392936527437060);\n        _ret[1] = uint256(394087347138603);\n        return _ret;\n    }\n}\n\ncontract MockMKRLender {\n    mapping(address => uint256) public maxFlashLoan;\n    uint256 public compilerMuter;\n\n    constructor(address _token, uint256 _maxFlashLoan) {\n        maxFlashLoan[_token] = _maxFlashLoan;\n    }\n\n    function flashFee(address, uint256) external view returns (uint256) {\n        compilerMuter;\n        return 0;\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower,\n        address,\n        uint256,\n        bytes calldata\n    ) external returns (bool) {\n        compilerMuter = 0;\n        return true;\n    }\n}\n\ncontract MockAToken is ERC20 {\n    event Minting(address indexed _to, address indexed _minter, uint256 _amount);\n    event Burning(address indexed _from, address indexed _burner, uint256 _amount);\n\n    /// @notice constructor\n    /// @param name_ of the token lent\n    /// @param symbol_ of the token lent\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 decimals\n    ) ERC20(name_, symbol_) {}\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n        emit Minting(account, msg.sender, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n        emit Burning(account, msg.sender, amount);\n    }\n\n    function getIncentivesController() external view returns (IAaveIncentivesController) {\n        return IAaveIncentivesController(address(this));\n    }\n}\n\nabstract contract MockLendingPool is ILendingPool {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant BASE = 10**27;\n\n    MockAToken public immutable aToken;\n    MockAToken public immutable debtToken;\n    uint128 public currentLiquidityRate = 0;\n    uint256 public compilerMuter;\n\n    constructor(address _aToken, address _debtToken) {\n        aToken = MockAToken(_aToken);\n        debtToken = MockAToken(_debtToken);\n    }\n\n    mapping(address => uint256) public reserveNormalizedIncomes; // Mapping between an underlying asset and its reserveNoramlized income\n\n    function deployNewUnderlying(address underlying) external {\n        reserveNormalizedIncomes[underlying] = BASE;\n    }\n\n    function getReserveNormalizedIncome(address asset) external view override returns (uint256) {\n        return reserveNormalizedIncomes[asset] / BASE;\n    }\n\n    function changeReserveNormalizedIncome(uint256 newIncome, address asset) external {\n        reserveNormalizedIncomes[asset] = newIncome * BASE;\n    }\n\n    function setCurrentLiquidityRate(uint128 _liquidityRate) external {\n        currentLiquidityRate = _liquidityRate;\n    }\n\n    function getReserveData(address) external view override returns (DataTypes.ReserveData memory) {\n        return\n            DataTypes.ReserveData(\n                DataTypes.ReserveConfigurationMap(uint256(0)),\n                uint128(0),\n                uint128(0),\n                currentLiquidityRate,\n                uint128(0),\n                uint128(0),\n                uint40(0),\n                address(this),\n                address(this),\n                address(this),\n                address(this),\n                uint8(0)\n            );\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16\n    ) external override {\n        IERC20 underlying = IERC20(asset);\n        underlying.safeTransferFrom(msg.sender, address(this), amount);\n        // With Aave the amount of cToken is exactly what has been given\n        uint256 reserveNormalizedIncome_ = reserveNormalizedIncomes[asset];\n        aToken.mint(onBehalfOf, (amount * BASE) / reserveNormalizedIncome_); // Here we don't exactly respect what Aave is doing\n    }\n\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external override returns (uint256) {\n        uint256 reserveNormalizedIncome_ = reserveNormalizedIncomes[asset];\n        uint256 amountcToken = (amount * BASE) / reserveNormalizedIncome_;\n        aToken.burn(msg.sender, amountcToken);\n        uint256 amountToken = (amountcToken * reserveNormalizedIncome_) / BASE;\n        IERC20(asset).safeTransfer(to, amountToken);\n        return (amountToken);\n    }\n\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external override {}\n\n    function repay(\n        address,\n        uint256,\n        uint256,\n        address\n    ) external override returns (uint256) {\n        compilerMuter = 0;\n        return 0;\n    }\n}\n\ncontract MockProtocolDataProvider {\n    uint256 public availableLiquidityStorage = 0;\n\n    address public immutable aToken;\n    address public immutable debtToken;\n    MockAave public immutable mockAave;\n\n    constructor(\n        address _aToken,\n        address _debtToken,\n        address _mockAave\n    ) {\n        aToken = _aToken;\n        debtToken = _debtToken;\n        mockAave = MockAave(_mockAave);\n    }\n\n    function getReserveTokensAddresses(address)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        )\n    {\n        aTokenAddress = aToken;\n        stableDebtTokenAddress = debtToken;\n        variableDebtTokenAddress = debtToken;\n    }\n\n    function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider) {\n        return ILendingPoolAddressesProvider(mockAave);\n    }\n\n    function getReserveConfigurationData(address)\n        external\n        pure\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        )\n    {\n        // https://etherscan.io/address/0x057835ad21a177dbdd3090bb1cae03eacf78fc6d#readContract\n        return (uint256(6), uint256(8250), uint256(8500), uint256(10400), uint256(1000), true, true, true, true, false);\n    }\n\n    function setAvailableLiquidity(uint256 _availableLiquidity) external {\n        availableLiquidityStorage = _availableLiquidity;\n    }\n\n    function getReserveData(address)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        )\n    {\n        availableLiquidity = availableLiquidityStorage;\n        return (\n            availableLiquidity,\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint256(0),\n            uint40(0)\n        );\n    }\n}\n"
    },
    "contracts/mock/MockCurveStETHETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n// Contract we have to fix flash attacks\ncontract MockCurveStETHETH {\n    using SafeERC20 for IERC20;\n\n    address public stETH;\n    uint256 public dy;\n\n    constructor(address _stETH) {\n        stETH = _stETH;\n        dy = 10**18;\n    }\n\n    receive() external payable {}\n\n    function exchange(\n        int128 from,\n        int128 to,\n        uint256 _from_amount,\n        uint256\n    ) external payable {\n        if (from == 0 && to == 1) {\n            IERC20(stETH).transfer(msg.sender, (msg.value * dy) / 10**18);\n        } else {\n            IERC20(stETH).transferFrom(msg.sender, address(this), _from_amount);\n            (bool sent, ) = msg.sender.call{ value: (_from_amount * 10**18) / dy }(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n\n    function setDy(uint256 _dy) external {\n        dy = _dy;\n    }\n\n    function get_dy(\n        int128,\n        int128,\n        uint256 _from_amount\n    ) external view returns (uint256) {\n        return (_from_amount * dy) / 10**18;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/external/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin. It is fully forked from OpenZeppelin\n * `TransparentUpgradeableProxy`\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "contracts/interfaces/external/curve/IMetaPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMetaPool is IERC20 {\n    function get_previous_balances() external view returns (uint256[] memory);\n\n    function get_twap_balances(\n        uint256[] memory _first_balances,\n        uint256[] memory _last_balances,\n        uint256 _time_elapsed\n    ) external view returns (uint256[] memory);\n\n    function get_price_cumulative_last() external view returns (uint256[] memory);\n\n    function admin_fee() external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(uint256[] memory _amounts, bool _is_deposit) external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[] memory _amounts,\n        bool _is_deposit,\n        bool _previous\n    ) external view returns (uint256);\n\n    function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external returns (uint256);\n\n    function add_liquidity(\n        uint256[] memory _amounts,\n        uint256 _min_mint_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256[] memory _balances\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256[] memory _balances\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy,\n        address _receiver\n    ) external returns (uint256);\n\n    function remove_liquidity(uint256 _burn_amount, uint256[] memory _min_amounts) external returns (uint256[] memory);\n\n    function remove_liquidity(\n        uint256 _burn_amount,\n        uint256[] memory _min_amounts,\n        address _receiver\n    ) external returns (uint256[] memory);\n\n    function remove_liquidity_imbalance(uint256[] memory _amounts, uint256 _max_burn_amount) external returns (uint256);\n\n    function remove_liquidity_imbalance(\n        uint256[] memory _amounts,\n        uint256 _max_burn_amount,\n        address _receiver\n    ) external returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _burn_amount, int128 i) external view returns (uint256);\n\n    function calc_withdraw_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        bool _previous\n    ) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received,\n        address _receiver\n    ) external returns (uint256);\n\n    function admin_balances(uint256 i) external view returns (uint256);\n\n    function withdraw_admin_fees() external;\n}\n"
    },
    "contracts/interfaces/external/curve/ICurveCryptoSwapPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ICurveCryptoSwapPool is IERC20 {\n    function A() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_fee(uint256[3] memory amounts, uint256[3] memory xp) external view returns (uint256);\n\n    function calc_token_amount(uint256[3] memory amounts, bool deposit) external view returns (uint256);\n\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts) external;\n\n    function remove_liquidity_imbalance(uint256[3] memory amounts, uint256 max_burn_amount) external;\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n}\n"
    },
    "contracts/strategies/OptimizerAPR/genericLender/GenericAaveFraxStaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\nimport \"../../../interfaces/external/frax/IFraxUnifiedFarmTemplate.sol\";\nimport \"./GenericAaveUpgradeable.sol\";\n\n/// @title GenericAaveFraxStaker\n/// @author  Angle Core Team\n/// @notice `GenericAaveUpgradeable` implementation for FRAX where aFRAX obtained from Aave are staked on a FRAX contract\n/// to earn FXS incentives\ncontract GenericAaveFraxStaker is GenericAaveUpgradeable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    // ============================= Protocol Addresses ============================\n\n    AggregatorV3Interface private constant oracleFXS =\n        AggregatorV3Interface(0x6Ebc52C8C1089be9eB3945C4350B68B8E4C2233f);\n    IFraxUnifiedFarmTemplate private constant aFraxStakingContract =\n        IFraxUnifiedFarmTemplate(0x02577b426F223A6B4f2351315A19ecD6F357d65c);\n    uint256 private constant FRAX_IDX = 0;\n\n    // ================================ Variables ==================================\n\n    /// @notice Hash representing the position on Frax staker\n    bytes32 public kekId;\n    /// @notice Used to track the current liquidity (staked + interests) from Aave\n    uint256 public lastAaveReserveNormalizedIncome;\n    /// @notice Tracks the amount of FRAX controlled by the protocol and lent as aFRAX on Frax staking contract\n    /// This quantity increases due to the Aave native yield\n    uint256 private lastLiquidity;\n    /// @notice Last time a staker has been created\n    uint256 public lastCreatedStake;\n\n    // ================================ Parameters =================================\n\n    /// @notice Minimum amount of aFRAX to stake\n    uint256 private constant minStakingAmount = 1000 * 1e18; // 1000 aFrax\n    /// @notice Staking duration\n    uint256 public stakingPeriod;\n\n    // ==================================== Errors =================================\n\n    error NoLockedLiquidity();\n    error TooSmallStakingPeriod();\n\n    // ============================= Constructor ===================================\n\n    /// @notice Wrapper built on top of the `initializeAave` method to initialize the contract\n    /// @param _stakingPeriod Amount of time aFRAX must remain staked\n    /// @dev This function also initialized some FRAX related parameters like the staking period\n    function initialize(\n        address _strategy,\n        string memory name,\n        bool _isIncentivised,\n        address[] memory governorList,\n        address guardian,\n        address[] memory keeperList,\n        uint256 _stakingPeriod\n    ) external {\n        initializeAave(_strategy, name, _isIncentivised, governorList, guardian, keeperList);\n        if (_stakingPeriod < aFraxStakingContract.lock_time_min()) revert TooSmallStakingPeriod();\n        stakingPeriod = _stakingPeriod;\n        lastAaveReserveNormalizedIncome = _lendingPool.getReserveNormalizedIncome(address(want));\n    }\n\n    // =========================== External Function ===============================\n\n    /// @notice Permisionless function to claim rewards, reward tokens are directly sent to the contract and keeper/governance\n    /// can handle them via a `sweep` or a `sellRewards` call\n    function claimRewardsExternal() external returns (uint256[] memory) {\n        return aFraxStakingContract.getReward(address(this));\n    }\n\n    // =========================== Governance Functions ============================\n\n    /// @notice Updates the staking period on the aFRAX staking contract\n    function setLockTime(uint256 _stakingPeriod) external onlyRole(GUARDIAN_ROLE) {\n        if (_stakingPeriod < aFraxStakingContract.lock_time_min()) revert TooSmallStakingPeriod();\n        stakingPeriod = _stakingPeriod;\n    }\n\n    /// @notice Sets a proxy on the staking contract to obtain a delegation from an address with a boost\n    /// @dev Contract can have a multiplier on its FXS rewards if granted by someone with boosting power\n    /// @dev Can only be called after Frax governance called `aFraxStakingContract.toggleValidVeFXSProxy(proxy)`\n    /// and proxy called `aFraxStakingContract.proxyToggleStaker(address(this))`\n    function setProxyBoost(address proxy) external onlyRole(GUARDIAN_ROLE) {\n        aFraxStakingContract.stakerSetVeFXSProxy(proxy);\n    }\n\n    // ============================ Virtual Functions ==============================\n\n    /// @notice Implementation of the `_stake` function to stake aFRAX in the FRAX staking contract\n    /// @dev If there is an existent locker already on Frax staking contract (keckId != null), then this function adds to it\n    /// otherwise (if it's the first time we deposit or if last action was a withdraw) we need to create a new locker\n    /// @dev Currently there is no additional reward to stake more than the minimum period as there is no multiplier\n    function _stake(uint256 amount) internal override returns (uint256 stakedAmount) {\n        uint256 pastReserveNormalizedIncome = lastAaveReserveNormalizedIncome;\n        uint256 newReserveNormalizedIncome = _lendingPool.getReserveNormalizedIncome(address(want));\n        lastAaveReserveNormalizedIncome = newReserveNormalizedIncome;\n\n        IERC20(address(_aToken)).safeApprove(address(aFraxStakingContract), amount);\n        if (kekId == bytes32(0)) {\n            lastLiquidity = amount;\n            lastCreatedStake = block.timestamp;\n            kekId = aFraxStakingContract.stakeLocked(amount, stakingPeriod);\n        } else {\n            aFraxStakingContract.lockAdditional(kekId, amount);\n            // Updating the `lastLiquidity` value\n            lastLiquidity = (lastLiquidity * newReserveNormalizedIncome) / pastReserveNormalizedIncome + amount;\n        }\n        stakedAmount = amount;\n    }\n\n    /// @notice Implementation of the `_unstake` function\n    /// @dev If the minimum staking period is not finished, the function will revert\n    /// @dev This implementation assumes that there cannot any loss when staking on FRAX\n    function _unstake(uint256 amount) internal override returns (uint256 freedAmount) {\n        if (kekId == bytes32(0)) return 0;\n\n        lastAaveReserveNormalizedIncome = _lendingPool.getReserveNormalizedIncome(address(want));\n        freedAmount = aFraxStakingContract.withdrawLocked(kekId, address(this));\n\n        if (amount + minStakingAmount < freedAmount) {\n            // If too much has been withdrawn, we must create back a locker\n            lastCreatedStake = block.timestamp;\n            uint256 amountFRAXControlled = freedAmount - amount;\n            lastLiquidity = amountFRAXControlled;\n            IERC20(address(_aToken)).safeApprove(address(aFraxStakingContract), amountFRAXControlled);\n            kekId = aFraxStakingContract.stakeLocked(amountFRAXControlled, stakingPeriod);\n\n            // We need to round down the `freedAmount` value because values can be rounded down when transfering aTokens\n            // and we may stake slightly less than desired: to play it safe in all cases and avoid multiple calls, we\n            // systematically round down\n            freedAmount = amount - 1;\n        } else {\n            lastLiquidity = 0;\n            lastCreatedStake = 0;\n            delete kekId;\n        }\n    }\n\n    /// @notice Get current staked Frax balance (counting interest receive since last update)\n    function _stakedBalance() internal view override returns (uint256 amount) {\n        uint256 reserveNormalizedIncome = _lendingPool.getReserveNormalizedIncome(address(want));\n        return (lastLiquidity * reserveNormalizedIncome) / lastAaveReserveNormalizedIncome;\n    }\n\n    /// @notice Get stakingAPR after staking an additional `amount`\n    /// @param amount Virtual amount to be staked\n    function _stakingApr(uint256 amount) internal view override returns (uint256 apr) {\n        // These computations are made possible only because there can only be one staker in the contract\n        (uint256 oldCombinedWeight, uint256 newVefxsMultiplier, uint256 newCombinedWeight) = aFraxStakingContract\n            .calcCurCombinedWeight(address(this));\n\n        uint256 newBalance;\n        // If we didn't stake anything and we don't have anything to give, then stakingApr can only be 0\n        if (lastLiquidity == 0 && amount == 0) return 0;\n        // If we didn't stake we need an extra info on the multiplier per staking period\n        // otherwise we reverse engineer the function\n        else if (lastLiquidity == 0) {\n            newBalance = amount;\n            newCombinedWeight =\n                (newBalance * (aFraxStakingContract.lockMultiplier(stakingPeriod) + newVefxsMultiplier)) /\n                1 ether;\n        } else {\n            newBalance = (_stakedBalance() + amount);\n            newCombinedWeight = (newBalance * newCombinedWeight) / lastLiquidity;\n        }\n\n        // If we arrive up until here the `totalCombinedWeight` can only be non null\n        uint256 totalCombinedWeight = aFraxStakingContract.totalCombinedWeight() +\n            newCombinedWeight -\n            oldCombinedWeight;\n\n        uint256 rewardRate = (newCombinedWeight * aFraxStakingContract.rewardRates(FRAX_IDX)) / totalCombinedWeight;\n\n        // APRs are in 1e18 and a 5% penalty on the FXS price is taken to avoid overestimations\n        apr = (_estimatedFXSToWant(rewardRate * _SECONDS_IN_YEAR) * 9500 * 1 ether) / 10000 / newBalance;\n    }\n\n    // ============================ Internal Functions =============================\n\n    /// @notice Estimates the amount of `want` we will get out by swapping it for FXS\n    /// @param amount Amount of FXS we want to exchange (in base 18)\n    /// @return swappedAmount Amount of `want` we are getting but in a global base 18\n    /// @dev Uses Chainlink spot price\n    /// @dev This implementation assumes that 1 FRAX = 1 USD, as it does not do any FRAX -> USD conversion\n    function _estimatedFXSToWant(uint256 amount) internal view returns (uint256) {\n        (, int256 fxsPriceUSD, , , ) = oracleFXS.latestRoundData();\n        // fxsPriceUSD is in base 8\n        return (uint256(fxsPriceUSD) * amount) / 1e8;\n    }\n}\n"
    },
    "contracts/interfaces/external/frax/IFraxUnifiedFarmTemplate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.12;\n\ninterface IFraxUnifiedFarmTemplate {\n    // Struct for the stake\n    struct LockedStake {\n        bytes32 kek_id;\n        uint256 start_timestamp;\n        uint256 liquidity;\n        uint256 ending_timestamp;\n        uint256 lock_multiplier; // 6 decimals of precision. 1x = 1000000\n    }\n\n    // Calculate the combined weight for an account\n    function calcCurCombinedWeight(address account)\n        external\n        view\n        returns (\n            uint256 old_combined_weight,\n            uint256 new_vefxs_multiplier,\n            uint256 new_combined_weight\n        );\n\n    // get the current minimum lockTime on the staking contract\n    function lock_time_min() external view returns (uint256);\n\n    /// @notice Send the rewards to the destination\n    /// @return Array of all sent rewards (only the amounts you need to know the order of the rewards)\n    function getReward(address destination_address) external returns (uint256[] memory);\n\n    // ------ LOCK RELATED ------\n\n    // Add additional LPs to an existing locked stake\n    // REBASE: If you simply want to accrue interest, call this with addl_liq = 0\n    function lockAdditional(bytes32 kek_id, uint256 addl_liq) external;\n\n    /// @notice Two different stake functions are needed because of delegateCall and msg.sender issues (important for migration)\n    /// @return the keckId\n    function stakeLocked(uint256 liquidity, uint256 secs) external returns (bytes32);\n\n    // ------ WITHDRAWING ------\n\n    /// @notice Each withdraw will delete the locked associated to the `keck_id`\n    /// @return Liquidity withdrawn from the locker\n    function withdrawLocked(bytes32 kek_id, address destination_address) external returns (uint256);\n\n    // ------ REWARDS ------\n\n    function stakerSetVeFXSProxy(address proxy_address) external;\n\n    function rewardRates(uint256 token_idx) external view returns (uint256 rwd_rate);\n\n    function lockMultiplier(uint256 secs) external view returns (uint256);\n\n    function totalCombinedWeight() external view returns (uint256);\n}\n"
    },
    "contracts/mock/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.12;\n\nimport \"../interfaces/IPoolManager.sol\";\n\ncontract MockStrategy {\n    address public poolManager;\n\n    address public want;\n\n    constructor(address _poolManager, address _want) {\n        poolManager = _poolManager;\n        want = _want;\n    }\n\n    function report(\n        uint256 gain,\n        uint256 loss,\n        uint256 debtPayment\n    ) external {\n        IPoolManager(poolManager).report(gain, loss, debtPayment);\n    }\n\n    function withdraw(uint256 amount) external pure returns (uint256, uint256) {\n        return (amount, 1);\n    }\n\n    function creditAvailable() external view returns (uint256 credit) {\n        credit = IPoolManager(poolManager).creditAvailable();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 3000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}